schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input CreateCampaignInput {
  campaignId: String!
  guided: Boolean
  linked: LinkedCampaignId
}

type CreateCampaignOutput {
  campaignId: Int!
  campaignIdA: Int
  campaignIdB: Int
}

input CreateDeckInput {
  description: String
  ignoreDeckLimitSlots: jsonb!
  investigator: String!
  meta: jsonb
  name: String!
  problem: String
  slots: jsonb!
  tabooSetId: Int
  tags: String
}

type CreateDeckOutput {
  deck: arkhamdb_deck
  deckId: String!
}

type DeckId {
  campaignId: Int!
  id: Int!
}

input DeleteCampaignInput {
  campaignId: String!
  serverId: Int!
}

type DeleteCampaignOutput {
  campaignId: Int!
}

input DeleteDeckInput {
  deckId: Int!
  deleteAllVersions: Boolean!
}

type DeleteDeckOutput {
  success: Boolean!
}

enum EditAccessAction {
  grant
  revoke
}

input EditCampaignAccessInput {
  action: EditAccessAction!
  campaignId: String!
  serverId: Int!
  users: [String!]!
}

type EditCampaignAccessOutput {
  campaignId: Int!
}

enum FriendRequestAction {
  request
  revoke
}

input FriendRequestInput {
  action: FriendRequestAction!
  userId: String!
}

type FriendRequestOutput {
  success: Boolean!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input LinkedCampaignId {
  campaignIdA: String!
  campaignIdB: String!
}

input LoginInput {
  code: String!
  redirectUri: String!
  state: String!
}

type LoginOutput {
  success: Boolean!
}

type LogoutOutput {
  success: Boolean!
}

input MigrateLoginInput {
  accessToken: String!
  refreshToken: String!
}

type MigrateLoginOutput {
  success: Boolean!
}

input RefreshDecksInput {
  force: Boolean!
}

type RefreshDecksOutput {
  updated: Boolean!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input UpdateHandleInput {
  handle: String!
  userId: String
}

type UpdateHandleOutput {
  success: Boolean!
  user: users
  userId: String!
}

input UpgradeDeckInput {
  deckId: Int!
  exiles: jsonb
  xp: Int!
}

type UpgradeDeckOutput {
  deckId: Int!
  upgradedDeckId: Int!
}

input UploadLocalCampaignDeckInput {
  arkhamDbId: Int!
  localDeckId: String!
}

type UploadLocalCampaignDeckOutput {
  deckIds: [DeckId!]!
}

type UserSearchResult {
  handle: String!
  id: String!
}

input UsersSearchInput {
  continueToken: String
  search: String!
}

type UsersSearchOutput {
  hasMore: String!
  users: [UserSearchResult!]!
}

scalar _text

"""
columns and relationships of "all_card"
"""
type all_card {
  alt_art_investigator: Boolean
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  clues_fixed: Boolean
  code: String!
  cost: Int
  customization_options(
    """JSON select path"""
    path: String
  ): jsonb
  deck_limit: Int
  deck_options(
    """JSON select path"""
    path: String
  ): jsonb
  deck_requirements(
    """JSON select path"""
    path: String
  ): jsonb
  doom: Int
  double_sided: Boolean
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int

  """An array relationship"""
  encounter_sets(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): [card_encounter_set!]!

  """An aggregate relationship"""
  encounter_sets_aggregate(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): card_encounter_set_aggregate!
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String!
  gender: gender_enum
  heals_damage: Boolean
  heals_horror: Boolean
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  id: String!
  illustrator: String
  imagesrc: String
  imageurl: String
  is_unique: Boolean
  linked: Boolean

  """An object relationship"""
  linked_card: all_card
  myriad: Boolean
  official: Boolean!

  """An object relationship"""
  pack: pack!
  pack_code: String!
  pack_position: Int!

  """An array relationship"""
  packs(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """An aggregate relationship"""
  packs_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!
  permanent: Boolean
  position: Int!
  preview: Boolean
  quantity: Int!
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String!
  real_pack_name: String!
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  restrictions(
    """JSON select path"""
    path: String
  ): jsonb
  sanity: Int
  shroud: Int
  side_deck_options(
    """JSON select path"""
    path: String
  ): jsonb
  side_deck_requirements(
    """JSON select path"""
    path: String
  ): jsonb
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  spoiler: Boolean
  stage: Int
  subtype_code: String
  taboo_placeholder: Boolean

  """An object relationship"""
  taboo_set: taboo_set
  taboo_set_id: Int
  taboo_xp: Int
  tags(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): [all_card_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): all_card_text_aggregate!

  """An object relationship"""
  type: card_type_code!
  type_code: card_type_code_enum!
  updated_at: timestamptz
  vengeance: Int
  version: Int!
  victory: Int
  xp: Int
}

"""
aggregated selection of "all_card"
"""
type all_card_aggregate {
  aggregate: all_card_aggregate_fields
  nodes: [all_card!]!
}

input all_card_aggregate_bool_exp {
  bool_and: all_card_aggregate_bool_exp_bool_and
  bool_or: all_card_aggregate_bool_exp_bool_or
  count: all_card_aggregate_bool_exp_count
}

input all_card_aggregate_bool_exp_bool_and {
  arguments: all_card_select_column_all_card_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: all_card_bool_exp
  predicate: Boolean_comparison_exp!
}

input all_card_aggregate_bool_exp_bool_or {
  arguments: all_card_select_column_all_card_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: all_card_bool_exp
  predicate: Boolean_comparison_exp!
}

input all_card_aggregate_bool_exp_count {
  arguments: [all_card_select_column!]
  distinct: Boolean
  filter: all_card_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "all_card"
"""
type all_card_aggregate_fields {
  avg: all_card_avg_fields
  count(columns: [all_card_select_column!], distinct: Boolean): Int!
  max: all_card_max_fields
  min: all_card_min_fields
  stddev: all_card_stddev_fields
  stddev_pop: all_card_stddev_pop_fields
  stddev_samp: all_card_stddev_samp_fields
  sum: all_card_sum_fields
  var_pop: all_card_var_pop_fields
  var_samp: all_card_var_samp_fields
  variance: all_card_variance_fields
}

"""
order by aggregate values of table "all_card"
"""
input all_card_aggregate_order_by {
  avg: all_card_avg_order_by
  count: order_by
  max: all_card_max_order_by
  min: all_card_min_order_by
  stddev: all_card_stddev_order_by
  stddev_pop: all_card_stddev_pop_order_by
  stddev_samp: all_card_stddev_samp_order_by
  sum: all_card_sum_order_by
  var_pop: all_card_var_pop_order_by
  var_samp: all_card_var_samp_order_by
  variance: all_card_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input all_card_append_input {
  customization_options: jsonb
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
  side_deck_options: jsonb
  side_deck_requirements: jsonb
  tags: jsonb
}

"""
input type for inserting array relation for remote table "all_card"
"""
input all_card_arr_rel_insert_input {
  data: [all_card_insert_input!]!

  """upsert condition"""
  on_conflict: all_card_on_conflict
}

"""aggregate avg on columns"""
type all_card_avg_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by avg() on columns of table "all_card"
"""
input all_card_avg_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""
Boolean expression to filter rows from the table "all_card". All fields are combined with a logical 'AND'.
"""
input all_card_bool_exp {
  _and: [all_card_bool_exp!]
  _not: all_card_bool_exp
  _or: [all_card_bool_exp!]
  alt_art_investigator: Boolean_comparison_exp
  alternate_of_code: String_comparison_exp
  alternate_required_code: String_comparison_exp
  back_illustrator: String_comparison_exp
  back_link_id: String_comparison_exp
  backimagesrc: String_comparison_exp
  backimageurl: String_comparison_exp
  clues: Int_comparison_exp
  clues_fixed: Boolean_comparison_exp
  code: String_comparison_exp
  cost: Int_comparison_exp
  customization_options: jsonb_comparison_exp
  deck_limit: Int_comparison_exp
  deck_options: jsonb_comparison_exp
  deck_requirements: jsonb_comparison_exp
  doom: Int_comparison_exp
  double_sided: Boolean_comparison_exp
  duplicate_of_code: String_comparison_exp
  encounter_code: String_comparison_exp
  encounter_position: Int_comparison_exp
  encounter_sets: card_encounter_set_bool_exp
  encounter_sets_aggregate: card_encounter_set_aggregate_bool_exp
  enemy_damage: Int_comparison_exp
  enemy_evade: Int_comparison_exp
  enemy_fight: Int_comparison_exp
  enemy_horror: Int_comparison_exp
  errata_date: String_comparison_exp
  exceptional: Boolean_comparison_exp
  exile: Boolean_comparison_exp
  faction2_code: String_comparison_exp
  faction3_code: String_comparison_exp
  faction_code: String_comparison_exp
  gender: gender_enum_comparison_exp
  heals_damage: Boolean_comparison_exp
  heals_horror: Boolean_comparison_exp
  health: Int_comparison_exp
  health_per_investigator: Boolean_comparison_exp
  hidden: Boolean_comparison_exp
  id: String_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  imageurl: String_comparison_exp
  is_unique: Boolean_comparison_exp
  linked: Boolean_comparison_exp
  linked_card: all_card_bool_exp
  myriad: Boolean_comparison_exp
  official: Boolean_comparison_exp
  pack: pack_bool_exp
  pack_code: String_comparison_exp
  pack_position: Int_comparison_exp
  packs: card_pack_bool_exp
  packs_aggregate: card_pack_aggregate_bool_exp
  permanent: Boolean_comparison_exp
  position: Int_comparison_exp
  preview: Boolean_comparison_exp
  quantity: Int_comparison_exp
  real_back_flavor: String_comparison_exp
  real_back_name: String_comparison_exp
  real_back_text: String_comparison_exp
  real_back_traits: String_comparison_exp
  real_customization_change: String_comparison_exp
  real_customization_text: String_comparison_exp
  real_encounter_set_name: String_comparison_exp
  real_flavor: String_comparison_exp
  real_name: String_comparison_exp
  real_pack_name: String_comparison_exp
  real_slot: String_comparison_exp
  real_subname: String_comparison_exp
  real_taboo_original_back_text: String_comparison_exp
  real_taboo_original_text: String_comparison_exp
  real_taboo_text_change: String_comparison_exp
  real_text: String_comparison_exp
  real_traits: String_comparison_exp
  restrictions: jsonb_comparison_exp
  sanity: Int_comparison_exp
  shroud: Int_comparison_exp
  side_deck_options: jsonb_comparison_exp
  side_deck_requirements: jsonb_comparison_exp
  skill_agility: Int_comparison_exp
  skill_combat: Int_comparison_exp
  skill_intellect: Int_comparison_exp
  skill_wild: Int_comparison_exp
  skill_willpower: Int_comparison_exp
  spoiler: Boolean_comparison_exp
  stage: Int_comparison_exp
  subtype_code: String_comparison_exp
  taboo_placeholder: Boolean_comparison_exp
  taboo_set: taboo_set_bool_exp
  taboo_set_id: Int_comparison_exp
  taboo_xp: Int_comparison_exp
  tags: jsonb_comparison_exp
  translations: all_card_text_bool_exp
  translations_aggregate: all_card_text_aggregate_bool_exp
  type: card_type_code_bool_exp
  type_code: card_type_code_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  vengeance: Int_comparison_exp
  version: Int_comparison_exp
  victory: Int_comparison_exp
  xp: Int_comparison_exp
}

"""
unique or primary key constraints on table "all_card"
"""
enum all_card_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  all_card_id_key

  """
  unique or primary key constraint on columns "id"
  """
  all_card_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input all_card_delete_at_path_input {
  customization_options: [String!]
  deck_options: [String!]
  deck_requirements: [String!]
  restrictions: [String!]
  side_deck_options: [String!]
  side_deck_requirements: [String!]
  tags: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input all_card_delete_elem_input {
  customization_options: Int
  deck_options: Int
  deck_requirements: Int
  restrictions: Int
  side_deck_options: Int
  side_deck_requirements: Int
  tags: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input all_card_delete_key_input {
  customization_options: String
  deck_options: String
  deck_requirements: String
  restrictions: String
  side_deck_options: String
  side_deck_requirements: String
  tags: String
}

"""
input type for incrementing numeric columns in table "all_card"
"""
input all_card_inc_input {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  taboo_set_id: Int
  taboo_xp: Int
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
input type for inserting data into table "all_card"
"""
input all_card_insert_input {
  alt_art_investigator: Boolean
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  customization_options: jsonb
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int
  encounter_sets: card_encounter_set_arr_rel_insert_input
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  gender: gender_enum
  heals_damage: Boolean
  heals_horror: Boolean
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  id: String
  illustrator: String
  imagesrc: String
  imageurl: String
  is_unique: Boolean
  linked: Boolean
  linked_card: all_card_obj_rel_insert_input
  myriad: Boolean
  official: Boolean
  pack: pack_obj_rel_insert_input
  pack_code: String
  pack_position: Int
  packs: card_pack_arr_rel_insert_input
  permanent: Boolean
  position: Int
  preview: Boolean
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  side_deck_options: jsonb
  side_deck_requirements: jsonb
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  spoiler: Boolean
  stage: Int
  subtype_code: String
  taboo_placeholder: Boolean
  taboo_set: taboo_set_obj_rel_insert_input
  taboo_set_id: Int
  taboo_xp: Int
  tags: jsonb
  translations: all_card_text_arr_rel_insert_input
  type: card_type_code_obj_rel_insert_input
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate max on columns"""
type all_card_max_fields {
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  imageurl: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  taboo_set_id: Int
  taboo_xp: Int
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
order by max() on columns of table "all_card"
"""
input all_card_max_order_by {
  alternate_of_code: order_by
  alternate_required_code: order_by
  back_illustrator: order_by
  back_link_id: order_by
  backimagesrc: order_by
  backimageurl: order_by
  clues: order_by
  code: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  duplicate_of_code: order_by
  encounter_code: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  errata_date: order_by
  faction2_code: order_by
  faction3_code: order_by
  faction_code: order_by
  health: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  imageurl: order_by
  pack_code: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_name: order_by
  real_back_text: order_by
  real_back_traits: order_by
  real_customization_change: order_by
  real_customization_text: order_by
  real_encounter_set_name: order_by
  real_flavor: order_by
  real_name: order_by
  real_pack_name: order_by
  real_slot: order_by
  real_subname: order_by
  real_taboo_original_back_text: order_by
  real_taboo_original_text: order_by
  real_taboo_text_change: order_by
  real_text: order_by
  real_traits: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  subtype_code: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  updated_at: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""aggregate min on columns"""
type all_card_min_fields {
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  imageurl: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  taboo_set_id: Int
  taboo_xp: Int
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
order by min() on columns of table "all_card"
"""
input all_card_min_order_by {
  alternate_of_code: order_by
  alternate_required_code: order_by
  back_illustrator: order_by
  back_link_id: order_by
  backimagesrc: order_by
  backimageurl: order_by
  clues: order_by
  code: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  duplicate_of_code: order_by
  encounter_code: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  errata_date: order_by
  faction2_code: order_by
  faction3_code: order_by
  faction_code: order_by
  health: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  imageurl: order_by
  pack_code: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_name: order_by
  real_back_text: order_by
  real_back_traits: order_by
  real_customization_change: order_by
  real_customization_text: order_by
  real_encounter_set_name: order_by
  real_flavor: order_by
  real_name: order_by
  real_pack_name: order_by
  real_slot: order_by
  real_subname: order_by
  real_taboo_original_back_text: order_by
  real_taboo_original_text: order_by
  real_taboo_text_change: order_by
  real_text: order_by
  real_traits: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  subtype_code: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  updated_at: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""
response of any mutation on the table "all_card"
"""
type all_card_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [all_card!]!
}

"""
input type for inserting object relation for remote table "all_card"
"""
input all_card_obj_rel_insert_input {
  data: all_card_insert_input!

  """upsert condition"""
  on_conflict: all_card_on_conflict
}

"""
on_conflict condition type for table "all_card"
"""
input all_card_on_conflict {
  constraint: all_card_constraint!
  update_columns: [all_card_update_column!]! = []
  where: all_card_bool_exp
}

"""Ordering options when selecting data from "all_card"."""
input all_card_order_by {
  alt_art_investigator: order_by
  alternate_of_code: order_by
  alternate_required_code: order_by
  back_illustrator: order_by
  back_link_id: order_by
  backimagesrc: order_by
  backimageurl: order_by
  clues: order_by
  clues_fixed: order_by
  code: order_by
  cost: order_by
  customization_options: order_by
  deck_limit: order_by
  deck_options: order_by
  deck_requirements: order_by
  doom: order_by
  double_sided: order_by
  duplicate_of_code: order_by
  encounter_code: order_by
  encounter_position: order_by
  encounter_sets_aggregate: card_encounter_set_aggregate_order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  errata_date: order_by
  exceptional: order_by
  exile: order_by
  faction2_code: order_by
  faction3_code: order_by
  faction_code: order_by
  gender: order_by
  heals_damage: order_by
  heals_horror: order_by
  health: order_by
  health_per_investigator: order_by
  hidden: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  imageurl: order_by
  is_unique: order_by
  linked: order_by
  linked_card: all_card_order_by
  myriad: order_by
  official: order_by
  pack: pack_order_by
  pack_code: order_by
  pack_position: order_by
  packs_aggregate: card_pack_aggregate_order_by
  permanent: order_by
  position: order_by
  preview: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_name: order_by
  real_back_text: order_by
  real_back_traits: order_by
  real_customization_change: order_by
  real_customization_text: order_by
  real_encounter_set_name: order_by
  real_flavor: order_by
  real_name: order_by
  real_pack_name: order_by
  real_slot: order_by
  real_subname: order_by
  real_taboo_original_back_text: order_by
  real_taboo_original_text: order_by
  real_taboo_text_change: order_by
  real_text: order_by
  real_traits: order_by
  restrictions: order_by
  sanity: order_by
  shroud: order_by
  side_deck_options: order_by
  side_deck_requirements: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  spoiler: order_by
  stage: order_by
  subtype_code: order_by
  taboo_placeholder: order_by
  taboo_set: taboo_set_order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  tags: order_by
  translations_aggregate: all_card_text_aggregate_order_by
  type: card_type_code_order_by
  type_code: order_by
  updated_at: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""primary key columns input for table: all_card"""
input all_card_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input all_card_prepend_input {
  customization_options: jsonb
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
  side_deck_options: jsonb
  side_deck_requirements: jsonb
  tags: jsonb
}

"""
select columns of table "all_card"
"""
enum all_card_select_column {
  """column name"""
  alt_art_investigator

  """column name"""
  alternate_of_code

  """column name"""
  alternate_required_code

  """column name"""
  back_illustrator

  """column name"""
  back_link_id

  """column name"""
  backimagesrc

  """column name"""
  backimageurl

  """column name"""
  clues

  """column name"""
  clues_fixed

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  customization_options

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  duplicate_of_code

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  errata_date

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction2_code

  """column name"""
  faction3_code

  """column name"""
  faction_code

  """column name"""
  gender

  """column name"""
  heals_damage

  """column name"""
  heals_horror

  """column name"""
  health

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  imageurl

  """column name"""
  is_unique

  """column name"""
  linked

  """column name"""
  myriad

  """column name"""
  official

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  preview

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_back_traits

  """column name"""
  real_customization_change

  """column name"""
  real_customization_text

  """column name"""
  real_encounter_set_name

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_taboo_original_back_text

  """column name"""
  real_taboo_original_text

  """column name"""
  real_taboo_text_change

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  side_deck_options

  """column name"""
  side_deck_requirements

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  spoiler

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  taboo_placeholder

  """column name"""
  taboo_set_id

  """column name"""
  taboo_xp

  """column name"""
  tags

  """column name"""
  type_code

  """column name"""
  updated_at

  """column name"""
  vengeance

  """column name"""
  version

  """column name"""
  victory

  """column name"""
  xp
}

"""
select "all_card_aggregate_bool_exp_bool_and_arguments_columns" columns of table "all_card"
"""
enum all_card_select_column_all_card_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  alt_art_investigator

  """column name"""
  clues_fixed

  """column name"""
  double_sided

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  heals_damage

  """column name"""
  heals_horror

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  is_unique

  """column name"""
  linked

  """column name"""
  myriad

  """column name"""
  official

  """column name"""
  permanent

  """column name"""
  preview

  """column name"""
  spoiler

  """column name"""
  taboo_placeholder
}

"""
select "all_card_aggregate_bool_exp_bool_or_arguments_columns" columns of table "all_card"
"""
enum all_card_select_column_all_card_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  alt_art_investigator

  """column name"""
  clues_fixed

  """column name"""
  double_sided

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  heals_damage

  """column name"""
  heals_horror

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  is_unique

  """column name"""
  linked

  """column name"""
  myriad

  """column name"""
  official

  """column name"""
  permanent

  """column name"""
  preview

  """column name"""
  spoiler

  """column name"""
  taboo_placeholder
}

"""
input type for updating data in table "all_card"
"""
input all_card_set_input {
  alt_art_investigator: Boolean
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  customization_options: jsonb
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  gender: gender_enum
  heals_damage: Boolean
  heals_horror: Boolean
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  id: String
  illustrator: String
  imagesrc: String
  imageurl: String
  is_unique: Boolean
  linked: Boolean
  myriad: Boolean
  official: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  preview: Boolean
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  side_deck_options: jsonb
  side_deck_requirements: jsonb
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  spoiler: Boolean
  stage: Int
  subtype_code: String
  taboo_placeholder: Boolean
  taboo_set_id: Int
  taboo_xp: Int
  tags: jsonb
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate stddev on columns"""
type all_card_stddev_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by stddev() on columns of table "all_card"
"""
input all_card_stddev_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""aggregate stddev_pop on columns"""
type all_card_stddev_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by stddev_pop() on columns of table "all_card"
"""
input all_card_stddev_pop_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""aggregate stddev_samp on columns"""
type all_card_stddev_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by stddev_samp() on columns of table "all_card"
"""
input all_card_stddev_samp_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""
Streaming cursor of the table "all_card"
"""
input all_card_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: all_card_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input all_card_stream_cursor_value_input {
  alt_art_investigator: Boolean
  alternate_of_code: String
  alternate_required_code: String
  back_illustrator: String
  back_link_id: String
  backimagesrc: String
  backimageurl: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  customization_options: jsonb
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  duplicate_of_code: String
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  errata_date: String
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  gender: gender_enum
  heals_damage: Boolean
  heals_horror: Boolean
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  id: String
  illustrator: String
  imagesrc: String
  imageurl: String
  is_unique: Boolean
  linked: Boolean
  myriad: Boolean
  official: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  preview: Boolean
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_back_traits: String
  real_customization_change: String
  real_customization_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_taboo_original_back_text: String
  real_taboo_original_text: String
  real_taboo_text_change: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  side_deck_options: jsonb
  side_deck_requirements: jsonb
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  spoiler: Boolean
  stage: Int
  subtype_code: String
  taboo_placeholder: Boolean
  taboo_set_id: Int
  taboo_xp: Int
  tags: jsonb
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate sum on columns"""
type all_card_sum_fields {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  taboo_set_id: Int
  taboo_xp: Int
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
order by sum() on columns of table "all_card"
"""
input all_card_sum_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""
columns and relationships of "all_card_text"
"""
type all_card_text {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String!
  imageurl: String
  locale: String!
  name: String!
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
aggregated selection of "all_card_text"
"""
type all_card_text_aggregate {
  aggregate: all_card_text_aggregate_fields
  nodes: [all_card_text!]!
}

input all_card_text_aggregate_bool_exp {
  count: all_card_text_aggregate_bool_exp_count
}

input all_card_text_aggregate_bool_exp_count {
  arguments: [all_card_text_select_column!]
  distinct: Boolean
  filter: all_card_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "all_card_text"
"""
type all_card_text_aggregate_fields {
  count(columns: [all_card_text_select_column!], distinct: Boolean): Int!
  max: all_card_text_max_fields
  min: all_card_text_min_fields
}

"""
order by aggregate values of table "all_card_text"
"""
input all_card_text_aggregate_order_by {
  count: order_by
  max: all_card_text_max_order_by
  min: all_card_text_min_order_by
}

"""
input type for inserting array relation for remote table "all_card_text"
"""
input all_card_text_arr_rel_insert_input {
  data: [all_card_text_insert_input!]!

  """upsert condition"""
  on_conflict: all_card_text_on_conflict
}

"""
Boolean expression to filter rows from the table "all_card_text". All fields are combined with a logical 'AND'.
"""
input all_card_text_bool_exp {
  _and: [all_card_text_bool_exp!]
  _not: all_card_text_bool_exp
  _or: [all_card_text_bool_exp!]
  back_flavor: String_comparison_exp
  back_name: String_comparison_exp
  back_text: String_comparison_exp
  back_traits: String_comparison_exp
  backimageurl: String_comparison_exp
  customization_change: String_comparison_exp
  customization_text: String_comparison_exp
  encounter_name: String_comparison_exp
  flavor: String_comparison_exp
  id: String_comparison_exp
  imageurl: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  slot: String_comparison_exp
  subname: String_comparison_exp
  taboo_original_back_text: String_comparison_exp
  taboo_original_text: String_comparison_exp
  taboo_text_change: String_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "all_card_text"
"""
enum all_card_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  all_card_text_pkey
}

"""
input type for inserting data into table "all_card_text"
"""
input all_card_text_insert_input {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String
  imageurl: String
  locale: String
  name: String
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type all_card_text_max_fields {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String
  imageurl: String
  locale: String
  name: String
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "all_card_text"
"""
input all_card_text_max_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  back_traits: order_by
  backimageurl: order_by
  customization_change: order_by
  customization_text: order_by
  encounter_name: order_by
  flavor: order_by
  id: order_by
  imageurl: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  taboo_original_back_text: order_by
  taboo_original_text: order_by
  taboo_text_change: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type all_card_text_min_fields {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String
  imageurl: String
  locale: String
  name: String
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "all_card_text"
"""
input all_card_text_min_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  back_traits: order_by
  backimageurl: order_by
  customization_change: order_by
  customization_text: order_by
  encounter_name: order_by
  flavor: order_by
  id: order_by
  imageurl: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  taboo_original_back_text: order_by
  taboo_original_text: order_by
  taboo_text_change: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "all_card_text"
"""
type all_card_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [all_card_text!]!
}

"""
on_conflict condition type for table "all_card_text"
"""
input all_card_text_on_conflict {
  constraint: all_card_text_constraint!
  update_columns: [all_card_text_update_column!]! = []
  where: all_card_text_bool_exp
}

"""Ordering options when selecting data from "all_card_text"."""
input all_card_text_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  back_traits: order_by
  backimageurl: order_by
  customization_change: order_by
  customization_text: order_by
  encounter_name: order_by
  flavor: order_by
  id: order_by
  imageurl: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  taboo_original_back_text: order_by
  taboo_original_text: order_by
  taboo_text_change: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""primary key columns input for table: all_card_text"""
input all_card_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "all_card_text"
"""
enum all_card_text_select_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  backimageurl

  """column name"""
  customization_change

  """column name"""
  customization_text

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imageurl

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  taboo_original_back_text

  """column name"""
  taboo_original_text

  """column name"""
  taboo_text_change

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

"""
input type for updating data in table "all_card_text"
"""
input all_card_text_set_input {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String
  imageurl: String
  locale: String
  name: String
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "all_card_text"
"""
input all_card_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: all_card_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input all_card_text_stream_cursor_value_input {
  back_flavor: String
  back_name: String
  back_text: String
  back_traits: String
  backimageurl: String
  customization_change: String
  customization_text: String
  encounter_name: String
  flavor: String
  id: String
  imageurl: String
  locale: String
  name: String
  slot: String
  subname: String
  taboo_original_back_text: String
  taboo_original_text: String
  taboo_text_change: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
update columns of table "all_card_text"
"""
enum all_card_text_update_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  backimageurl

  """column name"""
  customization_change

  """column name"""
  customization_text

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imageurl

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  taboo_original_back_text

  """column name"""
  taboo_original_text

  """column name"""
  taboo_text_change

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

input all_card_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: all_card_text_set_input

  """filter the rows which have to be updated"""
  where: all_card_text_bool_exp!
}

"""
update columns of table "all_card"
"""
enum all_card_update_column {
  """column name"""
  alt_art_investigator

  """column name"""
  alternate_of_code

  """column name"""
  alternate_required_code

  """column name"""
  back_illustrator

  """column name"""
  back_link_id

  """column name"""
  backimagesrc

  """column name"""
  backimageurl

  """column name"""
  clues

  """column name"""
  clues_fixed

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  customization_options

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  duplicate_of_code

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  errata_date

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction2_code

  """column name"""
  faction3_code

  """column name"""
  faction_code

  """column name"""
  gender

  """column name"""
  heals_damage

  """column name"""
  heals_horror

  """column name"""
  health

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  imageurl

  """column name"""
  is_unique

  """column name"""
  linked

  """column name"""
  myriad

  """column name"""
  official

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  preview

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_back_traits

  """column name"""
  real_customization_change

  """column name"""
  real_customization_text

  """column name"""
  real_encounter_set_name

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_taboo_original_back_text

  """column name"""
  real_taboo_original_text

  """column name"""
  real_taboo_text_change

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  side_deck_options

  """column name"""
  side_deck_requirements

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  spoiler

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  taboo_placeholder

  """column name"""
  taboo_set_id

  """column name"""
  taboo_xp

  """column name"""
  tags

  """column name"""
  type_code

  """column name"""
  updated_at

  """column name"""
  vengeance

  """column name"""
  version

  """column name"""
  victory

  """column name"""
  xp
}

"""
columns and relationships of "all_card_updated"
"""
type all_card_updated {
  card_count: Int
  cards_updated_at: timestamp!
  locale: String!
  translation_updated_at: timestamp!
}

"""
aggregated selection of "all_card_updated"
"""
type all_card_updated_aggregate {
  aggregate: all_card_updated_aggregate_fields
  nodes: [all_card_updated!]!
}

"""
aggregate fields of "all_card_updated"
"""
type all_card_updated_aggregate_fields {
  avg: all_card_updated_avg_fields
  count(columns: [all_card_updated_select_column!], distinct: Boolean): Int!
  max: all_card_updated_max_fields
  min: all_card_updated_min_fields
  stddev: all_card_updated_stddev_fields
  stddev_pop: all_card_updated_stddev_pop_fields
  stddev_samp: all_card_updated_stddev_samp_fields
  sum: all_card_updated_sum_fields
  var_pop: all_card_updated_var_pop_fields
  var_samp: all_card_updated_var_samp_fields
  variance: all_card_updated_variance_fields
}

"""aggregate avg on columns"""
type all_card_updated_avg_fields {
  card_count: Float
}

"""
Boolean expression to filter rows from the table "all_card_updated". All fields are combined with a logical 'AND'.
"""
input all_card_updated_bool_exp {
  _and: [all_card_updated_bool_exp!]
  _not: all_card_updated_bool_exp
  _or: [all_card_updated_bool_exp!]
  card_count: Int_comparison_exp
  cards_updated_at: timestamp_comparison_exp
  locale: String_comparison_exp
  translation_updated_at: timestamp_comparison_exp
}

"""
columns and relationships of "all_card_updated_by_version"
"""
type all_card_updated_by_version {
  card_count: Int!
  cards_updated_at: timestamp!
  locale: String!
  translation_updated_at: timestamp!
  version: Int!
}

"""
aggregated selection of "all_card_updated_by_version"
"""
type all_card_updated_by_version_aggregate {
  aggregate: all_card_updated_by_version_aggregate_fields
  nodes: [all_card_updated_by_version!]!
}

"""
aggregate fields of "all_card_updated_by_version"
"""
type all_card_updated_by_version_aggregate_fields {
  avg: all_card_updated_by_version_avg_fields
  count(columns: [all_card_updated_by_version_select_column!], distinct: Boolean): Int!
  max: all_card_updated_by_version_max_fields
  min: all_card_updated_by_version_min_fields
  stddev: all_card_updated_by_version_stddev_fields
  stddev_pop: all_card_updated_by_version_stddev_pop_fields
  stddev_samp: all_card_updated_by_version_stddev_samp_fields
  sum: all_card_updated_by_version_sum_fields
  var_pop: all_card_updated_by_version_var_pop_fields
  var_samp: all_card_updated_by_version_var_samp_fields
  variance: all_card_updated_by_version_variance_fields
}

"""aggregate avg on columns"""
type all_card_updated_by_version_avg_fields {
  card_count: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "all_card_updated_by_version". All fields are combined with a logical 'AND'.
"""
input all_card_updated_by_version_bool_exp {
  _and: [all_card_updated_by_version_bool_exp!]
  _not: all_card_updated_by_version_bool_exp
  _or: [all_card_updated_by_version_bool_exp!]
  card_count: Int_comparison_exp
  cards_updated_at: timestamp_comparison_exp
  locale: String_comparison_exp
  translation_updated_at: timestamp_comparison_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "all_card_updated_by_version"
"""
enum all_card_updated_by_version_constraint {
  """
  unique or primary key constraint on columns "locale", "version"
  """
  all_card_updated_by_version_pkey
}

"""
input type for incrementing numeric columns in table "all_card_updated_by_version"
"""
input all_card_updated_by_version_inc_input {
  card_count: Int
  version: Int
}

"""
input type for inserting data into table "all_card_updated_by_version"
"""
input all_card_updated_by_version_insert_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
  version: Int
}

"""aggregate max on columns"""
type all_card_updated_by_version_max_fields {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
  version: Int
}

"""aggregate min on columns"""
type all_card_updated_by_version_min_fields {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
  version: Int
}

"""
response of any mutation on the table "all_card_updated_by_version"
"""
type all_card_updated_by_version_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [all_card_updated_by_version!]!
}

"""
on_conflict condition type for table "all_card_updated_by_version"
"""
input all_card_updated_by_version_on_conflict {
  constraint: all_card_updated_by_version_constraint!
  update_columns: [all_card_updated_by_version_update_column!]! = []
  where: all_card_updated_by_version_bool_exp
}

"""
Ordering options when selecting data from "all_card_updated_by_version".
"""
input all_card_updated_by_version_order_by {
  card_count: order_by
  cards_updated_at: order_by
  locale: order_by
  translation_updated_at: order_by
  version: order_by
}

"""primary key columns input for table: all_card_updated_by_version"""
input all_card_updated_by_version_pk_columns_input {
  locale: String!
  version: Int!
}

"""
select columns of table "all_card_updated_by_version"
"""
enum all_card_updated_by_version_select_column {
  """column name"""
  card_count

  """column name"""
  cards_updated_at

  """column name"""
  locale

  """column name"""
  translation_updated_at

  """column name"""
  version
}

"""
input type for updating data in table "all_card_updated_by_version"
"""
input all_card_updated_by_version_set_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
  version: Int
}

"""aggregate stddev on columns"""
type all_card_updated_by_version_stddev_fields {
  card_count: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type all_card_updated_by_version_stddev_pop_fields {
  card_count: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type all_card_updated_by_version_stddev_samp_fields {
  card_count: Float
  version: Float
}

"""
Streaming cursor of the table "all_card_updated_by_version"
"""
input all_card_updated_by_version_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: all_card_updated_by_version_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input all_card_updated_by_version_stream_cursor_value_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
  version: Int
}

"""aggregate sum on columns"""
type all_card_updated_by_version_sum_fields {
  card_count: Int
  version: Int
}

"""
update columns of table "all_card_updated_by_version"
"""
enum all_card_updated_by_version_update_column {
  """column name"""
  card_count

  """column name"""
  cards_updated_at

  """column name"""
  locale

  """column name"""
  translation_updated_at

  """column name"""
  version
}

input all_card_updated_by_version_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: all_card_updated_by_version_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: all_card_updated_by_version_set_input

  """filter the rows which have to be updated"""
  where: all_card_updated_by_version_bool_exp!
}

"""aggregate var_pop on columns"""
type all_card_updated_by_version_var_pop_fields {
  card_count: Float
  version: Float
}

"""aggregate var_samp on columns"""
type all_card_updated_by_version_var_samp_fields {
  card_count: Float
  version: Float
}

"""aggregate variance on columns"""
type all_card_updated_by_version_variance_fields {
  card_count: Float
  version: Float
}

"""
unique or primary key constraints on table "all_card_updated"
"""
enum all_card_updated_constraint {
  """
  unique or primary key constraint on columns "locale"
  """
  all_card_updated_pkey
}

"""
input type for incrementing numeric columns in table "all_card_updated"
"""
input all_card_updated_inc_input {
  card_count: Int
}

"""
input type for inserting data into table "all_card_updated"
"""
input all_card_updated_insert_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
}

"""aggregate max on columns"""
type all_card_updated_max_fields {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
}

"""aggregate min on columns"""
type all_card_updated_min_fields {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
}

"""
response of any mutation on the table "all_card_updated"
"""
type all_card_updated_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [all_card_updated!]!
}

"""
on_conflict condition type for table "all_card_updated"
"""
input all_card_updated_on_conflict {
  constraint: all_card_updated_constraint!
  update_columns: [all_card_updated_update_column!]! = []
  where: all_card_updated_bool_exp
}

"""Ordering options when selecting data from "all_card_updated"."""
input all_card_updated_order_by {
  card_count: order_by
  cards_updated_at: order_by
  locale: order_by
  translation_updated_at: order_by
}

"""primary key columns input for table: all_card_updated"""
input all_card_updated_pk_columns_input {
  locale: String!
}

"""
select columns of table "all_card_updated"
"""
enum all_card_updated_select_column {
  """column name"""
  card_count

  """column name"""
  cards_updated_at

  """column name"""
  locale

  """column name"""
  translation_updated_at
}

"""
input type for updating data in table "all_card_updated"
"""
input all_card_updated_set_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
}

"""aggregate stddev on columns"""
type all_card_updated_stddev_fields {
  card_count: Float
}

"""aggregate stddev_pop on columns"""
type all_card_updated_stddev_pop_fields {
  card_count: Float
}

"""aggregate stddev_samp on columns"""
type all_card_updated_stddev_samp_fields {
  card_count: Float
}

"""
Streaming cursor of the table "all_card_updated"
"""
input all_card_updated_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: all_card_updated_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input all_card_updated_stream_cursor_value_input {
  card_count: Int
  cards_updated_at: timestamp
  locale: String
  translation_updated_at: timestamp
}

"""aggregate sum on columns"""
type all_card_updated_sum_fields {
  card_count: Int
}

"""
update columns of table "all_card_updated"
"""
enum all_card_updated_update_column {
  """column name"""
  card_count

  """column name"""
  cards_updated_at

  """column name"""
  locale

  """column name"""
  translation_updated_at
}

input all_card_updated_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: all_card_updated_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: all_card_updated_set_input

  """filter the rows which have to be updated"""
  where: all_card_updated_bool_exp!
}

"""aggregate var_pop on columns"""
type all_card_updated_var_pop_fields {
  card_count: Float
}

"""aggregate var_samp on columns"""
type all_card_updated_var_samp_fields {
  card_count: Float
}

"""aggregate variance on columns"""
type all_card_updated_variance_fields {
  card_count: Float
}

input all_card_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: all_card_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: all_card_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: all_card_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: all_card_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: all_card_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: all_card_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: all_card_set_input

  """filter the rows which have to be updated"""
  where: all_card_bool_exp!
}

"""aggregate var_pop on columns"""
type all_card_var_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by var_pop() on columns of table "all_card"
"""
input all_card_var_pop_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""aggregate var_samp on columns"""
type all_card_var_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by var_samp() on columns of table "all_card"
"""
input all_card_var_samp_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""aggregate variance on columns"""
type all_card_variance_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  taboo_set_id: Float
  taboo_xp: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
order by variance() on columns of table "all_card"
"""
input all_card_variance_order_by {
  clues: order_by
  cost: order_by
  deck_limit: order_by
  doom: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  health: order_by
  pack_position: order_by
  position: order_by
  quantity: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  taboo_set_id: order_by
  taboo_xp: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""
columns and relationships of "arkhamdb_auth"
"""
type arkhamdb_auth {
  access_token: String!
  access_token_expiration: timestamptz!
  account_id: Int
  account_name: String
  decks_cache_key: String
  reauthorization_required: Boolean!
  refresh_token: String!
  refresh_token_expiration: timestamptz
  user_id: String!
}

"""
aggregated selection of "arkhamdb_auth"
"""
type arkhamdb_auth_aggregate {
  aggregate: arkhamdb_auth_aggregate_fields
  nodes: [arkhamdb_auth!]!
}

"""
aggregate fields of "arkhamdb_auth"
"""
type arkhamdb_auth_aggregate_fields {
  avg: arkhamdb_auth_avg_fields
  count(columns: [arkhamdb_auth_select_column!], distinct: Boolean): Int!
  max: arkhamdb_auth_max_fields
  min: arkhamdb_auth_min_fields
  stddev: arkhamdb_auth_stddev_fields
  stddev_pop: arkhamdb_auth_stddev_pop_fields
  stddev_samp: arkhamdb_auth_stddev_samp_fields
  sum: arkhamdb_auth_sum_fields
  var_pop: arkhamdb_auth_var_pop_fields
  var_samp: arkhamdb_auth_var_samp_fields
  variance: arkhamdb_auth_variance_fields
}

"""aggregate avg on columns"""
type arkhamdb_auth_avg_fields {
  account_id: Float
}

"""
Boolean expression to filter rows from the table "arkhamdb_auth". All fields are combined with a logical 'AND'.
"""
input arkhamdb_auth_bool_exp {
  _and: [arkhamdb_auth_bool_exp!]
  _not: arkhamdb_auth_bool_exp
  _or: [arkhamdb_auth_bool_exp!]
  access_token: String_comparison_exp
  access_token_expiration: timestamptz_comparison_exp
  account_id: Int_comparison_exp
  account_name: String_comparison_exp
  decks_cache_key: String_comparison_exp
  reauthorization_required: Boolean_comparison_exp
  refresh_token: String_comparison_exp
  refresh_token_expiration: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "arkhamdb_auth"
"""
enum arkhamdb_auth_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  arkhamdb_auth_pkey
}

"""
input type for incrementing numeric columns in table "arkhamdb_auth"
"""
input arkhamdb_auth_inc_input {
  account_id: Int
}

"""
input type for inserting data into table "arkhamdb_auth"
"""
input arkhamdb_auth_insert_input {
  access_token: String
  access_token_expiration: timestamptz
  account_id: Int
  account_name: String
  decks_cache_key: String
  reauthorization_required: Boolean
  refresh_token: String
  refresh_token_expiration: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type arkhamdb_auth_max_fields {
  access_token: String
  access_token_expiration: timestamptz
  account_id: Int
  account_name: String
  decks_cache_key: String
  refresh_token: String
  refresh_token_expiration: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type arkhamdb_auth_min_fields {
  access_token: String
  access_token_expiration: timestamptz
  account_id: Int
  account_name: String
  decks_cache_key: String
  refresh_token: String
  refresh_token_expiration: timestamptz
  user_id: String
}

"""
response of any mutation on the table "arkhamdb_auth"
"""
type arkhamdb_auth_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [arkhamdb_auth!]!
}

"""
on_conflict condition type for table "arkhamdb_auth"
"""
input arkhamdb_auth_on_conflict {
  constraint: arkhamdb_auth_constraint!
  update_columns: [arkhamdb_auth_update_column!]! = []
  where: arkhamdb_auth_bool_exp
}

"""Ordering options when selecting data from "arkhamdb_auth"."""
input arkhamdb_auth_order_by {
  access_token: order_by
  access_token_expiration: order_by
  account_id: order_by
  account_name: order_by
  decks_cache_key: order_by
  reauthorization_required: order_by
  refresh_token: order_by
  refresh_token_expiration: order_by
  user_id: order_by
}

"""primary key columns input for table: arkhamdb_auth"""
input arkhamdb_auth_pk_columns_input {
  user_id: String!
}

"""
select columns of table "arkhamdb_auth"
"""
enum arkhamdb_auth_select_column {
  """column name"""
  access_token

  """column name"""
  access_token_expiration

  """column name"""
  account_id

  """column name"""
  account_name

  """column name"""
  decks_cache_key

  """column name"""
  reauthorization_required

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expiration

  """column name"""
  user_id
}

"""
input type for updating data in table "arkhamdb_auth"
"""
input arkhamdb_auth_set_input {
  access_token: String
  access_token_expiration: timestamptz
  account_id: Int
  account_name: String
  decks_cache_key: String
  reauthorization_required: Boolean
  refresh_token: String
  refresh_token_expiration: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type arkhamdb_auth_stddev_fields {
  account_id: Float
}

"""aggregate stddev_pop on columns"""
type arkhamdb_auth_stddev_pop_fields {
  account_id: Float
}

"""aggregate stddev_samp on columns"""
type arkhamdb_auth_stddev_samp_fields {
  account_id: Float
}

"""
Streaming cursor of the table "arkhamdb_auth"
"""
input arkhamdb_auth_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: arkhamdb_auth_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input arkhamdb_auth_stream_cursor_value_input {
  access_token: String
  access_token_expiration: timestamptz
  account_id: Int
  account_name: String
  decks_cache_key: String
  reauthorization_required: Boolean
  refresh_token: String
  refresh_token_expiration: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type arkhamdb_auth_sum_fields {
  account_id: Int
}

"""
update columns of table "arkhamdb_auth"
"""
enum arkhamdb_auth_update_column {
  """column name"""
  access_token

  """column name"""
  access_token_expiration

  """column name"""
  account_id

  """column name"""
  account_name

  """column name"""
  decks_cache_key

  """column name"""
  reauthorization_required

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expiration

  """column name"""
  user_id
}

input arkhamdb_auth_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: arkhamdb_auth_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: arkhamdb_auth_set_input

  """filter the rows which have to be updated"""
  where: arkhamdb_auth_bool_exp!
}

"""aggregate var_pop on columns"""
type arkhamdb_auth_var_pop_fields {
  account_id: Float
}

"""aggregate var_samp on columns"""
type arkhamdb_auth_var_samp_fields {
  account_id: Float
}

"""aggregate variance on columns"""
type arkhamdb_auth_variance_fields {
  account_id: Float
}

"""
columns and relationships of "arkhamdb_deck"
"""
type arkhamdb_deck {
  archived: Boolean
  created_at: timestamptz!
  deleted: Boolean!
  description: String!
  id: Int!
  ignore_deck_limit_slots(
    """JSON select path"""
    path: String
  ): jsonb!
  investigator: String!
  meta(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!

  """An object relationship"""
  next_deck: arkhamdb_deck
  next_deck_id: Int

  """An object relationship"""
  owner: users!
  owner_id: String!

  """An object relationship"""
  previous_deck: arkhamdb_deck
  side_slots(
    """JSON select path"""
    path: String
  ): jsonb!
  slots(
    """JSON select path"""
    path: String
  ): jsonb!
  tags(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamptz!
}

"""
aggregated selection of "arkhamdb_deck"
"""
type arkhamdb_deck_aggregate {
  aggregate: arkhamdb_deck_aggregate_fields
  nodes: [arkhamdb_deck!]!
}

"""
aggregate fields of "arkhamdb_deck"
"""
type arkhamdb_deck_aggregate_fields {
  avg: arkhamdb_deck_avg_fields
  count(columns: [arkhamdb_deck_select_column!], distinct: Boolean): Int!
  max: arkhamdb_deck_max_fields
  min: arkhamdb_deck_min_fields
  stddev: arkhamdb_deck_stddev_fields
  stddev_pop: arkhamdb_deck_stddev_pop_fields
  stddev_samp: arkhamdb_deck_stddev_samp_fields
  sum: arkhamdb_deck_sum_fields
  var_pop: arkhamdb_deck_var_pop_fields
  var_samp: arkhamdb_deck_var_samp_fields
  variance: arkhamdb_deck_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input arkhamdb_deck_append_input {
  ignore_deck_limit_slots: jsonb
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
}

"""aggregate avg on columns"""
type arkhamdb_deck_avg_fields {
  id: Float
  next_deck_id: Float
}

"""
Boolean expression to filter rows from the table "arkhamdb_deck". All fields are combined with a logical 'AND'.
"""
input arkhamdb_deck_bool_exp {
  _and: [arkhamdb_deck_bool_exp!]
  _not: arkhamdb_deck_bool_exp
  _or: [arkhamdb_deck_bool_exp!]
  archived: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted: Boolean_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  ignore_deck_limit_slots: jsonb_comparison_exp
  investigator: String_comparison_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  next_deck: arkhamdb_deck_bool_exp
  next_deck_id: Int_comparison_exp
  owner: users_bool_exp
  owner_id: String_comparison_exp
  previous_deck: arkhamdb_deck_bool_exp
  side_slots: jsonb_comparison_exp
  slots: jsonb_comparison_exp
  tags: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "arkhamdb_deck"
"""
enum arkhamdb_deck_constraint {
  """
  unique or primary key constraint on columns "next_deck_id"
  """
  deck_next_deck_id_key

  """
  unique or primary key constraint on columns "id"
  """
  deck_pkey1
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input arkhamdb_deck_delete_at_path_input {
  ignore_deck_limit_slots: [String!]
  meta: [String!]
  side_slots: [String!]
  slots: [String!]
  tags: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input arkhamdb_deck_delete_elem_input {
  ignore_deck_limit_slots: Int
  meta: Int
  side_slots: Int
  slots: Int
  tags: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input arkhamdb_deck_delete_key_input {
  ignore_deck_limit_slots: String
  meta: String
  side_slots: String
  slots: String
  tags: String
}

"""
input type for incrementing numeric columns in table "arkhamdb_deck"
"""
input arkhamdb_deck_inc_input {
  id: Int
  next_deck_id: Int
}

"""
input type for inserting data into table "arkhamdb_deck"
"""
input arkhamdb_deck_insert_input {
  archived: Boolean
  created_at: timestamptz
  deleted: Boolean
  description: String
  id: Int
  ignore_deck_limit_slots: jsonb
  investigator: String
  meta: jsonb
  name: String
  next_deck: arkhamdb_deck_obj_rel_insert_input
  next_deck_id: Int
  owner: users_obj_rel_insert_input
  owner_id: String
  previous_deck: arkhamdb_deck_obj_rel_insert_input
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
}

"""aggregate max on columns"""
type arkhamdb_deck_max_fields {
  created_at: timestamptz
  description: String
  id: Int
  investigator: String
  name: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type arkhamdb_deck_min_fields {
  created_at: timestamptz
  description: String
  id: Int
  investigator: String
  name: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "arkhamdb_deck"
"""
type arkhamdb_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [arkhamdb_deck!]!
}

"""
input type for inserting object relation for remote table "arkhamdb_deck"
"""
input arkhamdb_deck_obj_rel_insert_input {
  data: arkhamdb_deck_insert_input!

  """upsert condition"""
  on_conflict: arkhamdb_deck_on_conflict
}

"""
on_conflict condition type for table "arkhamdb_deck"
"""
input arkhamdb_deck_on_conflict {
  constraint: arkhamdb_deck_constraint!
  update_columns: [arkhamdb_deck_update_column!]! = []
  where: arkhamdb_deck_bool_exp
}

"""Ordering options when selecting data from "arkhamdb_deck"."""
input arkhamdb_deck_order_by {
  archived: order_by
  created_at: order_by
  deleted: order_by
  description: order_by
  id: order_by
  ignore_deck_limit_slots: order_by
  investigator: order_by
  meta: order_by
  name: order_by
  next_deck: arkhamdb_deck_order_by
  next_deck_id: order_by
  owner: users_order_by
  owner_id: order_by
  previous_deck: arkhamdb_deck_order_by
  side_slots: order_by
  slots: order_by
  tags: order_by
  updated_at: order_by
}

"""primary key columns input for table: arkhamdb_deck"""
input arkhamdb_deck_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input arkhamdb_deck_prepend_input {
  ignore_deck_limit_slots: jsonb
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
}

"""
select columns of table "arkhamdb_deck"
"""
enum arkhamdb_deck_select_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  deleted

  """column name"""
  description

  """column name"""
  id

  """column name"""
  ignore_deck_limit_slots

  """column name"""
  investigator

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  next_deck_id

  """column name"""
  owner_id

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  tags

  """column name"""
  updated_at
}

"""
input type for updating data in table "arkhamdb_deck"
"""
input arkhamdb_deck_set_input {
  archived: Boolean
  created_at: timestamptz
  deleted: Boolean
  description: String
  id: Int
  ignore_deck_limit_slots: jsonb
  investigator: String
  meta: jsonb
  name: String
  next_deck_id: Int
  owner_id: String
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type arkhamdb_deck_stddev_fields {
  id: Float
  next_deck_id: Float
}

"""aggregate stddev_pop on columns"""
type arkhamdb_deck_stddev_pop_fields {
  id: Float
  next_deck_id: Float
}

"""aggregate stddev_samp on columns"""
type arkhamdb_deck_stddev_samp_fields {
  id: Float
  next_deck_id: Float
}

"""
Streaming cursor of the table "arkhamdb_deck"
"""
input arkhamdb_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: arkhamdb_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input arkhamdb_deck_stream_cursor_value_input {
  archived: Boolean
  created_at: timestamptz
  deleted: Boolean
  description: String
  id: Int
  ignore_deck_limit_slots: jsonb
  investigator: String
  meta: jsonb
  name: String
  next_deck_id: Int
  owner_id: String
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type arkhamdb_deck_sum_fields {
  id: Int
  next_deck_id: Int
}

"""
update columns of table "arkhamdb_deck"
"""
enum arkhamdb_deck_update_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  deleted

  """column name"""
  description

  """column name"""
  id

  """column name"""
  ignore_deck_limit_slots

  """column name"""
  investigator

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  next_deck_id

  """column name"""
  owner_id

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  tags

  """column name"""
  updated_at
}

input arkhamdb_deck_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: arkhamdb_deck_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: arkhamdb_deck_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: arkhamdb_deck_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: arkhamdb_deck_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: arkhamdb_deck_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: arkhamdb_deck_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: arkhamdb_deck_set_input

  """filter the rows which have to be updated"""
  where: arkhamdb_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type arkhamdb_deck_var_pop_fields {
  id: Float
  next_deck_id: Float
}

"""aggregate var_samp on columns"""
type arkhamdb_deck_var_samp_fields {
  id: Float
  next_deck_id: Float
}

"""aggregate variance on columns"""
type arkhamdb_deck_variance_fields {
  id: Float
  next_deck_id: Float
}

"""
columns and relationships of "base_decks"
"""
type base_decks {
  """An object relationship"""
  campaign: campaign
  campaign_id: Int

  """An object relationship"""
  deck: campaign_deck
  id: Int
}

"""
aggregated selection of "base_decks"
"""
type base_decks_aggregate {
  aggregate: base_decks_aggregate_fields
  nodes: [base_decks!]!
}

input base_decks_aggregate_bool_exp {
  count: base_decks_aggregate_bool_exp_count
}

input base_decks_aggregate_bool_exp_count {
  arguments: [base_decks_select_column!]
  distinct: Boolean
  filter: base_decks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "base_decks"
"""
type base_decks_aggregate_fields {
  avg: base_decks_avg_fields
  count(columns: [base_decks_select_column!], distinct: Boolean): Int!
  max: base_decks_max_fields
  min: base_decks_min_fields
  stddev: base_decks_stddev_fields
  stddev_pop: base_decks_stddev_pop_fields
  stddev_samp: base_decks_stddev_samp_fields
  sum: base_decks_sum_fields
  var_pop: base_decks_var_pop_fields
  var_samp: base_decks_var_samp_fields
  variance: base_decks_variance_fields
}

"""
order by aggregate values of table "base_decks"
"""
input base_decks_aggregate_order_by {
  avg: base_decks_avg_order_by
  count: order_by
  max: base_decks_max_order_by
  min: base_decks_min_order_by
  stddev: base_decks_stddev_order_by
  stddev_pop: base_decks_stddev_pop_order_by
  stddev_samp: base_decks_stddev_samp_order_by
  sum: base_decks_sum_order_by
  var_pop: base_decks_var_pop_order_by
  var_samp: base_decks_var_samp_order_by
  variance: base_decks_variance_order_by
}

"""
input type for inserting array relation for remote table "base_decks"
"""
input base_decks_arr_rel_insert_input {
  data: [base_decks_insert_input!]!
}

"""aggregate avg on columns"""
type base_decks_avg_fields {
  campaign_id: Float
  id: Float
}

"""
order by avg() on columns of table "base_decks"
"""
input base_decks_avg_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "base_decks". All fields are combined with a logical 'AND'.
"""
input base_decks_bool_exp {
  _and: [base_decks_bool_exp!]
  _not: base_decks_bool_exp
  _or: [base_decks_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  deck: campaign_deck_bool_exp
  id: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "base_decks"
"""
input base_decks_inc_input {
  campaign_id: Int
  id: Int
}

"""
input type for inserting data into table "base_decks"
"""
input base_decks_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  deck: campaign_deck_obj_rel_insert_input
  id: Int
}

"""aggregate max on columns"""
type base_decks_max_fields {
  campaign_id: Int
  id: Int
}

"""
order by max() on columns of table "base_decks"
"""
input base_decks_max_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type base_decks_min_fields {
  campaign_id: Int
  id: Int
}

"""
order by min() on columns of table "base_decks"
"""
input base_decks_min_order_by {
  campaign_id: order_by
  id: order_by
}

"""
response of any mutation on the table "base_decks"
"""
type base_decks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [base_decks!]!
}

"""Ordering options when selecting data from "base_decks"."""
input base_decks_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  deck: campaign_deck_order_by
  id: order_by
}

"""
select columns of table "base_decks"
"""
enum base_decks_select_column {
  """column name"""
  campaign_id

  """column name"""
  id
}

"""
input type for updating data in table "base_decks"
"""
input base_decks_set_input {
  campaign_id: Int
  id: Int
}

"""aggregate stddev on columns"""
type base_decks_stddev_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev() on columns of table "base_decks"
"""
input base_decks_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type base_decks_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "base_decks"
"""
input base_decks_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type base_decks_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "base_decks"
"""
input base_decks_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "base_decks"
"""
input base_decks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: base_decks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input base_decks_stream_cursor_value_input {
  campaign_id: Int
  id: Int
}

"""aggregate sum on columns"""
type base_decks_sum_fields {
  campaign_id: Int
  id: Int
}

"""
order by sum() on columns of table "base_decks"
"""
input base_decks_sum_order_by {
  campaign_id: order_by
  id: order_by
}

input base_decks_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: base_decks_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: base_decks_set_input

  """filter the rows which have to be updated"""
  where: base_decks_bool_exp!
}

"""aggregate var_pop on columns"""
type base_decks_var_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "base_decks"
"""
input base_decks_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type base_decks_var_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "base_decks"
"""
input base_decks_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type base_decks_variance_fields {
  campaign_id: Float
  id: Float
}

"""
order by variance() on columns of table "base_decks"
"""
input base_decks_variance_order_by {
  campaign_id: order_by
  id: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "campaign"
"""
type campaign {
  """An array relationship"""
  access(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): [campaign_access!]!

  """An aggregate relationship"""
  access_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): campaign_access_aggregate!
  archived: Boolean

  """An array relationship"""
  base_decks(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): [base_decks!]!

  """An aggregate relationship"""
  base_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): base_decks_aggregate!
  campaignNotes(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  campaign_guide: campaign_guide
  chaosBag(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  chaos_bag_result(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): [chaos_bag_result!]!

  """An aggregate relationship"""
  chaos_bag_result_aggregate(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): chaos_bag_result_aggregate!
  created_at: timestamptz!
  cycleCode: String
  deleted: Boolean
  difficulty: String
  guide_version: Int
  guided: Boolean
  id: Int!

  """An array relationship"""
  investigator_data(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): [investigator_data!]!

  """An aggregate relationship"""
  investigator_data_aggregate(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): investigator_data_aggregate!

  """An array relationship"""
  investigators(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): [campaign_investigator!]!

  """An aggregate relationship"""
  investigators_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): campaign_investigator_aggregate!

  """An array relationship"""
  latest_decks(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): [latest_decks!]!

  """An aggregate relationship"""
  latest_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): latest_decks_aggregate!

  """An object relationship"""
  link_a_campaign: campaign
  link_a_campaign_id: Int

  """An object relationship"""
  link_b_campaign: campaign
  link_b_campaign_id: Int
  link_campaign_id: Int

  """An object relationship"""
  linked_campaign: campaign
  name: String

  """An object relationship"""
  owner: users!
  owner_id: String!
  scenarioResults(
    """JSON select path"""
    path: String
  ): jsonb
  showInterludes: Boolean
  standaloneId(
    """JSON select path"""
    path: String
  ): jsonb
  tarot_reading(
    """JSON select path"""
    path: String
  ): jsonb
  updated_at: timestamptz!
  uuid: String!
  weaknessSet(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
columns and relationships of "campaign_access"
"""
type campaign_access {
  """An object relationship"""
  campaign: campaign!
  campaign_id: Int!
  hidden: Boolean
  id: Int!

  """An object relationship"""
  user: users!
  user_id: String!
}

"""
aggregated selection of "campaign_access"
"""
type campaign_access_aggregate {
  aggregate: campaign_access_aggregate_fields
  nodes: [campaign_access!]!
}

input campaign_access_aggregate_bool_exp {
  bool_and: campaign_access_aggregate_bool_exp_bool_and
  bool_or: campaign_access_aggregate_bool_exp_bool_or
  count: campaign_access_aggregate_bool_exp_count
}

input campaign_access_aggregate_bool_exp_bool_and {
  arguments: campaign_access_select_column_campaign_access_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: campaign_access_bool_exp
  predicate: Boolean_comparison_exp!
}

input campaign_access_aggregate_bool_exp_bool_or {
  arguments: campaign_access_select_column_campaign_access_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: campaign_access_bool_exp
  predicate: Boolean_comparison_exp!
}

input campaign_access_aggregate_bool_exp_count {
  arguments: [campaign_access_select_column!]
  distinct: Boolean
  filter: campaign_access_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "campaign_access"
"""
type campaign_access_aggregate_fields {
  avg: campaign_access_avg_fields
  count(columns: [campaign_access_select_column!], distinct: Boolean): Int!
  max: campaign_access_max_fields
  min: campaign_access_min_fields
  stddev: campaign_access_stddev_fields
  stddev_pop: campaign_access_stddev_pop_fields
  stddev_samp: campaign_access_stddev_samp_fields
  sum: campaign_access_sum_fields
  var_pop: campaign_access_var_pop_fields
  var_samp: campaign_access_var_samp_fields
  variance: campaign_access_variance_fields
}

"""
order by aggregate values of table "campaign_access"
"""
input campaign_access_aggregate_order_by {
  avg: campaign_access_avg_order_by
  count: order_by
  max: campaign_access_max_order_by
  min: campaign_access_min_order_by
  stddev: campaign_access_stddev_order_by
  stddev_pop: campaign_access_stddev_pop_order_by
  stddev_samp: campaign_access_stddev_samp_order_by
  sum: campaign_access_sum_order_by
  var_pop: campaign_access_var_pop_order_by
  var_samp: campaign_access_var_samp_order_by
  variance: campaign_access_variance_order_by
}

"""
input type for inserting array relation for remote table "campaign_access"
"""
input campaign_access_arr_rel_insert_input {
  data: [campaign_access_insert_input!]!

  """upsert condition"""
  on_conflict: campaign_access_on_conflict
}

"""aggregate avg on columns"""
type campaign_access_avg_fields {
  campaign_id: Float
  id: Float
}

"""
order by avg() on columns of table "campaign_access"
"""
input campaign_access_avg_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "campaign_access". All fields are combined with a logical 'AND'.
"""
input campaign_access_bool_exp {
  _and: [campaign_access_bool_exp!]
  _not: campaign_access_bool_exp
  _or: [campaign_access_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  hidden: Boolean_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "campaign_access"
"""
enum campaign_access_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  campaign_access_pkey

  """
  unique or primary key constraint on columns "user_id", "campaign_id"
  """
  campaign_access_user_id_campaign_id_key
}

"""
input type for incrementing numeric columns in table "campaign_access"
"""
input campaign_access_inc_input {
  campaign_id: Int
  id: Int
}

"""
input type for inserting data into table "campaign_access"
"""
input campaign_access_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  hidden: Boolean
  id: Int
  user: users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type campaign_access_max_fields {
  campaign_id: Int
  id: Int
  user_id: String
}

"""
order by max() on columns of table "campaign_access"
"""
input campaign_access_max_order_by {
  campaign_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type campaign_access_min_fields {
  campaign_id: Int
  id: Int
  user_id: String
}

"""
order by min() on columns of table "campaign_access"
"""
input campaign_access_min_order_by {
  campaign_id: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "campaign_access"
"""
type campaign_access_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign_access!]!
}

"""
on_conflict condition type for table "campaign_access"
"""
input campaign_access_on_conflict {
  constraint: campaign_access_constraint!
  update_columns: [campaign_access_update_column!]! = []
  where: campaign_access_bool_exp
}

"""Ordering options when selecting data from "campaign_access"."""
input campaign_access_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  hidden: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: campaign_access"""
input campaign_access_pk_columns_input {
  id: Int!
}

"""
select columns of table "campaign_access"
"""
enum campaign_access_select_column {
  """column name"""
  campaign_id

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  user_id
}

"""
select "campaign_access_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_access"
"""
enum campaign_access_select_column_campaign_access_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  hidden
}

"""
select "campaign_access_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_access"
"""
enum campaign_access_select_column_campaign_access_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  hidden
}

"""
input type for updating data in table "campaign_access"
"""
input campaign_access_set_input {
  campaign_id: Int
  hidden: Boolean
  id: Int
  user_id: String
}

"""aggregate stddev on columns"""
type campaign_access_stddev_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev() on columns of table "campaign_access"
"""
input campaign_access_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type campaign_access_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "campaign_access"
"""
input campaign_access_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type campaign_access_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "campaign_access"
"""
input campaign_access_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "campaign_access"
"""
input campaign_access_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_access_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_access_stream_cursor_value_input {
  campaign_id: Int
  hidden: Boolean
  id: Int
  user_id: String
}

"""aggregate sum on columns"""
type campaign_access_sum_fields {
  campaign_id: Int
  id: Int
}

"""
order by sum() on columns of table "campaign_access"
"""
input campaign_access_sum_order_by {
  campaign_id: order_by
  id: order_by
}

"""
update columns of table "campaign_access"
"""
enum campaign_access_update_column {
  """column name"""
  campaign_id

  """column name"""
  hidden

  """column name"""
  id

  """column name"""
  user_id
}

input campaign_access_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: campaign_access_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: campaign_access_set_input

  """filter the rows which have to be updated"""
  where: campaign_access_bool_exp!
}

"""aggregate var_pop on columns"""
type campaign_access_var_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "campaign_access"
"""
input campaign_access_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type campaign_access_var_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "campaign_access"
"""
input campaign_access_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type campaign_access_variance_fields {
  campaign_id: Float
  id: Float
}

"""
order by variance() on columns of table "campaign_access"
"""
input campaign_access_variance_order_by {
  campaign_id: order_by
  id: order_by
}

"""
aggregated selection of "campaign"
"""
type campaign_aggregate {
  aggregate: campaign_aggregate_fields
  nodes: [campaign!]!
}

"""
aggregate fields of "campaign"
"""
type campaign_aggregate_fields {
  avg: campaign_avg_fields
  count(columns: [campaign_select_column!], distinct: Boolean): Int!
  max: campaign_max_fields
  min: campaign_min_fields
  stddev: campaign_stddev_fields
  stddev_pop: campaign_stddev_pop_fields
  stddev_samp: campaign_stddev_samp_fields
  sum: campaign_sum_fields
  var_pop: campaign_var_pop_fields
  var_samp: campaign_var_samp_fields
  variance: campaign_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input campaign_append_input {
  campaignNotes: jsonb
  chaosBag: jsonb
  scenarioResults: jsonb
  standaloneId: jsonb
  tarot_reading: jsonb
  weaknessSet: jsonb
}

"""aggregate avg on columns"""
type campaign_avg_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""
Boolean expression to filter rows from the table "campaign". All fields are combined with a logical 'AND'.
"""
input campaign_bool_exp {
  _and: [campaign_bool_exp!]
  _not: campaign_bool_exp
  _or: [campaign_bool_exp!]
  access: campaign_access_bool_exp
  access_aggregate: campaign_access_aggregate_bool_exp
  archived: Boolean_comparison_exp
  base_decks: base_decks_bool_exp
  base_decks_aggregate: base_decks_aggregate_bool_exp
  campaignNotes: jsonb_comparison_exp
  campaign_guide: campaign_guide_bool_exp
  chaosBag: jsonb_comparison_exp
  chaos_bag_result: chaos_bag_result_bool_exp
  chaos_bag_result_aggregate: chaos_bag_result_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  cycleCode: String_comparison_exp
  deleted: Boolean_comparison_exp
  difficulty: String_comparison_exp
  guide_version: Int_comparison_exp
  guided: Boolean_comparison_exp
  id: Int_comparison_exp
  investigator_data: investigator_data_bool_exp
  investigator_data_aggregate: investigator_data_aggregate_bool_exp
  investigators: campaign_investigator_bool_exp
  investigators_aggregate: campaign_investigator_aggregate_bool_exp
  latest_decks: latest_decks_bool_exp
  latest_decks_aggregate: latest_decks_aggregate_bool_exp
  link_a_campaign: campaign_bool_exp
  link_a_campaign_id: Int_comparison_exp
  link_b_campaign: campaign_bool_exp
  link_b_campaign_id: Int_comparison_exp
  link_campaign_id: Int_comparison_exp
  linked_campaign: campaign_bool_exp
  name: String_comparison_exp
  owner: users_bool_exp
  owner_id: String_comparison_exp
  scenarioResults: jsonb_comparison_exp
  showInterludes: Boolean_comparison_exp
  standaloneId: jsonb_comparison_exp
  tarot_reading: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  uuid: String_comparison_exp
  weaknessSet: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "campaign"
"""
enum campaign_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  campaign_data_pkey
}

"""
columns and relationships of "campaign_deck"
"""
type campaign_deck {
  archived: Boolean
  arkhamdb_id: Int
  arkhamdb_user: Int
  base: Boolean

  """An object relationship"""
  campaign: campaign!
  campaign_id: Int!
  content(
    """JSON select path"""
    path: String
  ): jsonb
  content_hash: String
  id: Int!
  investigator: String!

  """An object relationship"""
  investigator_data: investigator_data
  local_uuid: String

  """An object relationship"""
  next_deck: campaign_deck
  next_deck_id: Int

  """An array relationship"""
  other_decks(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """An aggregate relationship"""
  other_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): campaign_deck_aggregate!

  """An object relationship"""
  owner: users!
  owner_id: String!

  """An object relationship"""
  previous_deck: campaign_deck

  """An array relationship"""
  previous_decks(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """An aggregate relationship"""
  previous_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): campaign_deck_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "campaign_deck"
"""
type campaign_deck_aggregate {
  aggregate: campaign_deck_aggregate_fields
  nodes: [campaign_deck!]!
}

input campaign_deck_aggregate_bool_exp {
  bool_and: campaign_deck_aggregate_bool_exp_bool_and
  bool_or: campaign_deck_aggregate_bool_exp_bool_or
  count: campaign_deck_aggregate_bool_exp_count
}

input campaign_deck_aggregate_bool_exp_bool_and {
  arguments: campaign_deck_select_column_campaign_deck_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: campaign_deck_bool_exp
  predicate: Boolean_comparison_exp!
}

input campaign_deck_aggregate_bool_exp_bool_or {
  arguments: campaign_deck_select_column_campaign_deck_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: campaign_deck_bool_exp
  predicate: Boolean_comparison_exp!
}

input campaign_deck_aggregate_bool_exp_count {
  arguments: [campaign_deck_select_column!]
  distinct: Boolean
  filter: campaign_deck_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "campaign_deck"
"""
type campaign_deck_aggregate_fields {
  avg: campaign_deck_avg_fields
  count(columns: [campaign_deck_select_column!], distinct: Boolean): Int!
  max: campaign_deck_max_fields
  min: campaign_deck_min_fields
  stddev: campaign_deck_stddev_fields
  stddev_pop: campaign_deck_stddev_pop_fields
  stddev_samp: campaign_deck_stddev_samp_fields
  sum: campaign_deck_sum_fields
  var_pop: campaign_deck_var_pop_fields
  var_samp: campaign_deck_var_samp_fields
  variance: campaign_deck_variance_fields
}

"""
order by aggregate values of table "campaign_deck"
"""
input campaign_deck_aggregate_order_by {
  avg: campaign_deck_avg_order_by
  count: order_by
  max: campaign_deck_max_order_by
  min: campaign_deck_min_order_by
  stddev: campaign_deck_stddev_order_by
  stddev_pop: campaign_deck_stddev_pop_order_by
  stddev_samp: campaign_deck_stddev_samp_order_by
  sum: campaign_deck_sum_order_by
  var_pop: campaign_deck_var_pop_order_by
  var_samp: campaign_deck_var_samp_order_by
  variance: campaign_deck_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input campaign_deck_append_input {
  content: jsonb
}

"""
input type for inserting array relation for remote table "campaign_deck"
"""
input campaign_deck_arr_rel_insert_input {
  data: [campaign_deck_insert_input!]!

  """upsert condition"""
  on_conflict: campaign_deck_on_conflict
}

"""aggregate avg on columns"""
type campaign_deck_avg_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by avg() on columns of table "campaign_deck"
"""
input campaign_deck_avg_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""
Boolean expression to filter rows from the table "campaign_deck". All fields are combined with a logical 'AND'.
"""
input campaign_deck_bool_exp {
  _and: [campaign_deck_bool_exp!]
  _not: campaign_deck_bool_exp
  _or: [campaign_deck_bool_exp!]
  archived: Boolean_comparison_exp
  arkhamdb_id: Int_comparison_exp
  arkhamdb_user: Int_comparison_exp
  base: Boolean_comparison_exp
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  content: jsonb_comparison_exp
  content_hash: String_comparison_exp
  id: Int_comparison_exp
  investigator: String_comparison_exp
  investigator_data: investigator_data_bool_exp
  local_uuid: String_comparison_exp
  next_deck: campaign_deck_bool_exp
  next_deck_id: Int_comparison_exp
  other_decks: campaign_deck_bool_exp
  other_decks_aggregate: campaign_deck_aggregate_bool_exp
  owner: users_bool_exp
  owner_id: String_comparison_exp
  previous_deck: campaign_deck_bool_exp
  previous_decks: campaign_deck_bool_exp
  previous_decks_aggregate: campaign_deck_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "campaign_deck"
"""
enum campaign_deck_constraint {
  """
  unique or primary key constraint on columns "arkhamdb_id", "campaign_id"
  """
  deck_arkhamdb_id_campaign_id_key

  """
  unique or primary key constraint on columns "local_uuid", "campaign_id"
  """
  deck_local_uuid_campaign_id_key

  """
  unique or primary key constraint on columns "id"
  """
  deck_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input campaign_deck_delete_at_path_input {
  content: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input campaign_deck_delete_elem_input {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input campaign_deck_delete_key_input {
  content: String
}

"""
input type for incrementing numeric columns in table "campaign_deck"
"""
input campaign_deck_inc_input {
  arkhamdb_id: Int
  arkhamdb_user: Int
  campaign_id: Int
  id: Int
  next_deck_id: Int
}

"""
input type for inserting data into table "campaign_deck"
"""
input campaign_deck_insert_input {
  archived: Boolean
  arkhamdb_id: Int
  arkhamdb_user: Int
  base: Boolean
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  content: jsonb
  content_hash: String
  id: Int
  investigator: String
  investigator_data: investigator_data_obj_rel_insert_input
  local_uuid: String
  next_deck: campaign_deck_obj_rel_insert_input
  next_deck_id: Int
  other_decks: campaign_deck_arr_rel_insert_input
  owner: users_obj_rel_insert_input
  owner_id: String
  previous_deck: campaign_deck_obj_rel_insert_input
  previous_decks: campaign_deck_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type campaign_deck_max_fields {
  arkhamdb_id: Int
  arkhamdb_user: Int
  campaign_id: Int
  content_hash: String
  id: Int
  investigator: String
  local_uuid: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "campaign_deck"
"""
input campaign_deck_max_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  content_hash: order_by
  id: order_by
  investigator: order_by
  local_uuid: order_by
  next_deck_id: order_by
  owner_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type campaign_deck_min_fields {
  arkhamdb_id: Int
  arkhamdb_user: Int
  campaign_id: Int
  content_hash: String
  id: Int
  investigator: String
  local_uuid: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "campaign_deck"
"""
input campaign_deck_min_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  content_hash: order_by
  id: order_by
  investigator: order_by
  local_uuid: order_by
  next_deck_id: order_by
  owner_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "campaign_deck"
"""
type campaign_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign_deck!]!
}

"""
input type for inserting object relation for remote table "campaign_deck"
"""
input campaign_deck_obj_rel_insert_input {
  data: campaign_deck_insert_input!

  """upsert condition"""
  on_conflict: campaign_deck_on_conflict
}

"""
on_conflict condition type for table "campaign_deck"
"""
input campaign_deck_on_conflict {
  constraint: campaign_deck_constraint!
  update_columns: [campaign_deck_update_column!]! = []
  where: campaign_deck_bool_exp
}

"""Ordering options when selecting data from "campaign_deck"."""
input campaign_deck_order_by {
  archived: order_by
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  base: order_by
  campaign: campaign_order_by
  campaign_id: order_by
  content: order_by
  content_hash: order_by
  id: order_by
  investigator: order_by
  investigator_data: investigator_data_order_by
  local_uuid: order_by
  next_deck: campaign_deck_order_by
  next_deck_id: order_by
  other_decks_aggregate: campaign_deck_aggregate_order_by
  owner: users_order_by
  owner_id: order_by
  previous_deck: campaign_deck_order_by
  previous_decks_aggregate: campaign_deck_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: campaign_deck"""
input campaign_deck_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input campaign_deck_prepend_input {
  content: jsonb
}

"""
select columns of table "campaign_deck"
"""
enum campaign_deck_select_column {
  """column name"""
  archived

  """column name"""
  arkhamdb_id

  """column name"""
  arkhamdb_user

  """column name"""
  base

  """column name"""
  campaign_id

  """column name"""
  content

  """column name"""
  content_hash

  """column name"""
  id

  """column name"""
  investigator

  """column name"""
  local_uuid

  """column name"""
  next_deck_id

  """column name"""
  owner_id

  """column name"""
  updated_at
}

"""
select "campaign_deck_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_deck"
"""
enum campaign_deck_select_column_campaign_deck_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  archived

  """column name"""
  base
}

"""
select "campaign_deck_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_deck"
"""
enum campaign_deck_select_column_campaign_deck_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  archived

  """column name"""
  base
}

"""
input type for updating data in table "campaign_deck"
"""
input campaign_deck_set_input {
  archived: Boolean
  arkhamdb_id: Int
  arkhamdb_user: Int
  base: Boolean
  campaign_id: Int
  content: jsonb
  content_hash: String
  id: Int
  investigator: String
  local_uuid: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type campaign_deck_stddev_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by stddev() on columns of table "campaign_deck"
"""
input campaign_deck_stddev_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""aggregate stddev_pop on columns"""
type campaign_deck_stddev_pop_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by stddev_pop() on columns of table "campaign_deck"
"""
input campaign_deck_stddev_pop_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""aggregate stddev_samp on columns"""
type campaign_deck_stddev_samp_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by stddev_samp() on columns of table "campaign_deck"
"""
input campaign_deck_stddev_samp_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""
Streaming cursor of the table "campaign_deck"
"""
input campaign_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_deck_stream_cursor_value_input {
  archived: Boolean
  arkhamdb_id: Int
  arkhamdb_user: Int
  base: Boolean
  campaign_id: Int
  content: jsonb
  content_hash: String
  id: Int
  investigator: String
  local_uuid: String
  next_deck_id: Int
  owner_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type campaign_deck_sum_fields {
  arkhamdb_id: Int
  arkhamdb_user: Int
  campaign_id: Int
  id: Int
  next_deck_id: Int
}

"""
order by sum() on columns of table "campaign_deck"
"""
input campaign_deck_sum_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""
update columns of table "campaign_deck"
"""
enum campaign_deck_update_column {
  """column name"""
  archived

  """column name"""
  arkhamdb_id

  """column name"""
  arkhamdb_user

  """column name"""
  base

  """column name"""
  campaign_id

  """column name"""
  content

  """column name"""
  content_hash

  """column name"""
  id

  """column name"""
  investigator

  """column name"""
  local_uuid

  """column name"""
  next_deck_id

  """column name"""
  owner_id

  """column name"""
  updated_at
}

input campaign_deck_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: campaign_deck_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: campaign_deck_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: campaign_deck_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: campaign_deck_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: campaign_deck_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: campaign_deck_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: campaign_deck_set_input

  """filter the rows which have to be updated"""
  where: campaign_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type campaign_deck_var_pop_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by var_pop() on columns of table "campaign_deck"
"""
input campaign_deck_var_pop_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""aggregate var_samp on columns"""
type campaign_deck_var_samp_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by var_samp() on columns of table "campaign_deck"
"""
input campaign_deck_var_samp_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""aggregate variance on columns"""
type campaign_deck_variance_fields {
  arkhamdb_id: Float
  arkhamdb_user: Float
  campaign_id: Float
  id: Float
  next_deck_id: Float
}

"""
order by variance() on columns of table "campaign_deck"
"""
input campaign_deck_variance_order_by {
  arkhamdb_id: order_by
  arkhamdb_user: order_by
  campaign_id: order_by
  id: order_by
  next_deck_id: order_by
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input campaign_delete_at_path_input {
  campaignNotes: [String!]
  chaosBag: [String!]
  scenarioResults: [String!]
  standaloneId: [String!]
  tarot_reading: [String!]
  weaknessSet: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input campaign_delete_elem_input {
  campaignNotes: Int
  chaosBag: Int
  scenarioResults: Int
  standaloneId: Int
  tarot_reading: Int
  weaknessSet: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input campaign_delete_key_input {
  campaignNotes: String
  chaosBag: String
  scenarioResults: String
  standaloneId: String
  tarot_reading: String
  weaknessSet: String
}

"""
columns and relationships of "campaign_difficulty"
"""
type campaign_difficulty {
  value: String!
}

"""
aggregated selection of "campaign_difficulty"
"""
type campaign_difficulty_aggregate {
  aggregate: campaign_difficulty_aggregate_fields
  nodes: [campaign_difficulty!]!
}

"""
aggregate fields of "campaign_difficulty"
"""
type campaign_difficulty_aggregate_fields {
  count(columns: [campaign_difficulty_select_column!], distinct: Boolean): Int!
  max: campaign_difficulty_max_fields
  min: campaign_difficulty_min_fields
}

"""
Boolean expression to filter rows from the table "campaign_difficulty". All fields are combined with a logical 'AND'.
"""
input campaign_difficulty_bool_exp {
  _and: [campaign_difficulty_bool_exp!]
  _not: campaign_difficulty_bool_exp
  _or: [campaign_difficulty_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "campaign_difficulty"
"""
enum campaign_difficulty_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  campaign_difficulty_pkey
}

enum campaign_difficulty_enum {
  easy
  expert
  hard
  standard
}

"""
Boolean expression to compare columns of type "campaign_difficulty_enum". All fields are combined with logical 'AND'.
"""
input campaign_difficulty_enum_comparison_exp {
  _eq: campaign_difficulty_enum
  _in: [campaign_difficulty_enum!]
  _is_null: Boolean
  _neq: campaign_difficulty_enum
  _nin: [campaign_difficulty_enum!]
}

"""
input type for inserting data into table "campaign_difficulty"
"""
input campaign_difficulty_insert_input {
  value: String
}

"""aggregate max on columns"""
type campaign_difficulty_max_fields {
  value: String
}

"""aggregate min on columns"""
type campaign_difficulty_min_fields {
  value: String
}

"""
response of any mutation on the table "campaign_difficulty"
"""
type campaign_difficulty_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign_difficulty!]!
}

"""
on_conflict condition type for table "campaign_difficulty"
"""
input campaign_difficulty_on_conflict {
  constraint: campaign_difficulty_constraint!
  update_columns: [campaign_difficulty_update_column!]! = []
  where: campaign_difficulty_bool_exp
}

"""Ordering options when selecting data from "campaign_difficulty"."""
input campaign_difficulty_order_by {
  value: order_by
}

"""primary key columns input for table: campaign_difficulty"""
input campaign_difficulty_pk_columns_input {
  value: String!
}

"""
select columns of table "campaign_difficulty"
"""
enum campaign_difficulty_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "campaign_difficulty"
"""
input campaign_difficulty_set_input {
  value: String
}

"""
Streaming cursor of the table "campaign_difficulty"
"""
input campaign_difficulty_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_difficulty_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_difficulty_stream_cursor_value_input {
  value: String
}

"""
update columns of table "campaign_difficulty"
"""
enum campaign_difficulty_update_column {
  """column name"""
  value
}

input campaign_difficulty_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: campaign_difficulty_set_input

  """filter the rows which have to be updated"""
  where: campaign_difficulty_bool_exp!
}

"""
columns and relationships of "campaign_guide"
"""
type campaign_guide {
  """An array relationship"""
  access(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): [campaign_access!]!

  """An aggregate relationship"""
  access_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): campaign_access_aggregate!
  created_at: timestamptz

  """An array relationship"""
  guide_achievements(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): [guide_achievement!]!

  """An aggregate relationship"""
  guide_achievements_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): guide_achievement_aggregate!

  """An array relationship"""
  guide_inputs(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): [guide_input!]!

  """An aggregate relationship"""
  guide_inputs_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): guide_input_aggregate!
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""
aggregated selection of "campaign_guide"
"""
type campaign_guide_aggregate {
  aggregate: campaign_guide_aggregate_fields
  nodes: [campaign_guide!]!
}

"""
aggregate fields of "campaign_guide"
"""
type campaign_guide_aggregate_fields {
  avg: campaign_guide_avg_fields
  count(columns: [campaign_guide_select_column!], distinct: Boolean): Int!
  max: campaign_guide_max_fields
  min: campaign_guide_min_fields
  stddev: campaign_guide_stddev_fields
  stddev_pop: campaign_guide_stddev_pop_fields
  stddev_samp: campaign_guide_stddev_samp_fields
  sum: campaign_guide_sum_fields
  var_pop: campaign_guide_var_pop_fields
  var_samp: campaign_guide_var_samp_fields
  variance: campaign_guide_variance_fields
}

"""aggregate avg on columns"""
type campaign_guide_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "campaign_guide". All fields are combined with a logical 'AND'.
"""
input campaign_guide_bool_exp {
  _and: [campaign_guide_bool_exp!]
  _not: campaign_guide_bool_exp
  _or: [campaign_guide_bool_exp!]
  access: campaign_access_bool_exp
  access_aggregate: campaign_access_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  guide_achievements: guide_achievement_bool_exp
  guide_achievements_aggregate: guide_achievement_aggregate_bool_exp
  guide_inputs: guide_input_bool_exp
  guide_inputs_aggregate: guide_input_aggregate_bool_exp
  id: Int_comparison_exp
  owner: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uuid: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "campaign_guide"
"""
input campaign_guide_inc_input {
  id: Int
}

"""
input type for inserting data into table "campaign_guide"
"""
input campaign_guide_insert_input {
  access: campaign_access_arr_rel_insert_input
  created_at: timestamptz
  guide_achievements: guide_achievement_arr_rel_insert_input
  guide_inputs: guide_input_arr_rel_insert_input
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""aggregate max on columns"""
type campaign_guide_max_fields {
  created_at: timestamptz
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""aggregate min on columns"""
type campaign_guide_min_fields {
  created_at: timestamptz
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""
response of any mutation on the table "campaign_guide"
"""
type campaign_guide_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign_guide!]!
}

"""
input type for inserting object relation for remote table "campaign_guide"
"""
input campaign_guide_obj_rel_insert_input {
  data: campaign_guide_insert_input!
}

"""Ordering options when selecting data from "campaign_guide"."""
input campaign_guide_order_by {
  access_aggregate: campaign_access_aggregate_order_by
  created_at: order_by
  guide_achievements_aggregate: guide_achievement_aggregate_order_by
  guide_inputs_aggregate: guide_input_aggregate_order_by
  id: order_by
  owner: order_by
  updated_at: order_by
  uuid: order_by
}

"""
select columns of table "campaign_guide"
"""
enum campaign_guide_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  owner

  """column name"""
  updated_at

  """column name"""
  uuid
}

"""
input type for updating data in table "campaign_guide"
"""
input campaign_guide_set_input {
  created_at: timestamptz
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""aggregate stddev on columns"""
type campaign_guide_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type campaign_guide_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type campaign_guide_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "campaign_guide"
"""
input campaign_guide_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_guide_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_guide_stream_cursor_value_input {
  created_at: timestamptz
  id: Int
  owner: String
  updated_at: timestamptz
  uuid: String
}

"""aggregate sum on columns"""
type campaign_guide_sum_fields {
  id: Int
}

input campaign_guide_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: campaign_guide_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: campaign_guide_set_input

  """filter the rows which have to be updated"""
  where: campaign_guide_bool_exp!
}

"""aggregate var_pop on columns"""
type campaign_guide_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type campaign_guide_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type campaign_guide_variance_fields {
  id: Float
}

"""
input type for incrementing numeric columns in table "campaign"
"""
input campaign_inc_input {
  guide_version: Int
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
}

"""
input type for inserting data into table "campaign"
"""
input campaign_insert_input {
  access: campaign_access_arr_rel_insert_input
  archived: Boolean
  base_decks: base_decks_arr_rel_insert_input
  campaignNotes: jsonb
  campaign_guide: campaign_guide_obj_rel_insert_input
  chaosBag: jsonb
  chaos_bag_result: chaos_bag_result_arr_rel_insert_input
  created_at: timestamptz
  cycleCode: String
  deleted: Boolean
  difficulty: String
  guide_version: Int
  guided: Boolean
  id: Int
  investigator_data: investigator_data_arr_rel_insert_input
  investigators: campaign_investigator_arr_rel_insert_input
  latest_decks: latest_decks_arr_rel_insert_input
  link_a_campaign: campaign_obj_rel_insert_input
  link_a_campaign_id: Int
  link_b_campaign: campaign_obj_rel_insert_input
  link_b_campaign_id: Int
  link_campaign_id: Int
  linked_campaign: campaign_obj_rel_insert_input
  name: String
  owner: users_obj_rel_insert_input
  owner_id: String
  scenarioResults: jsonb
  showInterludes: Boolean
  standaloneId: jsonb
  tarot_reading: jsonb
  updated_at: timestamptz
  uuid: String
  weaknessSet: jsonb
}

"""
columns and relationships of "campaign_investigator"
"""
type campaign_investigator {
  """An object relationship"""
  campaign: campaign!
  campaign_id: Int!
  created_at: timestamptz!

  """
  A computed field, executes function "campaign_investigator_id"
  """
  id: String
  investigator: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "campaign_investigator"
"""
type campaign_investigator_aggregate {
  aggregate: campaign_investigator_aggregate_fields
  nodes: [campaign_investigator!]!
}

input campaign_investigator_aggregate_bool_exp {
  count: campaign_investigator_aggregate_bool_exp_count
}

input campaign_investigator_aggregate_bool_exp_count {
  arguments: [campaign_investigator_select_column!]
  distinct: Boolean
  filter: campaign_investigator_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "campaign_investigator"
"""
type campaign_investigator_aggregate_fields {
  avg: campaign_investigator_avg_fields
  count(columns: [campaign_investigator_select_column!], distinct: Boolean): Int!
  max: campaign_investigator_max_fields
  min: campaign_investigator_min_fields
  stddev: campaign_investigator_stddev_fields
  stddev_pop: campaign_investigator_stddev_pop_fields
  stddev_samp: campaign_investigator_stddev_samp_fields
  sum: campaign_investigator_sum_fields
  var_pop: campaign_investigator_var_pop_fields
  var_samp: campaign_investigator_var_samp_fields
  variance: campaign_investigator_variance_fields
}

"""
order by aggregate values of table "campaign_investigator"
"""
input campaign_investigator_aggregate_order_by {
  avg: campaign_investigator_avg_order_by
  count: order_by
  max: campaign_investigator_max_order_by
  min: campaign_investigator_min_order_by
  stddev: campaign_investigator_stddev_order_by
  stddev_pop: campaign_investigator_stddev_pop_order_by
  stddev_samp: campaign_investigator_stddev_samp_order_by
  sum: campaign_investigator_sum_order_by
  var_pop: campaign_investigator_var_pop_order_by
  var_samp: campaign_investigator_var_samp_order_by
  variance: campaign_investigator_variance_order_by
}

"""
input type for inserting array relation for remote table "campaign_investigator"
"""
input campaign_investigator_arr_rel_insert_input {
  data: [campaign_investigator_insert_input!]!

  """upsert condition"""
  on_conflict: campaign_investigator_on_conflict
}

"""aggregate avg on columns"""
type campaign_investigator_avg_fields {
  campaign_id: Float
}

"""
order by avg() on columns of table "campaign_investigator"
"""
input campaign_investigator_avg_order_by {
  campaign_id: order_by
}

"""
Boolean expression to filter rows from the table "campaign_investigator". All fields are combined with a logical 'AND'.
"""
input campaign_investigator_bool_exp {
  _and: [campaign_investigator_bool_exp!]
  _not: campaign_investigator_bool_exp
  _or: [campaign_investigator_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  investigator: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "campaign_investigator"
"""
enum campaign_investigator_constraint {
  """
  unique or primary key constraint on columns "campaign_id", "investigator"
  """
  campaign_investigator_campaign_id_investigator_key

  """
  unique or primary key constraint on columns "campaign_id", "investigator"
  """
  campaign_investigator_pkey
}

"""
input type for incrementing numeric columns in table "campaign_investigator"
"""
input campaign_investigator_inc_input {
  campaign_id: Int
}

"""
input type for inserting data into table "campaign_investigator"
"""
input campaign_investigator_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  created_at: timestamptz
  investigator: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type campaign_investigator_max_fields {
  campaign_id: Int
  created_at: timestamptz

  """
  A computed field, executes function "campaign_investigator_id"
  """
  id: String
  investigator: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "campaign_investigator"
"""
input campaign_investigator_max_order_by {
  campaign_id: order_by
  created_at: order_by
  investigator: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type campaign_investigator_min_fields {
  campaign_id: Int
  created_at: timestamptz

  """
  A computed field, executes function "campaign_investigator_id"
  """
  id: String
  investigator: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "campaign_investigator"
"""
input campaign_investigator_min_order_by {
  campaign_id: order_by
  created_at: order_by
  investigator: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "campaign_investigator"
"""
type campaign_investigator_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign_investigator!]!
}

"""
on_conflict condition type for table "campaign_investigator"
"""
input campaign_investigator_on_conflict {
  constraint: campaign_investigator_constraint!
  update_columns: [campaign_investigator_update_column!]! = []
  where: campaign_investigator_bool_exp
}

"""Ordering options when selecting data from "campaign_investigator"."""
input campaign_investigator_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  created_at: order_by
  id: order_by
  investigator: order_by
  updated_at: order_by
}

"""primary key columns input for table: campaign_investigator"""
input campaign_investigator_pk_columns_input {
  campaign_id: Int!
  investigator: String!
}

"""
select columns of table "campaign_investigator"
"""
enum campaign_investigator_select_column {
  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  investigator

  """column name"""
  updated_at
}

"""
input type for updating data in table "campaign_investigator"
"""
input campaign_investigator_set_input {
  campaign_id: Int
  created_at: timestamptz
  investigator: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type campaign_investigator_stddev_fields {
  campaign_id: Float
}

"""
order by stddev() on columns of table "campaign_investigator"
"""
input campaign_investigator_stddev_order_by {
  campaign_id: order_by
}

"""aggregate stddev_pop on columns"""
type campaign_investigator_stddev_pop_fields {
  campaign_id: Float
}

"""
order by stddev_pop() on columns of table "campaign_investigator"
"""
input campaign_investigator_stddev_pop_order_by {
  campaign_id: order_by
}

"""aggregate stddev_samp on columns"""
type campaign_investigator_stddev_samp_fields {
  campaign_id: Float
}

"""
order by stddev_samp() on columns of table "campaign_investigator"
"""
input campaign_investigator_stddev_samp_order_by {
  campaign_id: order_by
}

"""
Streaming cursor of the table "campaign_investigator"
"""
input campaign_investigator_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_investigator_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_investigator_stream_cursor_value_input {
  campaign_id: Int
  created_at: timestamptz
  investigator: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type campaign_investigator_sum_fields {
  campaign_id: Int
}

"""
order by sum() on columns of table "campaign_investigator"
"""
input campaign_investigator_sum_order_by {
  campaign_id: order_by
}

"""
update columns of table "campaign_investigator"
"""
enum campaign_investigator_update_column {
  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  investigator

  """column name"""
  updated_at
}

input campaign_investigator_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: campaign_investigator_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: campaign_investigator_set_input

  """filter the rows which have to be updated"""
  where: campaign_investigator_bool_exp!
}

"""aggregate var_pop on columns"""
type campaign_investigator_var_pop_fields {
  campaign_id: Float
}

"""
order by var_pop() on columns of table "campaign_investigator"
"""
input campaign_investigator_var_pop_order_by {
  campaign_id: order_by
}

"""aggregate var_samp on columns"""
type campaign_investigator_var_samp_fields {
  campaign_id: Float
}

"""
order by var_samp() on columns of table "campaign_investigator"
"""
input campaign_investigator_var_samp_order_by {
  campaign_id: order_by
}

"""aggregate variance on columns"""
type campaign_investigator_variance_fields {
  campaign_id: Float
}

"""
order by variance() on columns of table "campaign_investigator"
"""
input campaign_investigator_variance_order_by {
  campaign_id: order_by
}

"""aggregate max on columns"""
type campaign_max_fields {
  created_at: timestamptz
  cycleCode: String
  difficulty: String
  guide_version: Int
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
  name: String
  owner_id: String
  updated_at: timestamptz
  uuid: String
}

"""aggregate min on columns"""
type campaign_min_fields {
  created_at: timestamptz
  cycleCode: String
  difficulty: String
  guide_version: Int
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
  name: String
  owner_id: String
  updated_at: timestamptz
  uuid: String
}

"""
response of any mutation on the table "campaign"
"""
type campaign_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [campaign!]!
}

"""
input type for inserting object relation for remote table "campaign"
"""
input campaign_obj_rel_insert_input {
  data: campaign_insert_input!

  """upsert condition"""
  on_conflict: campaign_on_conflict
}

"""
on_conflict condition type for table "campaign"
"""
input campaign_on_conflict {
  constraint: campaign_constraint!
  update_columns: [campaign_update_column!]! = []
  where: campaign_bool_exp
}

"""Ordering options when selecting data from "campaign"."""
input campaign_order_by {
  access_aggregate: campaign_access_aggregate_order_by
  archived: order_by
  base_decks_aggregate: base_decks_aggregate_order_by
  campaignNotes: order_by
  campaign_guide: campaign_guide_order_by
  chaosBag: order_by
  chaos_bag_result_aggregate: chaos_bag_result_aggregate_order_by
  created_at: order_by
  cycleCode: order_by
  deleted: order_by
  difficulty: order_by
  guide_version: order_by
  guided: order_by
  id: order_by
  investigator_data_aggregate: investigator_data_aggregate_order_by
  investigators_aggregate: campaign_investigator_aggregate_order_by
  latest_decks_aggregate: latest_decks_aggregate_order_by
  link_a_campaign: campaign_order_by
  link_a_campaign_id: order_by
  link_b_campaign: campaign_order_by
  link_b_campaign_id: order_by
  link_campaign_id: order_by
  linked_campaign: campaign_order_by
  name: order_by
  owner: users_order_by
  owner_id: order_by
  scenarioResults: order_by
  showInterludes: order_by
  standaloneId: order_by
  tarot_reading: order_by
  updated_at: order_by
  uuid: order_by
  weaknessSet: order_by
}

"""primary key columns input for table: campaign"""
input campaign_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input campaign_prepend_input {
  campaignNotes: jsonb
  chaosBag: jsonb
  scenarioResults: jsonb
  standaloneId: jsonb
  tarot_reading: jsonb
  weaknessSet: jsonb
}

"""
select columns of table "campaign"
"""
enum campaign_select_column {
  """column name"""
  archived

  """column name"""
  campaignNotes

  """column name"""
  chaosBag

  """column name"""
  created_at

  """column name"""
  cycleCode

  """column name"""
  deleted

  """column name"""
  difficulty

  """column name"""
  guide_version

  """column name"""
  guided

  """column name"""
  id

  """column name"""
  link_a_campaign_id

  """column name"""
  link_b_campaign_id

  """column name"""
  link_campaign_id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  scenarioResults

  """column name"""
  showInterludes

  """column name"""
  standaloneId

  """column name"""
  tarot_reading

  """column name"""
  updated_at

  """column name"""
  uuid

  """column name"""
  weaknessSet
}

"""
input type for updating data in table "campaign"
"""
input campaign_set_input {
  archived: Boolean
  campaignNotes: jsonb
  chaosBag: jsonb
  created_at: timestamptz
  cycleCode: String
  deleted: Boolean
  difficulty: String
  guide_version: Int
  guided: Boolean
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
  name: String
  owner_id: String
  scenarioResults: jsonb
  showInterludes: Boolean
  standaloneId: jsonb
  tarot_reading: jsonb
  updated_at: timestamptz
  uuid: String
  weaknessSet: jsonb
}

"""aggregate stddev on columns"""
type campaign_stddev_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""aggregate stddev_pop on columns"""
type campaign_stddev_pop_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""aggregate stddev_samp on columns"""
type campaign_stddev_samp_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""
Streaming cursor of the table "campaign"
"""
input campaign_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaign_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaign_stream_cursor_value_input {
  archived: Boolean
  campaignNotes: jsonb
  chaosBag: jsonb
  created_at: timestamptz
  cycleCode: String
  deleted: Boolean
  difficulty: String
  guide_version: Int
  guided: Boolean
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
  name: String
  owner_id: String
  scenarioResults: jsonb
  showInterludes: Boolean
  standaloneId: jsonb
  tarot_reading: jsonb
  updated_at: timestamptz
  uuid: String
  weaknessSet: jsonb
}

"""aggregate sum on columns"""
type campaign_sum_fields {
  guide_version: Int
  id: Int
  link_a_campaign_id: Int
  link_b_campaign_id: Int
  link_campaign_id: Int
}

"""
update columns of table "campaign"
"""
enum campaign_update_column {
  """column name"""
  archived

  """column name"""
  campaignNotes

  """column name"""
  chaosBag

  """column name"""
  created_at

  """column name"""
  cycleCode

  """column name"""
  deleted

  """column name"""
  difficulty

  """column name"""
  guide_version

  """column name"""
  guided

  """column name"""
  id

  """column name"""
  link_a_campaign_id

  """column name"""
  link_b_campaign_id

  """column name"""
  link_campaign_id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  scenarioResults

  """column name"""
  showInterludes

  """column name"""
  standaloneId

  """column name"""
  tarot_reading

  """column name"""
  updated_at

  """column name"""
  uuid

  """column name"""
  weaknessSet
}

input campaign_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: campaign_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: campaign_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: campaign_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: campaign_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: campaign_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: campaign_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: campaign_set_input

  """filter the rows which have to be updated"""
  where: campaign_bool_exp!
}

"""aggregate var_pop on columns"""
type campaign_var_pop_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""aggregate var_samp on columns"""
type campaign_var_samp_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""aggregate variance on columns"""
type campaign_variance_fields {
  guide_version: Float
  id: Float
  link_a_campaign_id: Float
  link_b_campaign_id: Float
  link_campaign_id: Float
}

"""
columns and relationships of "campaigns_by_cycle"
"""
type campaigns_by_cycle {
  count: bigint
  cyclecode: String
}

"""
aggregated selection of "campaigns_by_cycle"
"""
type campaigns_by_cycle_aggregate {
  aggregate: campaigns_by_cycle_aggregate_fields
  nodes: [campaigns_by_cycle!]!
}

"""
aggregate fields of "campaigns_by_cycle"
"""
type campaigns_by_cycle_aggregate_fields {
  avg: campaigns_by_cycle_avg_fields
  count(columns: [campaigns_by_cycle_select_column!], distinct: Boolean): Int!
  max: campaigns_by_cycle_max_fields
  min: campaigns_by_cycle_min_fields
  stddev: campaigns_by_cycle_stddev_fields
  stddev_pop: campaigns_by_cycle_stddev_pop_fields
  stddev_samp: campaigns_by_cycle_stddev_samp_fields
  sum: campaigns_by_cycle_sum_fields
  var_pop: campaigns_by_cycle_var_pop_fields
  var_samp: campaigns_by_cycle_var_samp_fields
  variance: campaigns_by_cycle_variance_fields
}

"""aggregate avg on columns"""
type campaigns_by_cycle_avg_fields {
  count: Float
}

"""
Boolean expression to filter rows from the table "campaigns_by_cycle". All fields are combined with a logical 'AND'.
"""
input campaigns_by_cycle_bool_exp {
  _and: [campaigns_by_cycle_bool_exp!]
  _not: campaigns_by_cycle_bool_exp
  _or: [campaigns_by_cycle_bool_exp!]
  count: bigint_comparison_exp
  cyclecode: String_comparison_exp
}

"""aggregate max on columns"""
type campaigns_by_cycle_max_fields {
  count: bigint
  cyclecode: String
}

"""aggregate min on columns"""
type campaigns_by_cycle_min_fields {
  count: bigint
  cyclecode: String
}

"""Ordering options when selecting data from "campaigns_by_cycle"."""
input campaigns_by_cycle_order_by {
  count: order_by
  cyclecode: order_by
}

"""
select columns of table "campaigns_by_cycle"
"""
enum campaigns_by_cycle_select_column {
  """column name"""
  count

  """column name"""
  cyclecode
}

"""aggregate stddev on columns"""
type campaigns_by_cycle_stddev_fields {
  count: Float
}

"""aggregate stddev_pop on columns"""
type campaigns_by_cycle_stddev_pop_fields {
  count: Float
}

"""aggregate stddev_samp on columns"""
type campaigns_by_cycle_stddev_samp_fields {
  count: Float
}

"""
Streaming cursor of the table "campaigns_by_cycle"
"""
input campaigns_by_cycle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: campaigns_by_cycle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input campaigns_by_cycle_stream_cursor_value_input {
  count: bigint
  cyclecode: String
}

"""aggregate sum on columns"""
type campaigns_by_cycle_sum_fields {
  count: bigint
}

"""aggregate var_pop on columns"""
type campaigns_by_cycle_var_pop_fields {
  count: Float
}

"""aggregate var_samp on columns"""
type campaigns_by_cycle_var_samp_fields {
  count: Float
}

"""aggregate variance on columns"""
type campaigns_by_cycle_variance_fields {
  count: Float
}

"""
columns and relationships of "card"
"""
type card {
  back_link: String
  clues: Int
  code: String!
  cost: Int
  deck_limit: Int
  deck_options(
    """JSON select path"""
    path: String
  ): jsonb
  deck_requirements(
    """JSON select path"""
    path: String
  ): jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction_code: String!
  health: Int
  hidden: Boolean
  illustrator: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String!
  pack_position: Int!

  """An array relationship"""
  packs(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """An aggregate relationship"""
  packs_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!
  permanent: Boolean
  position: Int!
  quantity: Int!
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String!
  real_pack_name: String!
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions(
    """JSON select path"""
    path: String
  ): jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): [card_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): card_text_aggregate!
  type_code: String!
  victory: Int
}

"""
aggregated selection of "card"
"""
type card_aggregate {
  aggregate: card_aggregate_fields
  nodes: [card!]!
}

"""
aggregate fields of "card"
"""
type card_aggregate_fields {
  avg: card_avg_fields
  count(columns: [card_select_column!], distinct: Boolean): Int!
  max: card_max_fields
  min: card_min_fields
  stddev: card_stddev_fields
  stddev_pop: card_stddev_pop_fields
  stddev_samp: card_stddev_samp_fields
  sum: card_sum_fields
  var_pop: card_var_pop_fields
  var_samp: card_var_samp_fields
  variance: card_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input card_append_input {
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
}

"""aggregate avg on columns"""
type card_avg_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""
Boolean expression to filter rows from the table "card". All fields are combined with a logical 'AND'.
"""
input card_bool_exp {
  _and: [card_bool_exp!]
  _not: card_bool_exp
  _or: [card_bool_exp!]
  back_link: String_comparison_exp
  clues: Int_comparison_exp
  code: String_comparison_exp
  cost: Int_comparison_exp
  deck_limit: Int_comparison_exp
  deck_options: jsonb_comparison_exp
  deck_requirements: jsonb_comparison_exp
  doom: Int_comparison_exp
  double_sided: Boolean_comparison_exp
  encounter_code: String_comparison_exp
  encounter_position: Int_comparison_exp
  enemy_damage: Int_comparison_exp
  enemy_evade: Int_comparison_exp
  enemy_fight: Int_comparison_exp
  enemy_horror: Int_comparison_exp
  exceptional: Boolean_comparison_exp
  exile: Boolean_comparison_exp
  faction_code: String_comparison_exp
  health: Int_comparison_exp
  hidden: Boolean_comparison_exp
  illustrator: String_comparison_exp
  is_unique: Boolean_comparison_exp
  myriad: Boolean_comparison_exp
  pack_code: String_comparison_exp
  pack_position: Int_comparison_exp
  packs: card_pack_bool_exp
  packs_aggregate: card_pack_aggregate_bool_exp
  permanent: Boolean_comparison_exp
  position: Int_comparison_exp
  quantity: Int_comparison_exp
  real_back_flavor: String_comparison_exp
  real_back_name: String_comparison_exp
  real_back_text: String_comparison_exp
  real_flavor: String_comparison_exp
  real_name: String_comparison_exp
  real_pack_name: String_comparison_exp
  real_slot: String_comparison_exp
  real_subname: String_comparison_exp
  real_text: String_comparison_exp
  real_traits: String_comparison_exp
  restrictions: jsonb_comparison_exp
  sanity: Int_comparison_exp
  shroud: Int_comparison_exp
  skill_agility: Int_comparison_exp
  skill_combat: Int_comparison_exp
  skill_intellect: Int_comparison_exp
  skill_wild: Int_comparison_exp
  skill_willpower: Int_comparison_exp
  stage: Int_comparison_exp
  subtype_code: String_comparison_exp
  translations: card_text_bool_exp
  translations_aggregate: card_text_aggregate_bool_exp
  type_code: String_comparison_exp
  victory: Int_comparison_exp
}

"""
unique or primary key constraints on table "card"
"""
enum card_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  card_pkey
}

"""
columns and relationships of "card_cycle"
"""
type card_cycle {
  code: String!
  locale: String!
  name: String!
  official: Boolean!

  """An array relationship"""
  packs(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """An aggregate relationship"""
  packs_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!
  position: Int!
}

"""
aggregated selection of "card_cycle"
"""
type card_cycle_aggregate {
  aggregate: card_cycle_aggregate_fields
  nodes: [card_cycle!]!
}

"""
aggregate fields of "card_cycle"
"""
type card_cycle_aggregate_fields {
  avg: card_cycle_avg_fields
  count(columns: [card_cycle_select_column!], distinct: Boolean): Int!
  max: card_cycle_max_fields
  min: card_cycle_min_fields
  stddev: card_cycle_stddev_fields
  stddev_pop: card_cycle_stddev_pop_fields
  stddev_samp: card_cycle_stddev_samp_fields
  sum: card_cycle_sum_fields
  var_pop: card_cycle_var_pop_fields
  var_samp: card_cycle_var_samp_fields
  variance: card_cycle_variance_fields
}

"""aggregate avg on columns"""
type card_cycle_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "card_cycle". All fields are combined with a logical 'AND'.
"""
input card_cycle_bool_exp {
  _and: [card_cycle_bool_exp!]
  _not: card_cycle_bool_exp
  _or: [card_cycle_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  official: Boolean_comparison_exp
  packs: card_pack_bool_exp
  packs_aggregate: card_pack_aggregate_bool_exp
  position: Int_comparison_exp
}

"""
unique or primary key constraints on table "card_cycle"
"""
enum card_cycle_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_cycle_pkey
}

"""
input type for incrementing numeric columns in table "card_cycle"
"""
input card_cycle_inc_input {
  position: Int
}

"""
input type for inserting data into table "card_cycle"
"""
input card_cycle_insert_input {
  code: String
  locale: String
  name: String
  official: Boolean
  packs: card_pack_arr_rel_insert_input
  position: Int
}

"""aggregate max on columns"""
type card_cycle_max_fields {
  code: String
  locale: String
  name: String
  position: Int
}

"""aggregate min on columns"""
type card_cycle_min_fields {
  code: String
  locale: String
  name: String
  position: Int
}

"""
response of any mutation on the table "card_cycle"
"""
type card_cycle_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_cycle!]!
}

"""
input type for inserting object relation for remote table "card_cycle"
"""
input card_cycle_obj_rel_insert_input {
  data: card_cycle_insert_input!

  """upsert condition"""
  on_conflict: card_cycle_on_conflict
}

"""
on_conflict condition type for table "card_cycle"
"""
input card_cycle_on_conflict {
  constraint: card_cycle_constraint!
  update_columns: [card_cycle_update_column!]! = []
  where: card_cycle_bool_exp
}

"""Ordering options when selecting data from "card_cycle"."""
input card_cycle_order_by {
  code: order_by
  locale: order_by
  name: order_by
  official: order_by
  packs_aggregate: card_pack_aggregate_order_by
  position: order_by
}

"""primary key columns input for table: card_cycle"""
input card_cycle_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "card_cycle"
"""
enum card_cycle_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official

  """column name"""
  position
}

"""
input type for updating data in table "card_cycle"
"""
input card_cycle_set_input {
  code: String
  locale: String
  name: String
  official: Boolean
  position: Int
}

"""aggregate stddev on columns"""
type card_cycle_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type card_cycle_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type card_cycle_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "card_cycle"
"""
input card_cycle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_cycle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_cycle_stream_cursor_value_input {
  code: String
  locale: String
  name: String
  official: Boolean
  position: Int
}

"""aggregate sum on columns"""
type card_cycle_sum_fields {
  position: Int
}

"""
update columns of table "card_cycle"
"""
enum card_cycle_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official

  """column name"""
  position
}

input card_cycle_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: card_cycle_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: card_cycle_set_input

  """filter the rows which have to be updated"""
  where: card_cycle_bool_exp!
}

"""aggregate var_pop on columns"""
type card_cycle_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type card_cycle_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type card_cycle_variance_fields {
  position: Float
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input card_delete_at_path_input {
  deck_options: [String!]
  deck_requirements: [String!]
  restrictions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input card_delete_elem_input {
  deck_options: Int
  deck_requirements: Int
  restrictions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input card_delete_key_input {
  deck_options: String
  deck_requirements: String
  restrictions: String
}

"""
columns and relationships of "card_encounter_set"
"""
type card_encounter_set {
  """An array relationship"""
  cards(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """An aggregate relationship"""
  cards_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): all_card_aggregate!
  code: String!
  locale: String!
  name: String!
  official: Boolean!
}

"""
aggregated selection of "card_encounter_set"
"""
type card_encounter_set_aggregate {
  aggregate: card_encounter_set_aggregate_fields
  nodes: [card_encounter_set!]!
}

input card_encounter_set_aggregate_bool_exp {
  bool_and: card_encounter_set_aggregate_bool_exp_bool_and
  bool_or: card_encounter_set_aggregate_bool_exp_bool_or
  count: card_encounter_set_aggregate_bool_exp_count
}

input card_encounter_set_aggregate_bool_exp_bool_and {
  arguments: card_encounter_set_select_column_card_encounter_set_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: card_encounter_set_bool_exp
  predicate: Boolean_comparison_exp!
}

input card_encounter_set_aggregate_bool_exp_bool_or {
  arguments: card_encounter_set_select_column_card_encounter_set_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: card_encounter_set_bool_exp
  predicate: Boolean_comparison_exp!
}

input card_encounter_set_aggregate_bool_exp_count {
  arguments: [card_encounter_set_select_column!]
  distinct: Boolean
  filter: card_encounter_set_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "card_encounter_set"
"""
type card_encounter_set_aggregate_fields {
  count(columns: [card_encounter_set_select_column!], distinct: Boolean): Int!
  max: card_encounter_set_max_fields
  min: card_encounter_set_min_fields
}

"""
order by aggregate values of table "card_encounter_set"
"""
input card_encounter_set_aggregate_order_by {
  count: order_by
  max: card_encounter_set_max_order_by
  min: card_encounter_set_min_order_by
}

"""
input type for inserting array relation for remote table "card_encounter_set"
"""
input card_encounter_set_arr_rel_insert_input {
  data: [card_encounter_set_insert_input!]!

  """upsert condition"""
  on_conflict: card_encounter_set_on_conflict
}

"""
Boolean expression to filter rows from the table "card_encounter_set". All fields are combined with a logical 'AND'.
"""
input card_encounter_set_bool_exp {
  _and: [card_encounter_set_bool_exp!]
  _not: card_encounter_set_bool_exp
  _or: [card_encounter_set_bool_exp!]
  cards: all_card_bool_exp
  cards_aggregate: all_card_aggregate_bool_exp
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  official: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "card_encounter_set"
"""
enum card_encounter_set_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_encounter_set_pkey
}

"""
input type for inserting data into table "card_encounter_set"
"""
input card_encounter_set_insert_input {
  cards: all_card_arr_rel_insert_input
  code: String
  locale: String
  name: String
  official: Boolean
}

"""aggregate max on columns"""
type card_encounter_set_max_fields {
  code: String
  locale: String
  name: String
}

"""
order by max() on columns of table "card_encounter_set"
"""
input card_encounter_set_max_order_by {
  code: order_by
  locale: order_by
  name: order_by
}

"""aggregate min on columns"""
type card_encounter_set_min_fields {
  code: String
  locale: String
  name: String
}

"""
order by min() on columns of table "card_encounter_set"
"""
input card_encounter_set_min_order_by {
  code: order_by
  locale: order_by
  name: order_by
}

"""
response of any mutation on the table "card_encounter_set"
"""
type card_encounter_set_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_encounter_set!]!
}

"""
on_conflict condition type for table "card_encounter_set"
"""
input card_encounter_set_on_conflict {
  constraint: card_encounter_set_constraint!
  update_columns: [card_encounter_set_update_column!]! = []
  where: card_encounter_set_bool_exp
}

"""Ordering options when selecting data from "card_encounter_set"."""
input card_encounter_set_order_by {
  cards_aggregate: all_card_aggregate_order_by
  code: order_by
  locale: order_by
  name: order_by
  official: order_by
}

"""primary key columns input for table: card_encounter_set"""
input card_encounter_set_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "card_encounter_set"
"""
enum card_encounter_set_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official
}

"""
select "card_encounter_set_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_encounter_set"
"""
enum card_encounter_set_select_column_card_encounter_set_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  official
}

"""
select "card_encounter_set_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_encounter_set"
"""
enum card_encounter_set_select_column_card_encounter_set_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  official
}

"""
input type for updating data in table "card_encounter_set"
"""
input card_encounter_set_set_input {
  code: String
  locale: String
  name: String
  official: Boolean
}

"""
Streaming cursor of the table "card_encounter_set"
"""
input card_encounter_set_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_encounter_set_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_encounter_set_stream_cursor_value_input {
  code: String
  locale: String
  name: String
  official: Boolean
}

"""
update columns of table "card_encounter_set"
"""
enum card_encounter_set_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official
}

input card_encounter_set_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: card_encounter_set_set_input

  """filter the rows which have to be updated"""
  where: card_encounter_set_bool_exp!
}

"""
input type for incrementing numeric columns in table "card"
"""
input card_inc_input {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  victory: Int
}

"""
input type for inserting data into table "card"
"""
input card_insert_input {
  back_link: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction_code: String
  health: Int
  hidden: Boolean
  illustrator: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String
  pack_position: Int
  packs: card_pack_arr_rel_insert_input
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  translations: card_text_arr_rel_insert_input
  type_code: String
  victory: Int
}

"""aggregate max on columns"""
type card_max_fields {
  back_link: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  faction_code: String
  health: Int
  illustrator: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: String
  victory: Int
}

"""aggregate min on columns"""
type card_min_fields {
  back_link: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  faction_code: String
  health: Int
  illustrator: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: String
  victory: Int
}

"""
response of any mutation on the table "card"
"""
type card_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card!]!
}

"""
on_conflict condition type for table "card"
"""
input card_on_conflict {
  constraint: card_constraint!
  update_columns: [card_update_column!]! = []
  where: card_bool_exp
}

"""Ordering options when selecting data from "card"."""
input card_order_by {
  back_link: order_by
  clues: order_by
  code: order_by
  cost: order_by
  deck_limit: order_by
  deck_options: order_by
  deck_requirements: order_by
  doom: order_by
  double_sided: order_by
  encounter_code: order_by
  encounter_position: order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  exceptional: order_by
  exile: order_by
  faction_code: order_by
  health: order_by
  hidden: order_by
  illustrator: order_by
  is_unique: order_by
  myriad: order_by
  pack_code: order_by
  pack_position: order_by
  packs_aggregate: card_pack_aggregate_order_by
  permanent: order_by
  position: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_name: order_by
  real_back_text: order_by
  real_flavor: order_by
  real_name: order_by
  real_pack_name: order_by
  real_slot: order_by
  real_subname: order_by
  real_text: order_by
  real_traits: order_by
  restrictions: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  subtype_code: order_by
  translations_aggregate: card_text_aggregate_order_by
  type_code: order_by
  victory: order_by
}

"""
columns and relationships of "card_pack"
"""
type card_pack {
  code: String!

  """An object relationship"""
  cycle: card_cycle
  cycle_code: String
  locale: String!
  name: String!
  official: Boolean!
  position: Int
}

"""
aggregated selection of "card_pack"
"""
type card_pack_aggregate {
  aggregate: card_pack_aggregate_fields
  nodes: [card_pack!]!
}

input card_pack_aggregate_bool_exp {
  bool_and: card_pack_aggregate_bool_exp_bool_and
  bool_or: card_pack_aggregate_bool_exp_bool_or
  count: card_pack_aggregate_bool_exp_count
}

input card_pack_aggregate_bool_exp_bool_and {
  arguments: card_pack_select_column_card_pack_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: card_pack_bool_exp
  predicate: Boolean_comparison_exp!
}

input card_pack_aggregate_bool_exp_bool_or {
  arguments: card_pack_select_column_card_pack_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: card_pack_bool_exp
  predicate: Boolean_comparison_exp!
}

input card_pack_aggregate_bool_exp_count {
  arguments: [card_pack_select_column!]
  distinct: Boolean
  filter: card_pack_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "card_pack"
"""
type card_pack_aggregate_fields {
  avg: card_pack_avg_fields
  count(columns: [card_pack_select_column!], distinct: Boolean): Int!
  max: card_pack_max_fields
  min: card_pack_min_fields
  stddev: card_pack_stddev_fields
  stddev_pop: card_pack_stddev_pop_fields
  stddev_samp: card_pack_stddev_samp_fields
  sum: card_pack_sum_fields
  var_pop: card_pack_var_pop_fields
  var_samp: card_pack_var_samp_fields
  variance: card_pack_variance_fields
}

"""
order by aggregate values of table "card_pack"
"""
input card_pack_aggregate_order_by {
  avg: card_pack_avg_order_by
  count: order_by
  max: card_pack_max_order_by
  min: card_pack_min_order_by
  stddev: card_pack_stddev_order_by
  stddev_pop: card_pack_stddev_pop_order_by
  stddev_samp: card_pack_stddev_samp_order_by
  sum: card_pack_sum_order_by
  var_pop: card_pack_var_pop_order_by
  var_samp: card_pack_var_samp_order_by
  variance: card_pack_variance_order_by
}

"""
input type for inserting array relation for remote table "card_pack"
"""
input card_pack_arr_rel_insert_input {
  data: [card_pack_insert_input!]!

  """upsert condition"""
  on_conflict: card_pack_on_conflict
}

"""aggregate avg on columns"""
type card_pack_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "card_pack"
"""
input card_pack_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "card_pack". All fields are combined with a logical 'AND'.
"""
input card_pack_bool_exp {
  _and: [card_pack_bool_exp!]
  _not: card_pack_bool_exp
  _or: [card_pack_bool_exp!]
  code: String_comparison_exp
  cycle: card_cycle_bool_exp
  cycle_code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  official: Boolean_comparison_exp
  position: Int_comparison_exp
}

"""
unique or primary key constraints on table "card_pack"
"""
enum card_pack_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_pack_pkey
}

"""
input type for incrementing numeric columns in table "card_pack"
"""
input card_pack_inc_input {
  position: Int
}

"""
input type for inserting data into table "card_pack"
"""
input card_pack_insert_input {
  code: String
  cycle: card_cycle_obj_rel_insert_input
  cycle_code: String
  locale: String
  name: String
  official: Boolean
  position: Int
}

"""aggregate max on columns"""
type card_pack_max_fields {
  code: String
  cycle_code: String
  locale: String
  name: String
  position: Int
}

"""
order by max() on columns of table "card_pack"
"""
input card_pack_max_order_by {
  code: order_by
  cycle_code: order_by
  locale: order_by
  name: order_by
  position: order_by
}

"""aggregate min on columns"""
type card_pack_min_fields {
  code: String
  cycle_code: String
  locale: String
  name: String
  position: Int
}

"""
order by min() on columns of table "card_pack"
"""
input card_pack_min_order_by {
  code: order_by
  cycle_code: order_by
  locale: order_by
  name: order_by
  position: order_by
}

"""
response of any mutation on the table "card_pack"
"""
type card_pack_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_pack!]!
}

"""
on_conflict condition type for table "card_pack"
"""
input card_pack_on_conflict {
  constraint: card_pack_constraint!
  update_columns: [card_pack_update_column!]! = []
  where: card_pack_bool_exp
}

"""Ordering options when selecting data from "card_pack"."""
input card_pack_order_by {
  code: order_by
  cycle: card_cycle_order_by
  cycle_code: order_by
  locale: order_by
  name: order_by
  official: order_by
  position: order_by
}

"""primary key columns input for table: card_pack"""
input card_pack_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "card_pack"
"""
enum card_pack_select_column {
  """column name"""
  code

  """column name"""
  cycle_code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official

  """column name"""
  position
}

"""
select "card_pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_pack"
"""
enum card_pack_select_column_card_pack_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  official
}

"""
select "card_pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_pack"
"""
enum card_pack_select_column_card_pack_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  official
}

"""
input type for updating data in table "card_pack"
"""
input card_pack_set_input {
  code: String
  cycle_code: String
  locale: String
  name: String
  official: Boolean
  position: Int
}

"""aggregate stddev on columns"""
type card_pack_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "card_pack"
"""
input card_pack_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type card_pack_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "card_pack"
"""
input card_pack_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type card_pack_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "card_pack"
"""
input card_pack_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "card_pack"
"""
input card_pack_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_pack_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_pack_stream_cursor_value_input {
  code: String
  cycle_code: String
  locale: String
  name: String
  official: Boolean
  position: Int
}

"""aggregate sum on columns"""
type card_pack_sum_fields {
  position: Int
}

"""
order by sum() on columns of table "card_pack"
"""
input card_pack_sum_order_by {
  position: order_by
}

"""
update columns of table "card_pack"
"""
enum card_pack_update_column {
  """column name"""
  code

  """column name"""
  cycle_code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  official

  """column name"""
  position
}

input card_pack_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: card_pack_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: card_pack_set_input

  """filter the rows which have to be updated"""
  where: card_pack_bool_exp!
}

"""aggregate var_pop on columns"""
type card_pack_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "card_pack"
"""
input card_pack_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type card_pack_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "card_pack"
"""
input card_pack_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type card_pack_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "card_pack"
"""
input card_pack_variance_order_by {
  position: order_by
}

"""primary key columns input for table: card"""
input card_pk_columns_input {
  code: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input card_prepend_input {
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
}

"""
select columns of table "card"
"""
enum card_select_column {
  """column name"""
  back_link

  """column name"""
  clues

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction_code

  """column name"""
  health

  """column name"""
  hidden

  """column name"""
  illustrator

  """column name"""
  is_unique

  """column name"""
  myriad

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  type_code

  """column name"""
  victory
}

"""
input type for updating data in table "card"
"""
input card_set_input {
  back_link: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction_code: String
  health: Int
  hidden: Boolean
  illustrator: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: String
  victory: Int
}

"""aggregate stddev on columns"""
type card_stddev_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""aggregate stddev_pop on columns"""
type card_stddev_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""aggregate stddev_samp on columns"""
type card_stddev_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""
Streaming cursor of the table "card"
"""
input card_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_stream_cursor_value_input {
  back_link: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction_code: String
  health: Int
  hidden: Boolean
  illustrator: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: String
  victory: Int
}

"""
columns and relationships of "card_subtype_name"
"""
type card_subtype_name {
  code: String!
  locale: String!
  name: String!
}

"""
aggregated selection of "card_subtype_name"
"""
type card_subtype_name_aggregate {
  aggregate: card_subtype_name_aggregate_fields
  nodes: [card_subtype_name!]!
}

"""
aggregate fields of "card_subtype_name"
"""
type card_subtype_name_aggregate_fields {
  count(columns: [card_subtype_name_select_column!], distinct: Boolean): Int!
  max: card_subtype_name_max_fields
  min: card_subtype_name_min_fields
}

"""
Boolean expression to filter rows from the table "card_subtype_name". All fields are combined with a logical 'AND'.
"""
input card_subtype_name_bool_exp {
  _and: [card_subtype_name_bool_exp!]
  _not: card_subtype_name_bool_exp
  _or: [card_subtype_name_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "card_subtype_name"
"""
enum card_subtype_name_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_subtype_name_pkey
}

"""
input type for inserting data into table "card_subtype_name"
"""
input card_subtype_name_insert_input {
  code: String
  locale: String
  name: String
}

"""aggregate max on columns"""
type card_subtype_name_max_fields {
  code: String
  locale: String
  name: String
}

"""aggregate min on columns"""
type card_subtype_name_min_fields {
  code: String
  locale: String
  name: String
}

"""
response of any mutation on the table "card_subtype_name"
"""
type card_subtype_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_subtype_name!]!
}

"""
on_conflict condition type for table "card_subtype_name"
"""
input card_subtype_name_on_conflict {
  constraint: card_subtype_name_constraint!
  update_columns: [card_subtype_name_update_column!]! = []
  where: card_subtype_name_bool_exp
}

"""Ordering options when selecting data from "card_subtype_name"."""
input card_subtype_name_order_by {
  code: order_by
  locale: order_by
  name: order_by
}

"""primary key columns input for table: card_subtype_name"""
input card_subtype_name_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "card_subtype_name"
"""
enum card_subtype_name_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

"""
input type for updating data in table "card_subtype_name"
"""
input card_subtype_name_set_input {
  code: String
  locale: String
  name: String
}

"""
Streaming cursor of the table "card_subtype_name"
"""
input card_subtype_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_subtype_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_subtype_name_stream_cursor_value_input {
  code: String
  locale: String
  name: String
}

"""
update columns of table "card_subtype_name"
"""
enum card_subtype_name_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

input card_subtype_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: card_subtype_name_set_input

  """filter the rows which have to be updated"""
  where: card_subtype_name_bool_exp!
}

"""aggregate sum on columns"""
type card_sum_fields {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  victory: Int
}

"""
columns and relationships of "card_text"
"""
type card_text {
  back_flavor: String
  back_name: String
  back_text: String
  code: String!
  encounter_name: String
  flavor: String
  locale: String!
  name: String!
  slot: String
  subname: String
  text: String
  traits: String
}

"""
aggregated selection of "card_text"
"""
type card_text_aggregate {
  aggregate: card_text_aggregate_fields
  nodes: [card_text!]!
}

input card_text_aggregate_bool_exp {
  count: card_text_aggregate_bool_exp_count
}

input card_text_aggregate_bool_exp_count {
  arguments: [card_text_select_column!]
  distinct: Boolean
  filter: card_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "card_text"
"""
type card_text_aggregate_fields {
  count(columns: [card_text_select_column!], distinct: Boolean): Int!
  max: card_text_max_fields
  min: card_text_min_fields
}

"""
order by aggregate values of table "card_text"
"""
input card_text_aggregate_order_by {
  count: order_by
  max: card_text_max_order_by
  min: card_text_min_order_by
}

"""
input type for inserting array relation for remote table "card_text"
"""
input card_text_arr_rel_insert_input {
  data: [card_text_insert_input!]!

  """upsert condition"""
  on_conflict: card_text_on_conflict
}

"""
Boolean expression to filter rows from the table "card_text". All fields are combined with a logical 'AND'.
"""
input card_text_bool_exp {
  _and: [card_text_bool_exp!]
  _not: card_text_bool_exp
  _or: [card_text_bool_exp!]
  back_flavor: String_comparison_exp
  back_name: String_comparison_exp
  back_text: String_comparison_exp
  code: String_comparison_exp
  encounter_name: String_comparison_exp
  flavor: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  slot: String_comparison_exp
  subname: String_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
}

"""
unique or primary key constraints on table "card_text"
"""
enum card_text_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_text_code_locale_key

  """
  unique or primary key constraint on columns "locale", "code"
  """
  card_text_pkey
}

"""
input type for inserting data into table "card_text"
"""
input card_text_insert_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""aggregate max on columns"""
type card_text_max_fields {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
order by max() on columns of table "card_text"
"""
input card_text_max_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""aggregate min on columns"""
type card_text_min_fields {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
order by min() on columns of table "card_text"
"""
input card_text_min_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""
response of any mutation on the table "card_text"
"""
type card_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_text!]!
}

"""
on_conflict condition type for table "card_text"
"""
input card_text_on_conflict {
  constraint: card_text_constraint!
  update_columns: [card_text_update_column!]! = []
  where: card_text_bool_exp
}

"""Ordering options when selecting data from "card_text"."""
input card_text_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""primary key columns input for table: card_text"""
input card_text_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "card_text"
"""
enum card_text_select_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  code

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  text

  """column name"""
  traits
}

"""
input type for updating data in table "card_text"
"""
input card_text_set_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
Streaming cursor of the table "card_text"
"""
input card_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_text_stream_cursor_value_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
update columns of table "card_text"
"""
enum card_text_update_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  code

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  text

  """column name"""
  traits
}

input card_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: card_text_set_input

  """filter the rows which have to be updated"""
  where: card_text_bool_exp!
}

"""
columns and relationships of "card_type_code"
"""
type card_type_code {
  code: String!
}

"""
aggregated selection of "card_type_code"
"""
type card_type_code_aggregate {
  aggregate: card_type_code_aggregate_fields
  nodes: [card_type_code!]!
}

"""
aggregate fields of "card_type_code"
"""
type card_type_code_aggregate_fields {
  count(columns: [card_type_code_select_column!], distinct: Boolean): Int!
  max: card_type_code_max_fields
  min: card_type_code_min_fields
}

"""
Boolean expression to filter rows from the table "card_type_code". All fields are combined with a logical 'AND'.
"""
input card_type_code_bool_exp {
  _and: [card_type_code_bool_exp!]
  _not: card_type_code_bool_exp
  _or: [card_type_code_bool_exp!]
  code: String_comparison_exp
}

"""
unique or primary key constraints on table "card_type_code"
"""
enum card_type_code_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  card_type_code_pkey
}

enum card_type_code_enum {
  act
  agenda
  asset
  enemy
  enemy_location
  event
  investigator
  key
  location
  scenario
  skill
  story
  treachery
}

"""
Boolean expression to compare columns of type "card_type_code_enum". All fields are combined with logical 'AND'.
"""
input card_type_code_enum_comparison_exp {
  _eq: card_type_code_enum
  _in: [card_type_code_enum!]
  _is_null: Boolean
  _neq: card_type_code_enum
  _nin: [card_type_code_enum!]
}

"""
input type for inserting data into table "card_type_code"
"""
input card_type_code_insert_input {
  code: String
}

"""aggregate max on columns"""
type card_type_code_max_fields {
  code: String
}

"""aggregate min on columns"""
type card_type_code_min_fields {
  code: String
}

"""
response of any mutation on the table "card_type_code"
"""
type card_type_code_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_type_code!]!
}

"""
input type for inserting object relation for remote table "card_type_code"
"""
input card_type_code_obj_rel_insert_input {
  data: card_type_code_insert_input!

  """upsert condition"""
  on_conflict: card_type_code_on_conflict
}

"""
on_conflict condition type for table "card_type_code"
"""
input card_type_code_on_conflict {
  constraint: card_type_code_constraint!
  update_columns: [card_type_code_update_column!]! = []
  where: card_type_code_bool_exp
}

"""Ordering options when selecting data from "card_type_code"."""
input card_type_code_order_by {
  code: order_by
}

"""primary key columns input for table: card_type_code"""
input card_type_code_pk_columns_input {
  code: String!
}

"""
select columns of table "card_type_code"
"""
enum card_type_code_select_column {
  """column name"""
  code
}

"""
input type for updating data in table "card_type_code"
"""
input card_type_code_set_input {
  code: String
}

"""
Streaming cursor of the table "card_type_code"
"""
input card_type_code_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_type_code_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_type_code_stream_cursor_value_input {
  code: String
}

"""
update columns of table "card_type_code"
"""
enum card_type_code_update_column {
  """column name"""
  code
}

input card_type_code_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: card_type_code_set_input

  """filter the rows which have to be updated"""
  where: card_type_code_bool_exp!
}

"""
columns and relationships of "card_type_name"
"""
type card_type_name {
  code: card_type_code_enum!
  locale: String!
  name: String!
}

"""
aggregated selection of "card_type_name"
"""
type card_type_name_aggregate {
  aggregate: card_type_name_aggregate_fields
  nodes: [card_type_name!]!
}

"""
aggregate fields of "card_type_name"
"""
type card_type_name_aggregate_fields {
  count(columns: [card_type_name_select_column!], distinct: Boolean): Int!
  max: card_type_name_max_fields
  min: card_type_name_min_fields
}

"""
Boolean expression to filter rows from the table "card_type_name". All fields are combined with a logical 'AND'.
"""
input card_type_name_bool_exp {
  _and: [card_type_name_bool_exp!]
  _not: card_type_name_bool_exp
  _or: [card_type_name_bool_exp!]
  code: card_type_code_enum_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "card_type_name"
"""
enum card_type_name_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  type_name_pkey
}

"""
input type for inserting data into table "card_type_name"
"""
input card_type_name_insert_input {
  code: card_type_code_enum
  locale: String
  name: String
}

"""aggregate max on columns"""
type card_type_name_max_fields {
  locale: String
  name: String
}

"""aggregate min on columns"""
type card_type_name_min_fields {
  locale: String
  name: String
}

"""
response of any mutation on the table "card_type_name"
"""
type card_type_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [card_type_name!]!
}

"""
on_conflict condition type for table "card_type_name"
"""
input card_type_name_on_conflict {
  constraint: card_type_name_constraint!
  update_columns: [card_type_name_update_column!]! = []
  where: card_type_name_bool_exp
}

"""Ordering options when selecting data from "card_type_name"."""
input card_type_name_order_by {
  code: order_by
  locale: order_by
  name: order_by
}

"""primary key columns input for table: card_type_name"""
input card_type_name_pk_columns_input {
  code: card_type_code_enum!
  locale: String!
}

"""
select columns of table "card_type_name"
"""
enum card_type_name_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

"""
input type for updating data in table "card_type_name"
"""
input card_type_name_set_input {
  code: card_type_code_enum
  locale: String
  name: String
}

"""
Streaming cursor of the table "card_type_name"
"""
input card_type_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: card_type_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input card_type_name_stream_cursor_value_input {
  code: card_type_code_enum
  locale: String
  name: String
}

"""
update columns of table "card_type_name"
"""
enum card_type_name_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

input card_type_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: card_type_name_set_input

  """filter the rows which have to be updated"""
  where: card_type_name_bool_exp!
}

"""
update columns of table "card"
"""
enum card_update_column {
  """column name"""
  back_link

  """column name"""
  clues

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction_code

  """column name"""
  health

  """column name"""
  hidden

  """column name"""
  illustrator

  """column name"""
  is_unique

  """column name"""
  myriad

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  type_code

  """column name"""
  victory
}

input card_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: card_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: card_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: card_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: card_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: card_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: card_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: card_set_input

  """filter the rows which have to be updated"""
  where: card_bool_exp!
}

"""aggregate var_pop on columns"""
type card_var_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""aggregate var_samp on columns"""
type card_var_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""aggregate variance on columns"""
type card_variance_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  victory: Float
}

"""
columns and relationships of "chaos_bag_result"
"""
type chaos_bag_result {
  bless: Int!

  """An object relationship"""
  campaign: campaign!
  created_at: timestamptz!
  curse: Int!
  difficulty: campaign_difficulty_enum
  drawn(
    """JSON select path"""
    path: String
  ): jsonb!
  history(
    """JSON select path"""
    path: String
  ): jsonb!
  id: Int!
  sealed(
    """JSON select path"""
    path: String
  ): jsonb!
  tarot: chaos_bag_tarot_mode_enum

  """An object relationship"""
  tarot_mode: chaos_bag_tarot_mode
  totalDrawn: Int
  updated_at: timestamptz!
}

"""
aggregated selection of "chaos_bag_result"
"""
type chaos_bag_result_aggregate {
  aggregate: chaos_bag_result_aggregate_fields
  nodes: [chaos_bag_result!]!
}

input chaos_bag_result_aggregate_bool_exp {
  count: chaos_bag_result_aggregate_bool_exp_count
}

input chaos_bag_result_aggregate_bool_exp_count {
  arguments: [chaos_bag_result_select_column!]
  distinct: Boolean
  filter: chaos_bag_result_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "chaos_bag_result"
"""
type chaos_bag_result_aggregate_fields {
  avg: chaos_bag_result_avg_fields
  count(columns: [chaos_bag_result_select_column!], distinct: Boolean): Int!
  max: chaos_bag_result_max_fields
  min: chaos_bag_result_min_fields
  stddev: chaos_bag_result_stddev_fields
  stddev_pop: chaos_bag_result_stddev_pop_fields
  stddev_samp: chaos_bag_result_stddev_samp_fields
  sum: chaos_bag_result_sum_fields
  var_pop: chaos_bag_result_var_pop_fields
  var_samp: chaos_bag_result_var_samp_fields
  variance: chaos_bag_result_variance_fields
}

"""
order by aggregate values of table "chaos_bag_result"
"""
input chaos_bag_result_aggregate_order_by {
  avg: chaos_bag_result_avg_order_by
  count: order_by
  max: chaos_bag_result_max_order_by
  min: chaos_bag_result_min_order_by
  stddev: chaos_bag_result_stddev_order_by
  stddev_pop: chaos_bag_result_stddev_pop_order_by
  stddev_samp: chaos_bag_result_stddev_samp_order_by
  sum: chaos_bag_result_sum_order_by
  var_pop: chaos_bag_result_var_pop_order_by
  var_samp: chaos_bag_result_var_samp_order_by
  variance: chaos_bag_result_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input chaos_bag_result_append_input {
  drawn: jsonb
  history: jsonb
  sealed: jsonb
}

"""
input type for inserting array relation for remote table "chaos_bag_result"
"""
input chaos_bag_result_arr_rel_insert_input {
  data: [chaos_bag_result_insert_input!]!

  """upsert condition"""
  on_conflict: chaos_bag_result_on_conflict
}

"""aggregate avg on columns"""
type chaos_bag_result_avg_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by avg() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_avg_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""
Boolean expression to filter rows from the table "chaos_bag_result". All fields are combined with a logical 'AND'.
"""
input chaos_bag_result_bool_exp {
  _and: [chaos_bag_result_bool_exp!]
  _not: chaos_bag_result_bool_exp
  _or: [chaos_bag_result_bool_exp!]
  bless: Int_comparison_exp
  campaign: campaign_bool_exp
  created_at: timestamptz_comparison_exp
  curse: Int_comparison_exp
  difficulty: campaign_difficulty_enum_comparison_exp
  drawn: jsonb_comparison_exp
  history: jsonb_comparison_exp
  id: Int_comparison_exp
  sealed: jsonb_comparison_exp
  tarot: chaos_bag_tarot_mode_enum_comparison_exp
  tarot_mode: chaos_bag_tarot_mode_bool_exp
  totalDrawn: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "chaos_bag_result"
"""
enum chaos_bag_result_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chaos_bag_pkey

  """
  unique or primary key constraint on columns "id"
  """
  chaos_bag_results_campaign_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input chaos_bag_result_delete_at_path_input {
  drawn: [String!]
  history: [String!]
  sealed: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input chaos_bag_result_delete_elem_input {
  drawn: Int
  history: Int
  sealed: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input chaos_bag_result_delete_key_input {
  drawn: String
  history: String
  sealed: String
}

"""
input type for incrementing numeric columns in table "chaos_bag_result"
"""
input chaos_bag_result_inc_input {
  bless: Int
  curse: Int
  id: Int
  totalDrawn: Int
}

"""
input type for inserting data into table "chaos_bag_result"
"""
input chaos_bag_result_insert_input {
  bless: Int
  campaign: campaign_obj_rel_insert_input
  created_at: timestamptz
  curse: Int
  difficulty: campaign_difficulty_enum
  drawn: jsonb
  history: jsonb
  id: Int
  sealed: jsonb
  tarot: chaos_bag_tarot_mode_enum
  tarot_mode: chaos_bag_tarot_mode_obj_rel_insert_input
  totalDrawn: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type chaos_bag_result_max_fields {
  bless: Int
  created_at: timestamptz
  curse: Int
  id: Int
  totalDrawn: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_max_order_by {
  bless: order_by
  created_at: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type chaos_bag_result_min_fields {
  bless: Int
  created_at: timestamptz
  curse: Int
  id: Int
  totalDrawn: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_min_order_by {
  bless: order_by
  created_at: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "chaos_bag_result"
"""
type chaos_bag_result_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chaos_bag_result!]!
}

"""
on_conflict condition type for table "chaos_bag_result"
"""
input chaos_bag_result_on_conflict {
  constraint: chaos_bag_result_constraint!
  update_columns: [chaos_bag_result_update_column!]! = []
  where: chaos_bag_result_bool_exp
}

"""Ordering options when selecting data from "chaos_bag_result"."""
input chaos_bag_result_order_by {
  bless: order_by
  campaign: campaign_order_by
  created_at: order_by
  curse: order_by
  difficulty: order_by
  drawn: order_by
  history: order_by
  id: order_by
  sealed: order_by
  tarot: order_by
  tarot_mode: chaos_bag_tarot_mode_order_by
  totalDrawn: order_by
  updated_at: order_by
}

"""primary key columns input for table: chaos_bag_result"""
input chaos_bag_result_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input chaos_bag_result_prepend_input {
  drawn: jsonb
  history: jsonb
  sealed: jsonb
}

"""
select columns of table "chaos_bag_result"
"""
enum chaos_bag_result_select_column {
  """column name"""
  bless

  """column name"""
  created_at

  """column name"""
  curse

  """column name"""
  difficulty

  """column name"""
  drawn

  """column name"""
  history

  """column name"""
  id

  """column name"""
  sealed

  """column name"""
  tarot

  """column name"""
  totalDrawn

  """column name"""
  updated_at
}

"""
input type for updating data in table "chaos_bag_result"
"""
input chaos_bag_result_set_input {
  bless: Int
  created_at: timestamptz
  curse: Int
  difficulty: campaign_difficulty_enum
  drawn: jsonb
  history: jsonb
  id: Int
  sealed: jsonb
  tarot: chaos_bag_tarot_mode_enum
  totalDrawn: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type chaos_bag_result_stddev_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by stddev() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_stddev_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""aggregate stddev_pop on columns"""
type chaos_bag_result_stddev_pop_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by stddev_pop() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_stddev_pop_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""aggregate stddev_samp on columns"""
type chaos_bag_result_stddev_samp_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by stddev_samp() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_stddev_samp_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""
Streaming cursor of the table "chaos_bag_result"
"""
input chaos_bag_result_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chaos_bag_result_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chaos_bag_result_stream_cursor_value_input {
  bless: Int
  created_at: timestamptz
  curse: Int
  difficulty: campaign_difficulty_enum
  drawn: jsonb
  history: jsonb
  id: Int
  sealed: jsonb
  tarot: chaos_bag_tarot_mode_enum
  totalDrawn: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type chaos_bag_result_sum_fields {
  bless: Int
  curse: Int
  id: Int
  totalDrawn: Int
}

"""
order by sum() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_sum_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""
update columns of table "chaos_bag_result"
"""
enum chaos_bag_result_update_column {
  """column name"""
  bless

  """column name"""
  created_at

  """column name"""
  curse

  """column name"""
  difficulty

  """column name"""
  drawn

  """column name"""
  history

  """column name"""
  id

  """column name"""
  sealed

  """column name"""
  tarot

  """column name"""
  totalDrawn

  """column name"""
  updated_at
}

input chaos_bag_result_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: chaos_bag_result_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: chaos_bag_result_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: chaos_bag_result_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: chaos_bag_result_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: chaos_bag_result_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: chaos_bag_result_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: chaos_bag_result_set_input

  """filter the rows which have to be updated"""
  where: chaos_bag_result_bool_exp!
}

"""aggregate var_pop on columns"""
type chaos_bag_result_var_pop_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by var_pop() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_var_pop_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""aggregate var_samp on columns"""
type chaos_bag_result_var_samp_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by var_samp() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_var_samp_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""aggregate variance on columns"""
type chaos_bag_result_variance_fields {
  bless: Float
  curse: Float
  id: Float
  totalDrawn: Float
}

"""
order by variance() on columns of table "chaos_bag_result"
"""
input chaos_bag_result_variance_order_by {
  bless: order_by
  curse: order_by
  id: order_by
  totalDrawn: order_by
}

"""
columns and relationships of "chaos_bag_tarot_mode"
"""
type chaos_bag_tarot_mode {
  value: String!
}

"""
aggregated selection of "chaos_bag_tarot_mode"
"""
type chaos_bag_tarot_mode_aggregate {
  aggregate: chaos_bag_tarot_mode_aggregate_fields
  nodes: [chaos_bag_tarot_mode!]!
}

"""
aggregate fields of "chaos_bag_tarot_mode"
"""
type chaos_bag_tarot_mode_aggregate_fields {
  count(columns: [chaos_bag_tarot_mode_select_column!], distinct: Boolean): Int!
  max: chaos_bag_tarot_mode_max_fields
  min: chaos_bag_tarot_mode_min_fields
}

"""
Boolean expression to filter rows from the table "chaos_bag_tarot_mode". All fields are combined with a logical 'AND'.
"""
input chaos_bag_tarot_mode_bool_exp {
  _and: [chaos_bag_tarot_mode_bool_exp!]
  _not: chaos_bag_tarot_mode_bool_exp
  _or: [chaos_bag_tarot_mode_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "chaos_bag_tarot_mode"
"""
enum chaos_bag_tarot_mode_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  chaos_bag_tarot_mode_pkey
}

enum chaos_bag_tarot_mode_enum {
  judgement
  judgement_inverted
}

"""
Boolean expression to compare columns of type "chaos_bag_tarot_mode_enum". All fields are combined with logical 'AND'.
"""
input chaos_bag_tarot_mode_enum_comparison_exp {
  _eq: chaos_bag_tarot_mode_enum
  _in: [chaos_bag_tarot_mode_enum!]
  _is_null: Boolean
  _neq: chaos_bag_tarot_mode_enum
  _nin: [chaos_bag_tarot_mode_enum!]
}

"""
input type for inserting data into table "chaos_bag_tarot_mode"
"""
input chaos_bag_tarot_mode_insert_input {
  value: String
}

"""aggregate max on columns"""
type chaos_bag_tarot_mode_max_fields {
  value: String
}

"""aggregate min on columns"""
type chaos_bag_tarot_mode_min_fields {
  value: String
}

"""
response of any mutation on the table "chaos_bag_tarot_mode"
"""
type chaos_bag_tarot_mode_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chaos_bag_tarot_mode!]!
}

"""
input type for inserting object relation for remote table "chaos_bag_tarot_mode"
"""
input chaos_bag_tarot_mode_obj_rel_insert_input {
  data: chaos_bag_tarot_mode_insert_input!

  """upsert condition"""
  on_conflict: chaos_bag_tarot_mode_on_conflict
}

"""
on_conflict condition type for table "chaos_bag_tarot_mode"
"""
input chaos_bag_tarot_mode_on_conflict {
  constraint: chaos_bag_tarot_mode_constraint!
  update_columns: [chaos_bag_tarot_mode_update_column!]! = []
  where: chaos_bag_tarot_mode_bool_exp
}

"""Ordering options when selecting data from "chaos_bag_tarot_mode"."""
input chaos_bag_tarot_mode_order_by {
  value: order_by
}

"""primary key columns input for table: chaos_bag_tarot_mode"""
input chaos_bag_tarot_mode_pk_columns_input {
  value: String!
}

"""
select columns of table "chaos_bag_tarot_mode"
"""
enum chaos_bag_tarot_mode_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "chaos_bag_tarot_mode"
"""
input chaos_bag_tarot_mode_set_input {
  value: String
}

"""
Streaming cursor of the table "chaos_bag_tarot_mode"
"""
input chaos_bag_tarot_mode_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chaos_bag_tarot_mode_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chaos_bag_tarot_mode_stream_cursor_value_input {
  value: String
}

"""
update columns of table "chaos_bag_tarot_mode"
"""
enum chaos_bag_tarot_mode_update_column {
  """column name"""
  value
}

input chaos_bag_tarot_mode_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: chaos_bag_tarot_mode_set_input

  """filter the rows which have to be updated"""
  where: chaos_bag_tarot_mode_bool_exp!
}

"""
columns and relationships of "conquest.card"
"""
type conquest_card {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  deck_rules(
    """JSON select path"""
    path: String
  ): jsonb
  faction_id: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String!
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String!
  pack_id: String!
  position: Int!
  preparation: Boolean!
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String!
  unique: Boolean!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.card"
"""
type conquest_card_aggregate {
  aggregate: conquest_card_aggregate_fields
  nodes: [conquest_card!]!
}

"""
aggregate fields of "conquest.card"
"""
type conquest_card_aggregate_fields {
  avg: conquest_card_avg_fields
  count(columns: [conquest_card_select_column!], distinct: Boolean): Int!
  max: conquest_card_max_fields
  min: conquest_card_min_fields
  stddev: conquest_card_stddev_fields
  stddev_pop: conquest_card_stddev_pop_fields
  stddev_samp: conquest_card_stddev_samp_fields
  sum: conquest_card_sum_fields
  var_pop: conquest_card_var_pop_fields
  var_samp: conquest_card_var_samp_fields
  variance: conquest_card_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input conquest_card_append_input {
  deck_rules: jsonb
}

"""aggregate avg on columns"""
type conquest_card_avg_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""
Boolean expression to filter rows from the table "conquest.card". All fields are combined with a logical 'AND'.
"""
input conquest_card_bool_exp {
  _and: [conquest_card_bool_exp!]
  _not: conquest_card_bool_exp
  _or: [conquest_card_bool_exp!]
  attack: Int_comparison_exp
  back_attack: Int_comparison_exp
  back_card_id: String_comparison_exp
  back_flavor: String_comparison_exp
  back_health: Int_comparison_exp
  back_imagesrc: String_comparison_exp
  back_text: String_comparison_exp
  back_traits: String_comparison_exp
  back_tts_sheet_url: String_comparison_exp
  command_hammers: Int_comparison_exp
  cost: Int_comparison_exp
  deck_rules: jsonb_comparison_exp
  faction_id: String_comparison_exp
  flavor: String_comparison_exp
  health: Int_comparison_exp
  horizontal: Boolean_comparison_exp
  id: String_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  keywords: String_comparison_exp
  loyalty_id: String_comparison_exp
  name: String_comparison_exp
  pack_id: String_comparison_exp
  position: Int_comparison_exp
  preparation: Boolean_comparison_exp
  quantity: Int_comparison_exp
  shields: Int_comparison_exp
  signature_id: Int_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
  tts_sheet_position: Int_comparison_exp
  tts_sheet_url: String_comparison_exp
  type_id: String_comparison_exp
  unique: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.card"
"""
enum conquest_card_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  card_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input conquest_card_delete_at_path_input {
  deck_rules: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input conquest_card_delete_elem_input {
  deck_rules: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input conquest_card_delete_key_input {
  deck_rules: String
}

"""
input type for incrementing numeric columns in table "conquest.card"
"""
input conquest_card_inc_input {
  attack: Int
  back_attack: Int
  back_health: Int
  command_hammers: Int
  cost: Int
  health: Int
  position: Int
  quantity: Int
  shields: Int
  signature_id: Int
  tts_sheet_position: Int
}

"""
input type for inserting data into table "conquest.card"
"""
input conquest_card_insert_input {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  deck_rules: jsonb
  faction_id: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String
  pack_id: String
  position: Int
  preparation: Boolean
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  unique: Boolean
  updated_at: timestamptz
}

"""
columns and relationships of "conquest.card_localized"
"""
type conquest_card_localized {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  command_hammers: Int
  cost: Int
  deck_rules(
    """JSON select path"""
    path: String
  ): jsonb
  faction_id: String
  faction_name: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  locale: String
  loyalty_id: String
  loyalty_name: String
  name: String
  pack_cycle_id: String
  pack_cycle_name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  position: Int
  preparation: Boolean
  quantity: Int
  real_back_flavor: String
  real_back_imagesrc: String
  real_back_text: String
  real_back_traits: String
  real_flavor: String
  real_imagesrc: String
  real_keywords: String
  real_name: String
  real_text: String
  real_traits: String
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  type_name: String
  unique: Boolean
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.card_localized"
"""
type conquest_card_localized_aggregate {
  aggregate: conquest_card_localized_aggregate_fields
  nodes: [conquest_card_localized!]!
}

"""
aggregate fields of "conquest.card_localized"
"""
type conquest_card_localized_aggregate_fields {
  avg: conquest_card_localized_avg_fields
  count(columns: [conquest_card_localized_select_column!], distinct: Boolean): Int!
  max: conquest_card_localized_max_fields
  min: conquest_card_localized_min_fields
  stddev: conquest_card_localized_stddev_fields
  stddev_pop: conquest_card_localized_stddev_pop_fields
  stddev_samp: conquest_card_localized_stddev_samp_fields
  sum: conquest_card_localized_sum_fields
  var_pop: conquest_card_localized_var_pop_fields
  var_samp: conquest_card_localized_var_samp_fields
  variance: conquest_card_localized_variance_fields
}

"""aggregate avg on columns"""
type conquest_card_localized_avg_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""
Boolean expression to filter rows from the table "conquest.card_localized". All fields are combined with a logical 'AND'.
"""
input conquest_card_localized_bool_exp {
  _and: [conquest_card_localized_bool_exp!]
  _not: conquest_card_localized_bool_exp
  _or: [conquest_card_localized_bool_exp!]
  attack: Int_comparison_exp
  back_attack: Int_comparison_exp
  back_card_id: String_comparison_exp
  back_flavor: String_comparison_exp
  back_health: Int_comparison_exp
  back_imagesrc: String_comparison_exp
  back_text: String_comparison_exp
  back_traits: String_comparison_exp
  command_hammers: Int_comparison_exp
  cost: Int_comparison_exp
  deck_rules: jsonb_comparison_exp
  faction_id: String_comparison_exp
  faction_name: String_comparison_exp
  flavor: String_comparison_exp
  health: Int_comparison_exp
  horizontal: Boolean_comparison_exp
  id: String_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  keywords: String_comparison_exp
  locale: String_comparison_exp
  loyalty_id: String_comparison_exp
  loyalty_name: String_comparison_exp
  name: String_comparison_exp
  pack_cycle_id: String_comparison_exp
  pack_cycle_name: String_comparison_exp
  pack_id: String_comparison_exp
  pack_name: String_comparison_exp
  pack_position: Int_comparison_exp
  position: Int_comparison_exp
  preparation: Boolean_comparison_exp
  quantity: Int_comparison_exp
  real_back_flavor: String_comparison_exp
  real_back_imagesrc: String_comparison_exp
  real_back_text: String_comparison_exp
  real_back_traits: String_comparison_exp
  real_flavor: String_comparison_exp
  real_imagesrc: String_comparison_exp
  real_keywords: String_comparison_exp
  real_name: String_comparison_exp
  real_text: String_comparison_exp
  real_traits: String_comparison_exp
  shields: Int_comparison_exp
  signature_id: Int_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
  tts_sheet_position: Int_comparison_exp
  tts_sheet_url: String_comparison_exp
  type_id: String_comparison_exp
  type_name: String_comparison_exp
  unique: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type conquest_card_localized_max_fields {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  command_hammers: Int
  cost: Int
  faction_id: String
  faction_name: String
  flavor: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  locale: String
  loyalty_id: String
  loyalty_name: String
  name: String
  pack_cycle_id: String
  pack_cycle_name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_imagesrc: String
  real_back_text: String
  real_back_traits: String
  real_flavor: String
  real_imagesrc: String
  real_keywords: String
  real_name: String
  real_text: String
  real_traits: String
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_card_localized_min_fields {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  command_hammers: Int
  cost: Int
  faction_id: String
  faction_name: String
  flavor: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  locale: String
  loyalty_id: String
  loyalty_name: String
  name: String
  pack_cycle_id: String
  pack_cycle_name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_imagesrc: String
  real_back_text: String
  real_back_traits: String
  real_flavor: String
  real_imagesrc: String
  real_keywords: String
  real_name: String
  real_text: String
  real_traits: String
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "conquest.card_localized"."""
input conquest_card_localized_order_by {
  attack: order_by
  back_attack: order_by
  back_card_id: order_by
  back_flavor: order_by
  back_health: order_by
  back_imagesrc: order_by
  back_text: order_by
  back_traits: order_by
  command_hammers: order_by
  cost: order_by
  deck_rules: order_by
  faction_id: order_by
  faction_name: order_by
  flavor: order_by
  health: order_by
  horizontal: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  keywords: order_by
  locale: order_by
  loyalty_id: order_by
  loyalty_name: order_by
  name: order_by
  pack_cycle_id: order_by
  pack_cycle_name: order_by
  pack_id: order_by
  pack_name: order_by
  pack_position: order_by
  position: order_by
  preparation: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_imagesrc: order_by
  real_back_text: order_by
  real_back_traits: order_by
  real_flavor: order_by
  real_imagesrc: order_by
  real_keywords: order_by
  real_name: order_by
  real_text: order_by
  real_traits: order_by
  shields: order_by
  signature_id: order_by
  text: order_by
  traits: order_by
  tts_sheet_position: order_by
  tts_sheet_url: order_by
  type_id: order_by
  type_name: order_by
  unique: order_by
  updated_at: order_by
}

"""
select columns of table "conquest.card_localized"
"""
enum conquest_card_localized_select_column {
  """column name"""
  attack

  """column name"""
  back_attack

  """column name"""
  back_card_id

  """column name"""
  back_flavor

  """column name"""
  back_health

  """column name"""
  back_imagesrc

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  command_hammers

  """column name"""
  cost

  """column name"""
  deck_rules

  """column name"""
  faction_id

  """column name"""
  faction_name

  """column name"""
  flavor

  """column name"""
  health

  """column name"""
  horizontal

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  keywords

  """column name"""
  locale

  """column name"""
  loyalty_id

  """column name"""
  loyalty_name

  """column name"""
  name

  """column name"""
  pack_cycle_id

  """column name"""
  pack_cycle_name

  """column name"""
  pack_id

  """column name"""
  pack_name

  """column name"""
  pack_position

  """column name"""
  position

  """column name"""
  preparation

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_imagesrc

  """column name"""
  real_back_text

  """column name"""
  real_back_traits

  """column name"""
  real_flavor

  """column name"""
  real_imagesrc

  """column name"""
  real_keywords

  """column name"""
  real_name

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  shields

  """column name"""
  signature_id

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  tts_sheet_position

  """column name"""
  tts_sheet_url

  """column name"""
  type_id

  """column name"""
  type_name

  """column name"""
  unique

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type conquest_card_localized_stddev_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate stddev_pop on columns"""
type conquest_card_localized_stddev_pop_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate stddev_samp on columns"""
type conquest_card_localized_stddev_samp_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""
Streaming cursor of the table "conquest_card_localized"
"""
input conquest_card_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_card_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_card_localized_stream_cursor_value_input {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  command_hammers: Int
  cost: Int
  deck_rules: jsonb
  faction_id: String
  faction_name: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  locale: String
  loyalty_id: String
  loyalty_name: String
  name: String
  pack_cycle_id: String
  pack_cycle_name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  position: Int
  preparation: Boolean
  quantity: Int
  real_back_flavor: String
  real_back_imagesrc: String
  real_back_text: String
  real_back_traits: String
  real_flavor: String
  real_imagesrc: String
  real_keywords: String
  real_name: String
  real_text: String
  real_traits: String
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  type_name: String
  unique: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type conquest_card_localized_sum_fields {
  attack: Int
  back_attack: Int
  back_health: Int
  command_hammers: Int
  cost: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  shields: Int
  signature_id: Int
  tts_sheet_position: Int
}

"""aggregate var_pop on columns"""
type conquest_card_localized_var_pop_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate var_samp on columns"""
type conquest_card_localized_var_samp_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate variance on columns"""
type conquest_card_localized_variance_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate max on columns"""
type conquest_card_max_fields {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  faction_id: String
  flavor: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String
  pack_id: String
  position: Int
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_card_min_fields {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  faction_id: String
  flavor: String
  health: Int
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String
  pack_id: String
  position: Int
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.card"
"""
type conquest_card_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_card!]!
}

"""
on_conflict condition type for table "conquest.card"
"""
input conquest_card_on_conflict {
  constraint: conquest_card_constraint!
  update_columns: [conquest_card_update_column!]! = []
  where: conquest_card_bool_exp
}

"""Ordering options when selecting data from "conquest.card"."""
input conquest_card_order_by {
  attack: order_by
  back_attack: order_by
  back_card_id: order_by
  back_flavor: order_by
  back_health: order_by
  back_imagesrc: order_by
  back_text: order_by
  back_traits: order_by
  back_tts_sheet_url: order_by
  command_hammers: order_by
  cost: order_by
  deck_rules: order_by
  faction_id: order_by
  flavor: order_by
  health: order_by
  horizontal: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  keywords: order_by
  loyalty_id: order_by
  name: order_by
  pack_id: order_by
  position: order_by
  preparation: order_by
  quantity: order_by
  shields: order_by
  signature_id: order_by
  text: order_by
  traits: order_by
  tts_sheet_position: order_by
  tts_sheet_url: order_by
  type_id: order_by
  unique: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.card"""
input conquest_card_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input conquest_card_prepend_input {
  deck_rules: jsonb
}

"""
select columns of table "conquest.card"
"""
enum conquest_card_select_column {
  """column name"""
  attack

  """column name"""
  back_attack

  """column name"""
  back_card_id

  """column name"""
  back_flavor

  """column name"""
  back_health

  """column name"""
  back_imagesrc

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  back_tts_sheet_url

  """column name"""
  command_hammers

  """column name"""
  cost

  """column name"""
  deck_rules

  """column name"""
  faction_id

  """column name"""
  flavor

  """column name"""
  health

  """column name"""
  horizontal

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  keywords

  """column name"""
  loyalty_id

  """column name"""
  name

  """column name"""
  pack_id

  """column name"""
  position

  """column name"""
  preparation

  """column name"""
  quantity

  """column name"""
  shields

  """column name"""
  signature_id

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  tts_sheet_position

  """column name"""
  tts_sheet_url

  """column name"""
  type_id

  """column name"""
  unique

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.card"
"""
input conquest_card_set_input {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  deck_rules: jsonb
  faction_id: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String
  pack_id: String
  position: Int
  preparation: Boolean
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  unique: Boolean
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type conquest_card_stddev_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate stddev_pop on columns"""
type conquest_card_stddev_pop_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate stddev_samp on columns"""
type conquest_card_stddev_samp_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""
Streaming cursor of the table "conquest_card"
"""
input conquest_card_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_card_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_card_stream_cursor_value_input {
  attack: Int
  back_attack: Int
  back_card_id: String
  back_flavor: String
  back_health: Int
  back_imagesrc: String
  back_text: String
  back_traits: String
  back_tts_sheet_url: String
  command_hammers: Int
  cost: Int
  deck_rules: jsonb
  faction_id: String
  flavor: String
  health: Int
  horizontal: Boolean
  id: String
  illustrator: String
  imagesrc: String
  keywords: String
  loyalty_id: String
  name: String
  pack_id: String
  position: Int
  preparation: Boolean
  quantity: Int
  shields: Int
  signature_id: Int
  text: String
  traits: String
  tts_sheet_position: Int
  tts_sheet_url: String
  type_id: String
  unique: Boolean
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type conquest_card_sum_fields {
  attack: Int
  back_attack: Int
  back_health: Int
  command_hammers: Int
  cost: Int
  health: Int
  position: Int
  quantity: Int
  shields: Int
  signature_id: Int
  tts_sheet_position: Int
}

"""
columns and relationships of "conquest.card_text"
"""
type conquest_card_text {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String!
  imagesrc: String
  keywords: String
  locale: String!
  name: String!
  text: String
  traits: String
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.card_text"
"""
type conquest_card_text_aggregate {
  aggregate: conquest_card_text_aggregate_fields
  nodes: [conquest_card_text!]!
}

"""
aggregate fields of "conquest.card_text"
"""
type conquest_card_text_aggregate_fields {
  count(columns: [conquest_card_text_select_column!], distinct: Boolean): Int!
  max: conquest_card_text_max_fields
  min: conquest_card_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.card_text". All fields are combined with a logical 'AND'.
"""
input conquest_card_text_bool_exp {
  _and: [conquest_card_text_bool_exp!]
  _not: conquest_card_text_bool_exp
  _or: [conquest_card_text_bool_exp!]
  back_flavor: String_comparison_exp
  back_imagesrc: String_comparison_exp
  back_text: String_comparison_exp
  back_traits: String_comparison_exp
  flavor: String_comparison_exp
  id: String_comparison_exp
  imagesrc: String_comparison_exp
  keywords: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.card_text"
"""
enum conquest_card_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  card_text_pkey
}

"""
input type for inserting data into table "conquest.card_text"
"""
input conquest_card_text_insert_input {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String
  imagesrc: String
  keywords: String
  locale: String
  name: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_card_text_max_fields {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String
  imagesrc: String
  keywords: String
  locale: String
  name: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_card_text_min_fields {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String
  imagesrc: String
  keywords: String
  locale: String
  name: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.card_text"
"""
type conquest_card_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_card_text!]!
}

"""
on_conflict condition type for table "conquest.card_text"
"""
input conquest_card_text_on_conflict {
  constraint: conquest_card_text_constraint!
  update_columns: [conquest_card_text_update_column!]! = []
  where: conquest_card_text_bool_exp
}

"""Ordering options when selecting data from "conquest.card_text"."""
input conquest_card_text_order_by {
  back_flavor: order_by
  back_imagesrc: order_by
  back_text: order_by
  back_traits: order_by
  flavor: order_by
  id: order_by
  imagesrc: order_by
  keywords: order_by
  locale: order_by
  name: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.card_text"""
input conquest_card_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.card_text"
"""
enum conquest_card_text_select_column {
  """column name"""
  back_flavor

  """column name"""
  back_imagesrc

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imagesrc

  """column name"""
  keywords

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.card_text"
"""
input conquest_card_text_set_input {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String
  imagesrc: String
  keywords: String
  locale: String
  name: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_card_text"
"""
input conquest_card_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_card_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_card_text_stream_cursor_value_input {
  back_flavor: String
  back_imagesrc: String
  back_text: String
  back_traits: String
  flavor: String
  id: String
  imagesrc: String
  keywords: String
  locale: String
  name: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.card_text"
"""
enum conquest_card_text_update_column {
  """column name"""
  back_flavor

  """column name"""
  back_imagesrc

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imagesrc

  """column name"""
  keywords

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

input conquest_card_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_card_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_card_text_bool_exp!
}

"""
update columns of table "conquest.card"
"""
enum conquest_card_update_column {
  """column name"""
  attack

  """column name"""
  back_attack

  """column name"""
  back_card_id

  """column name"""
  back_flavor

  """column name"""
  back_health

  """column name"""
  back_imagesrc

  """column name"""
  back_text

  """column name"""
  back_traits

  """column name"""
  back_tts_sheet_url

  """column name"""
  command_hammers

  """column name"""
  cost

  """column name"""
  deck_rules

  """column name"""
  faction_id

  """column name"""
  flavor

  """column name"""
  health

  """column name"""
  horizontal

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  keywords

  """column name"""
  loyalty_id

  """column name"""
  name

  """column name"""
  pack_id

  """column name"""
  position

  """column name"""
  preparation

  """column name"""
  quantity

  """column name"""
  shields

  """column name"""
  signature_id

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  tts_sheet_position

  """column name"""
  tts_sheet_url

  """column name"""
  type_id

  """column name"""
  unique

  """column name"""
  updated_at
}

"""
columns and relationships of "conquest.card_updated"
"""
type conquest_card_updated {
  locale: String
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.card_updated"
"""
type conquest_card_updated_aggregate {
  aggregate: conquest_card_updated_aggregate_fields
  nodes: [conquest_card_updated!]!
}

"""
aggregate fields of "conquest.card_updated"
"""
type conquest_card_updated_aggregate_fields {
  count(columns: [conquest_card_updated_select_column!], distinct: Boolean): Int!
  max: conquest_card_updated_max_fields
  min: conquest_card_updated_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.card_updated". All fields are combined with a logical 'AND'.
"""
input conquest_card_updated_bool_exp {
  _and: [conquest_card_updated_bool_exp!]
  _not: conquest_card_updated_bool_exp
  _or: [conquest_card_updated_bool_exp!]
  locale: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type conquest_card_updated_max_fields {
  locale: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_card_updated_min_fields {
  locale: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "conquest.card_updated"."""
input conquest_card_updated_order_by {
  locale: order_by
  updated_at: order_by
}

"""
select columns of table "conquest.card_updated"
"""
enum conquest_card_updated_select_column {
  """column name"""
  locale

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "conquest_card_updated"
"""
input conquest_card_updated_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_card_updated_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_card_updated_stream_cursor_value_input {
  locale: String
  updated_at: timestamptz
}

input conquest_card_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: conquest_card_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: conquest_card_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: conquest_card_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: conquest_card_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_card_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: conquest_card_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_card_set_input

  """filter the rows which have to be updated"""
  where: conquest_card_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_card_var_pop_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate var_samp on columns"""
type conquest_card_var_samp_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""aggregate variance on columns"""
type conquest_card_variance_fields {
  attack: Float
  back_attack: Float
  back_health: Float
  command_hammers: Float
  cost: Float
  health: Float
  position: Float
  quantity: Float
  shields: Float
  signature_id: Float
  tts_sheet_position: Float
}

"""
columns and relationships of "conquest.comment"
"""
type conquest_comment {
  comment_id: uuid
  created_at: timestamptz!

  """An object relationship"""
  deck: conquest_deck
  deck_id: Int
  id: uuid!
  response_count: Int!

  """An array relationship"""
  responses(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): [conquest_comment!]!

  """An aggregate relationship"""
  responses_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): conquest_comment_aggregate!
  text: String
  updated_at: timestamptz!

  """An object relationship"""
  user: conquest_users!
  user_id: String!
}

"""
aggregated selection of "conquest.comment"
"""
type conquest_comment_aggregate {
  aggregate: conquest_comment_aggregate_fields
  nodes: [conquest_comment!]!
}

input conquest_comment_aggregate_bool_exp {
  count: conquest_comment_aggregate_bool_exp_count
}

input conquest_comment_aggregate_bool_exp_count {
  arguments: [conquest_comment_select_column!]
  distinct: Boolean
  filter: conquest_comment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "conquest.comment"
"""
type conquest_comment_aggregate_fields {
  avg: conquest_comment_avg_fields
  count(columns: [conquest_comment_select_column!], distinct: Boolean): Int!
  max: conquest_comment_max_fields
  min: conquest_comment_min_fields
  stddev: conquest_comment_stddev_fields
  stddev_pop: conquest_comment_stddev_pop_fields
  stddev_samp: conquest_comment_stddev_samp_fields
  sum: conquest_comment_sum_fields
  var_pop: conquest_comment_var_pop_fields
  var_samp: conquest_comment_var_samp_fields
  variance: conquest_comment_variance_fields
}

"""
order by aggregate values of table "conquest.comment"
"""
input conquest_comment_aggregate_order_by {
  avg: conquest_comment_avg_order_by
  count: order_by
  max: conquest_comment_max_order_by
  min: conquest_comment_min_order_by
  stddev: conquest_comment_stddev_order_by
  stddev_pop: conquest_comment_stddev_pop_order_by
  stddev_samp: conquest_comment_stddev_samp_order_by
  sum: conquest_comment_sum_order_by
  var_pop: conquest_comment_var_pop_order_by
  var_samp: conquest_comment_var_samp_order_by
  variance: conquest_comment_variance_order_by
}

"""
input type for inserting array relation for remote table "conquest.comment"
"""
input conquest_comment_arr_rel_insert_input {
  data: [conquest_comment_insert_input!]!

  """upsert condition"""
  on_conflict: conquest_comment_on_conflict
}

"""aggregate avg on columns"""
type conquest_comment_avg_fields {
  deck_id: Float
  response_count: Float
}

"""
order by avg() on columns of table "conquest.comment"
"""
input conquest_comment_avg_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
Boolean expression to filter rows from the table "conquest.comment". All fields are combined with a logical 'AND'.
"""
input conquest_comment_bool_exp {
  _and: [conquest_comment_bool_exp!]
  _not: conquest_comment_bool_exp
  _or: [conquest_comment_bool_exp!]
  comment_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deck: conquest_deck_bool_exp
  deck_id: Int_comparison_exp
  id: uuid_comparison_exp
  response_count: Int_comparison_exp
  responses: conquest_comment_bool_exp
  responses_aggregate: conquest_comment_aggregate_bool_exp
  text: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: conquest_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.comment"
"""
enum conquest_comment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  comment_pkey
}

"""
input type for incrementing numeric columns in table "conquest.comment"
"""
input conquest_comment_inc_input {
  deck_id: Int
  response_count: Int
}

"""
input type for inserting data into table "conquest.comment"
"""
input conquest_comment_insert_input {
  comment_id: uuid
  created_at: timestamptz
  deck: conquest_deck_obj_rel_insert_input
  deck_id: Int
  id: uuid
  response_count: Int
  responses: conquest_comment_arr_rel_insert_input
  text: String
  updated_at: timestamptz
  user: conquest_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type conquest_comment_max_fields {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "conquest.comment"
"""
input conquest_comment_max_order_by {
  comment_id: order_by
  created_at: order_by
  deck_id: order_by
  id: order_by
  response_count: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type conquest_comment_min_fields {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "conquest.comment"
"""
input conquest_comment_min_order_by {
  comment_id: order_by
  created_at: order_by
  deck_id: order_by
  id: order_by
  response_count: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "conquest.comment"
"""
type conquest_comment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_comment!]!
}

"""
on_conflict condition type for table "conquest.comment"
"""
input conquest_comment_on_conflict {
  constraint: conquest_comment_constraint!
  update_columns: [conquest_comment_update_column!]! = []
  where: conquest_comment_bool_exp
}

"""Ordering options when selecting data from "conquest.comment"."""
input conquest_comment_order_by {
  comment_id: order_by
  created_at: order_by
  deck: conquest_deck_order_by
  deck_id: order_by
  id: order_by
  response_count: order_by
  responses_aggregate: conquest_comment_aggregate_order_by
  text: order_by
  updated_at: order_by
  user: conquest_users_order_by
  user_id: order_by
}

"""primary key columns input for table: conquest.comment"""
input conquest_comment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "conquest.comment"
"""
enum conquest_comment_select_column {
  """column name"""
  comment_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  id

  """column name"""
  response_count

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "conquest.comment"
"""
input conquest_comment_set_input {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type conquest_comment_stddev_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev() on columns of table "conquest.comment"
"""
input conquest_comment_stddev_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate stddev_pop on columns"""
type conquest_comment_stddev_pop_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev_pop() on columns of table "conquest.comment"
"""
input conquest_comment_stddev_pop_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate stddev_samp on columns"""
type conquest_comment_stddev_samp_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev_samp() on columns of table "conquest.comment"
"""
input conquest_comment_stddev_samp_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
Streaming cursor of the table "conquest_comment"
"""
input conquest_comment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_comment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_comment_stream_cursor_value_input {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type conquest_comment_sum_fields {
  deck_id: Int
  response_count: Int
}

"""
order by sum() on columns of table "conquest.comment"
"""
input conquest_comment_sum_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
update columns of table "conquest.comment"
"""
enum conquest_comment_update_column {
  """column name"""
  comment_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  id

  """column name"""
  response_count

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_id
}

input conquest_comment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_comment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_comment_set_input

  """filter the rows which have to be updated"""
  where: conquest_comment_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_comment_var_pop_fields {
  deck_id: Float
  response_count: Float
}

"""
order by var_pop() on columns of table "conquest.comment"
"""
input conquest_comment_var_pop_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate var_samp on columns"""
type conquest_comment_var_samp_fields {
  deck_id: Float
  response_count: Float
}

"""
order by var_samp() on columns of table "conquest.comment"
"""
input conquest_comment_var_samp_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate variance on columns"""
type conquest_comment_variance_fields {
  deck_id: Float
  response_count: Float
}

"""
order by variance() on columns of table "conquest.comment"
"""
input conquest_comment_variance_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
columns and relationships of "conquest.cycle"
"""
type conquest_cycle {
  id: String!
  name: String!
  position: Int!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.cycle"
"""
type conquest_cycle_aggregate {
  aggregate: conquest_cycle_aggregate_fields
  nodes: [conquest_cycle!]!
}

"""
aggregate fields of "conquest.cycle"
"""
type conquest_cycle_aggregate_fields {
  avg: conquest_cycle_avg_fields
  count(columns: [conquest_cycle_select_column!], distinct: Boolean): Int!
  max: conquest_cycle_max_fields
  min: conquest_cycle_min_fields
  stddev: conquest_cycle_stddev_fields
  stddev_pop: conquest_cycle_stddev_pop_fields
  stddev_samp: conquest_cycle_stddev_samp_fields
  sum: conquest_cycle_sum_fields
  var_pop: conquest_cycle_var_pop_fields
  var_samp: conquest_cycle_var_samp_fields
  variance: conquest_cycle_variance_fields
}

"""aggregate avg on columns"""
type conquest_cycle_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "conquest.cycle". All fields are combined with a logical 'AND'.
"""
input conquest_cycle_bool_exp {
  _and: [conquest_cycle_bool_exp!]
  _not: conquest_cycle_bool_exp
  _or: [conquest_cycle_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  position: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.cycle"
"""
enum conquest_cycle_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  cycle_pkey
}

"""
input type for incrementing numeric columns in table "conquest.cycle"
"""
input conquest_cycle_inc_input {
  position: Int
}

"""
input type for inserting data into table "conquest.cycle"
"""
input conquest_cycle_insert_input {
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_cycle_max_fields {
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_cycle_min_fields {
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.cycle"
"""
type conquest_cycle_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_cycle!]!
}

"""
on_conflict condition type for table "conquest.cycle"
"""
input conquest_cycle_on_conflict {
  constraint: conquest_cycle_constraint!
  update_columns: [conquest_cycle_update_column!]! = []
  where: conquest_cycle_bool_exp
}

"""Ordering options when selecting data from "conquest.cycle"."""
input conquest_cycle_order_by {
  id: order_by
  name: order_by
  position: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.cycle"""
input conquest_cycle_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.cycle"
"""
enum conquest_cycle_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.cycle"
"""
input conquest_cycle_set_input {
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type conquest_cycle_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type conquest_cycle_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type conquest_cycle_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "conquest_cycle"
"""
input conquest_cycle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_cycle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_cycle_stream_cursor_value_input {
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type conquest_cycle_sum_fields {
  position: Int
}

"""
columns and relationships of "conquest.cycle_text"
"""
type conquest_cycle_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.cycle_text"
"""
type conquest_cycle_text_aggregate {
  aggregate: conquest_cycle_text_aggregate_fields
  nodes: [conquest_cycle_text!]!
}

"""
aggregate fields of "conquest.cycle_text"
"""
type conquest_cycle_text_aggregate_fields {
  count(columns: [conquest_cycle_text_select_column!], distinct: Boolean): Int!
  max: conquest_cycle_text_max_fields
  min: conquest_cycle_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.cycle_text". All fields are combined with a logical 'AND'.
"""
input conquest_cycle_text_bool_exp {
  _and: [conquest_cycle_text_bool_exp!]
  _not: conquest_cycle_text_bool_exp
  _or: [conquest_cycle_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.cycle_text"
"""
enum conquest_cycle_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  cycle_text_pkey
}

"""
input type for inserting data into table "conquest.cycle_text"
"""
input conquest_cycle_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_cycle_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_cycle_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.cycle_text"
"""
type conquest_cycle_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_cycle_text!]!
}

"""
on_conflict condition type for table "conquest.cycle_text"
"""
input conquest_cycle_text_on_conflict {
  constraint: conquest_cycle_text_constraint!
  update_columns: [conquest_cycle_text_update_column!]! = []
  where: conquest_cycle_text_bool_exp
}

"""Ordering options when selecting data from "conquest.cycle_text"."""
input conquest_cycle_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.cycle_text"""
input conquest_cycle_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.cycle_text"
"""
enum conquest_cycle_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.cycle_text"
"""
input conquest_cycle_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_cycle_text"
"""
input conquest_cycle_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_cycle_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_cycle_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.cycle_text"
"""
enum conquest_cycle_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_cycle_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_cycle_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_cycle_text_bool_exp!
}

"""
update columns of table "conquest.cycle"
"""
enum conquest_cycle_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  updated_at
}

input conquest_cycle_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_cycle_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_cycle_set_input

  """filter the rows which have to be updated"""
  where: conquest_cycle_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_cycle_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type conquest_cycle_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type conquest_cycle_variance_fields {
  position: Float
}

"""
columns and relationships of "conquest.deck"
"""
type conquest_deck {
  comment_count: Int!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): [conquest_comment!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): conquest_comment_aggregate!
  copy_count: Int!
  created_at: timestamptz!
  description: String
  id: Int!
  like_count: Int!

  """
  A computed field, executes function "conquest.deck_liked_by_user"
  """
  liked_by_user: Boolean
  meta(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!

  """An object relationship"""
  original_deck: conquest_deck_copy
  published: Boolean
  side_slots(
    """JSON select path"""
    path: String
  ): jsonb!
  slots(
    """JSON select path"""
    path: String
  ): jsonb!
  tags(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamptz!

  """An object relationship"""
  user: conquest_users!
  user_id: String!
}

"""
aggregated selection of "conquest.deck"
"""
type conquest_deck_aggregate {
  aggregate: conquest_deck_aggregate_fields
  nodes: [conquest_deck!]!
}

"""
aggregate fields of "conquest.deck"
"""
type conquest_deck_aggregate_fields {
  avg: conquest_deck_avg_fields
  count(columns: [conquest_deck_select_column!], distinct: Boolean): Int!
  max: conquest_deck_max_fields
  min: conquest_deck_min_fields
  stddev: conquest_deck_stddev_fields
  stddev_pop: conquest_deck_stddev_pop_fields
  stddev_samp: conquest_deck_stddev_samp_fields
  sum: conquest_deck_sum_fields
  var_pop: conquest_deck_var_pop_fields
  var_samp: conquest_deck_var_samp_fields
  variance: conquest_deck_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input conquest_deck_append_input {
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
}

"""aggregate avg on columns"""
type conquest_deck_avg_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""
Boolean expression to filter rows from the table "conquest.deck". All fields are combined with a logical 'AND'.
"""
input conquest_deck_bool_exp {
  _and: [conquest_deck_bool_exp!]
  _not: conquest_deck_bool_exp
  _or: [conquest_deck_bool_exp!]
  comment_count: Int_comparison_exp
  comments: conquest_comment_bool_exp
  comments_aggregate: conquest_comment_aggregate_bool_exp
  copy_count: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  like_count: Int_comparison_exp
  liked_by_user: Boolean_comparison_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  original_deck: conquest_deck_copy_bool_exp
  published: Boolean_comparison_exp
  side_slots: jsonb_comparison_exp
  slots: jsonb_comparison_exp
  tags: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: conquest_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.deck"
"""
enum conquest_deck_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  deck_pkey
}

"""
columns and relationships of "conquest.deck_copy"
"""
type conquest_deck_copy {
  copy_deck_id: Int!
  created_at: timestamptz!

  """An object relationship"""
  deck: conquest_deck!

  """An object relationship"""
  deck_copy: conquest_deck!
  deck_id: Int!
  updated_at: timestamptz!

  """An object relationship"""
  user: conquest_users!
  user_id: String!
}

"""
aggregated selection of "conquest.deck_copy"
"""
type conquest_deck_copy_aggregate {
  aggregate: conquest_deck_copy_aggregate_fields
  nodes: [conquest_deck_copy!]!
}

"""
aggregate fields of "conquest.deck_copy"
"""
type conquest_deck_copy_aggregate_fields {
  avg: conquest_deck_copy_avg_fields
  count(columns: [conquest_deck_copy_select_column!], distinct: Boolean): Int!
  max: conquest_deck_copy_max_fields
  min: conquest_deck_copy_min_fields
  stddev: conquest_deck_copy_stddev_fields
  stddev_pop: conquest_deck_copy_stddev_pop_fields
  stddev_samp: conquest_deck_copy_stddev_samp_fields
  sum: conquest_deck_copy_sum_fields
  var_pop: conquest_deck_copy_var_pop_fields
  var_samp: conquest_deck_copy_var_samp_fields
  variance: conquest_deck_copy_variance_fields
}

"""aggregate avg on columns"""
type conquest_deck_copy_avg_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
Boolean expression to filter rows from the table "conquest.deck_copy". All fields are combined with a logical 'AND'.
"""
input conquest_deck_copy_bool_exp {
  _and: [conquest_deck_copy_bool_exp!]
  _not: conquest_deck_copy_bool_exp
  _or: [conquest_deck_copy_bool_exp!]
  copy_deck_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deck: conquest_deck_bool_exp
  deck_copy: conquest_deck_bool_exp
  deck_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: conquest_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.deck_copy"
"""
enum conquest_deck_copy_constraint {
  """
  unique or primary key constraint on columns "copy_deck_id"
  """
  deck_copy_pkey
}

"""
input type for incrementing numeric columns in table "conquest.deck_copy"
"""
input conquest_deck_copy_inc_input {
  copy_deck_id: Int
  deck_id: Int
}

"""
input type for inserting data into table "conquest.deck_copy"
"""
input conquest_deck_copy_insert_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck: conquest_deck_obj_rel_insert_input
  deck_copy: conquest_deck_obj_rel_insert_input
  deck_id: Int
  updated_at: timestamptz
  user: conquest_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type conquest_deck_copy_max_fields {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type conquest_deck_copy_min_fields {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "conquest.deck_copy"
"""
type conquest_deck_copy_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_deck_copy!]!
}

"""
input type for inserting object relation for remote table "conquest.deck_copy"
"""
input conquest_deck_copy_obj_rel_insert_input {
  data: conquest_deck_copy_insert_input!

  """upsert condition"""
  on_conflict: conquest_deck_copy_on_conflict
}

"""
on_conflict condition type for table "conquest.deck_copy"
"""
input conquest_deck_copy_on_conflict {
  constraint: conquest_deck_copy_constraint!
  update_columns: [conquest_deck_copy_update_column!]! = []
  where: conquest_deck_copy_bool_exp
}

"""Ordering options when selecting data from "conquest.deck_copy"."""
input conquest_deck_copy_order_by {
  copy_deck_id: order_by
  created_at: order_by
  deck: conquest_deck_order_by
  deck_copy: conquest_deck_order_by
  deck_id: order_by
  updated_at: order_by
  user: conquest_users_order_by
  user_id: order_by
}

"""primary key columns input for table: conquest.deck_copy"""
input conquest_deck_copy_pk_columns_input {
  copy_deck_id: Int!
}

"""
select columns of table "conquest.deck_copy"
"""
enum conquest_deck_copy_select_column {
  """column name"""
  copy_deck_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "conquest.deck_copy"
"""
input conquest_deck_copy_set_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type conquest_deck_copy_stddev_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate stddev_pop on columns"""
type conquest_deck_copy_stddev_pop_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate stddev_samp on columns"""
type conquest_deck_copy_stddev_samp_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
Streaming cursor of the table "conquest_deck_copy"
"""
input conquest_deck_copy_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_deck_copy_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_deck_copy_stream_cursor_value_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type conquest_deck_copy_sum_fields {
  copy_deck_id: Int
  deck_id: Int
}

"""
update columns of table "conquest.deck_copy"
"""
enum conquest_deck_copy_update_column {
  """column name"""
  copy_deck_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input conquest_deck_copy_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_deck_copy_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_deck_copy_set_input

  """filter the rows which have to be updated"""
  where: conquest_deck_copy_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_deck_copy_var_pop_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate var_samp on columns"""
type conquest_deck_copy_var_samp_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate variance on columns"""
type conquest_deck_copy_variance_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input conquest_deck_delete_at_path_input {
  meta: [String!]
  side_slots: [String!]
  slots: [String!]
  tags: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input conquest_deck_delete_elem_input {
  meta: Int
  side_slots: Int
  slots: Int
  tags: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input conquest_deck_delete_key_input {
  meta: String
  side_slots: String
  slots: String
  tags: String
}

"""
input type for incrementing numeric columns in table "conquest.deck"
"""
input conquest_deck_inc_input {
  comment_count: Int
  copy_count: Int
  id: Int
  like_count: Int
}

"""
input type for inserting data into table "conquest.deck"
"""
input conquest_deck_insert_input {
  comment_count: Int
  comments: conquest_comment_arr_rel_insert_input
  copy_count: Int
  created_at: timestamptz
  description: String
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  original_deck: conquest_deck_copy_obj_rel_insert_input
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
  user: conquest_users_obj_rel_insert_input
  user_id: String
}

"""
columns and relationships of "conquest.deck_like"
"""
type conquest_deck_like {
  created_at: timestamptz!
  deck_id: Int!
  liked: Boolean!
  user_id: String!
}

"""
aggregated selection of "conquest.deck_like"
"""
type conquest_deck_like_aggregate {
  aggregate: conquest_deck_like_aggregate_fields
  nodes: [conquest_deck_like!]!
}

"""
aggregate fields of "conquest.deck_like"
"""
type conquest_deck_like_aggregate_fields {
  avg: conquest_deck_like_avg_fields
  count(columns: [conquest_deck_like_select_column!], distinct: Boolean): Int!
  max: conquest_deck_like_max_fields
  min: conquest_deck_like_min_fields
  stddev: conquest_deck_like_stddev_fields
  stddev_pop: conquest_deck_like_stddev_pop_fields
  stddev_samp: conquest_deck_like_stddev_samp_fields
  sum: conquest_deck_like_sum_fields
  var_pop: conquest_deck_like_var_pop_fields
  var_samp: conquest_deck_like_var_samp_fields
  variance: conquest_deck_like_variance_fields
}

"""aggregate avg on columns"""
type conquest_deck_like_avg_fields {
  deck_id: Float
}

"""
Boolean expression to filter rows from the table "conquest.deck_like". All fields are combined with a logical 'AND'.
"""
input conquest_deck_like_bool_exp {
  _and: [conquest_deck_like_bool_exp!]
  _not: conquest_deck_like_bool_exp
  _or: [conquest_deck_like_bool_exp!]
  created_at: timestamptz_comparison_exp
  deck_id: Int_comparison_exp
  liked: Boolean_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.deck_like"
"""
enum conquest_deck_like_constraint {
  """
  unique or primary key constraint on columns "user_id", "deck_id"
  """
  deck_like_pkey
}

"""
input type for incrementing numeric columns in table "conquest.deck_like"
"""
input conquest_deck_like_inc_input {
  deck_id: Int
}

"""
input type for inserting data into table "conquest.deck_like"
"""
input conquest_deck_like_insert_input {
  created_at: timestamptz
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate max on columns"""
type conquest_deck_like_max_fields {
  created_at: timestamptz
  deck_id: Int
  user_id: String
}

"""aggregate min on columns"""
type conquest_deck_like_min_fields {
  created_at: timestamptz
  deck_id: Int
  user_id: String
}

"""
response of any mutation on the table "conquest.deck_like"
"""
type conquest_deck_like_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_deck_like!]!
}

"""
on_conflict condition type for table "conquest.deck_like"
"""
input conquest_deck_like_on_conflict {
  constraint: conquest_deck_like_constraint!
  update_columns: [conquest_deck_like_update_column!]! = []
  where: conquest_deck_like_bool_exp
}

"""Ordering options when selecting data from "conquest.deck_like"."""
input conquest_deck_like_order_by {
  created_at: order_by
  deck_id: order_by
  liked: order_by
  user_id: order_by
}

"""primary key columns input for table: conquest.deck_like"""
input conquest_deck_like_pk_columns_input {
  deck_id: Int!
  user_id: String!
}

"""
select columns of table "conquest.deck_like"
"""
enum conquest_deck_like_select_column {
  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  liked

  """column name"""
  user_id
}

"""
input type for updating data in table "conquest.deck_like"
"""
input conquest_deck_like_set_input {
  created_at: timestamptz
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate stddev on columns"""
type conquest_deck_like_stddev_fields {
  deck_id: Float
}

"""aggregate stddev_pop on columns"""
type conquest_deck_like_stddev_pop_fields {
  deck_id: Float
}

"""aggregate stddev_samp on columns"""
type conquest_deck_like_stddev_samp_fields {
  deck_id: Float
}

"""
Streaming cursor of the table "conquest_deck_like"
"""
input conquest_deck_like_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_deck_like_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_deck_like_stream_cursor_value_input {
  created_at: timestamptz
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate sum on columns"""
type conquest_deck_like_sum_fields {
  deck_id: Int
}

"""
update columns of table "conquest.deck_like"
"""
enum conquest_deck_like_update_column {
  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  liked

  """column name"""
  user_id
}

input conquest_deck_like_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_deck_like_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_deck_like_set_input

  """filter the rows which have to be updated"""
  where: conquest_deck_like_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_deck_like_var_pop_fields {
  deck_id: Float
}

"""aggregate var_samp on columns"""
type conquest_deck_like_var_samp_fields {
  deck_id: Float
}

"""aggregate variance on columns"""
type conquest_deck_like_variance_fields {
  deck_id: Float
}

"""aggregate max on columns"""
type conquest_deck_max_fields {
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  id: Int
  like_count: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type conquest_deck_min_fields {
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  id: Int
  like_count: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "conquest.deck"
"""
type conquest_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_deck!]!
}

"""
input type for inserting object relation for remote table "conquest.deck"
"""
input conquest_deck_obj_rel_insert_input {
  data: conquest_deck_insert_input!

  """upsert condition"""
  on_conflict: conquest_deck_on_conflict
}

"""
on_conflict condition type for table "conquest.deck"
"""
input conquest_deck_on_conflict {
  constraint: conquest_deck_constraint!
  update_columns: [conquest_deck_update_column!]! = []
  where: conquest_deck_bool_exp
}

"""Ordering options when selecting data from "conquest.deck"."""
input conquest_deck_order_by {
  comment_count: order_by
  comments_aggregate: conquest_comment_aggregate_order_by
  copy_count: order_by
  created_at: order_by
  description: order_by
  id: order_by
  like_count: order_by
  liked_by_user: order_by
  meta: order_by
  name: order_by
  original_deck: conquest_deck_copy_order_by
  published: order_by
  side_slots: order_by
  slots: order_by
  tags: order_by
  updated_at: order_by
  user: conquest_users_order_by
  user_id: order_by
}

"""primary key columns input for table: conquest.deck"""
input conquest_deck_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input conquest_deck_prepend_input {
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
}

"""
select columns of table "conquest.deck"
"""
enum conquest_deck_select_column {
  """column name"""
  comment_count

  """column name"""
  copy_count

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  published

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "conquest.deck"
"""
input conquest_deck_set_input {
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type conquest_deck_stddev_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""aggregate stddev_pop on columns"""
type conquest_deck_stddev_pop_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""aggregate stddev_samp on columns"""
type conquest_deck_stddev_samp_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""
Streaming cursor of the table "conquest_deck"
"""
input conquest_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_deck_stream_cursor_value_input {
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type conquest_deck_sum_fields {
  comment_count: Int
  copy_count: Int
  id: Int
  like_count: Int
}

"""
update columns of table "conquest.deck"
"""
enum conquest_deck_update_column {
  """column name"""
  comment_count

  """column name"""
  copy_count

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  published

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_id
}

input conquest_deck_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: conquest_deck_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: conquest_deck_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: conquest_deck_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: conquest_deck_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_deck_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: conquest_deck_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_deck_set_input

  """filter the rows which have to be updated"""
  where: conquest_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_deck_var_pop_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""aggregate var_samp on columns"""
type conquest_deck_var_samp_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""aggregate variance on columns"""
type conquest_deck_variance_fields {
  comment_count: Float
  copy_count: Float
  id: Float
  like_count: Float
}

"""
columns and relationships of "conquest.faction"
"""
type conquest_faction {
  id: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.faction"
"""
type conquest_faction_aggregate {
  aggregate: conquest_faction_aggregate_fields
  nodes: [conquest_faction!]!
}

"""
aggregate fields of "conquest.faction"
"""
type conquest_faction_aggregate_fields {
  count(columns: [conquest_faction_select_column!], distinct: Boolean): Int!
  max: conquest_faction_max_fields
  min: conquest_faction_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.faction". All fields are combined with a logical 'AND'.
"""
input conquest_faction_bool_exp {
  _and: [conquest_faction_bool_exp!]
  _not: conquest_faction_bool_exp
  _or: [conquest_faction_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.faction"
"""
enum conquest_faction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  faction_pkey
}

"""
input type for inserting data into table "conquest.faction"
"""
input conquest_faction_insert_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_faction_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_faction_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.faction"
"""
type conquest_faction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_faction!]!
}

"""
on_conflict condition type for table "conquest.faction"
"""
input conquest_faction_on_conflict {
  constraint: conquest_faction_constraint!
  update_columns: [conquest_faction_update_column!]! = []
  where: conquest_faction_bool_exp
}

"""Ordering options when selecting data from "conquest.faction"."""
input conquest_faction_order_by {
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.faction"""
input conquest_faction_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.faction"
"""
enum conquest_faction_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.faction"
"""
input conquest_faction_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_faction"
"""
input conquest_faction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_faction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_faction_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "conquest.faction_text"
"""
type conquest_faction_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.faction_text"
"""
type conquest_faction_text_aggregate {
  aggregate: conquest_faction_text_aggregate_fields
  nodes: [conquest_faction_text!]!
}

"""
aggregate fields of "conquest.faction_text"
"""
type conquest_faction_text_aggregate_fields {
  count(columns: [conquest_faction_text_select_column!], distinct: Boolean): Int!
  max: conquest_faction_text_max_fields
  min: conquest_faction_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.faction_text". All fields are combined with a logical 'AND'.
"""
input conquest_faction_text_bool_exp {
  _and: [conquest_faction_text_bool_exp!]
  _not: conquest_faction_text_bool_exp
  _or: [conquest_faction_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.faction_text"
"""
enum conquest_faction_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  faction_text_pkey
}

"""
input type for inserting data into table "conquest.faction_text"
"""
input conquest_faction_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_faction_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_faction_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.faction_text"
"""
type conquest_faction_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_faction_text!]!
}

"""
on_conflict condition type for table "conquest.faction_text"
"""
input conquest_faction_text_on_conflict {
  constraint: conquest_faction_text_constraint!
  update_columns: [conquest_faction_text_update_column!]! = []
  where: conquest_faction_text_bool_exp
}

"""Ordering options when selecting data from "conquest.faction_text"."""
input conquest_faction_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.faction_text"""
input conquest_faction_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.faction_text"
"""
enum conquest_faction_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.faction_text"
"""
input conquest_faction_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_faction_text"
"""
input conquest_faction_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_faction_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_faction_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.faction_text"
"""
enum conquest_faction_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_faction_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_faction_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_faction_text_bool_exp!
}

"""
update columns of table "conquest.faction"
"""
enum conquest_faction_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_faction_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_faction_set_input

  """filter the rows which have to be updated"""
  where: conquest_faction_bool_exp!
}

"""
columns and relationships of "conquest.loyalty"
"""
type conquest_loyalty {
  id: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.loyalty"
"""
type conquest_loyalty_aggregate {
  aggregate: conquest_loyalty_aggregate_fields
  nodes: [conquest_loyalty!]!
}

"""
aggregate fields of "conquest.loyalty"
"""
type conquest_loyalty_aggregate_fields {
  count(columns: [conquest_loyalty_select_column!], distinct: Boolean): Int!
  max: conquest_loyalty_max_fields
  min: conquest_loyalty_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.loyalty". All fields are combined with a logical 'AND'.
"""
input conquest_loyalty_bool_exp {
  _and: [conquest_loyalty_bool_exp!]
  _not: conquest_loyalty_bool_exp
  _or: [conquest_loyalty_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.loyalty"
"""
enum conquest_loyalty_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  loyalty_pkey
}

"""
input type for inserting data into table "conquest.loyalty"
"""
input conquest_loyalty_insert_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_loyalty_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_loyalty_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.loyalty"
"""
type conquest_loyalty_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_loyalty!]!
}

"""
on_conflict condition type for table "conquest.loyalty"
"""
input conquest_loyalty_on_conflict {
  constraint: conquest_loyalty_constraint!
  update_columns: [conquest_loyalty_update_column!]! = []
  where: conquest_loyalty_bool_exp
}

"""Ordering options when selecting data from "conquest.loyalty"."""
input conquest_loyalty_order_by {
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.loyalty"""
input conquest_loyalty_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.loyalty"
"""
enum conquest_loyalty_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.loyalty"
"""
input conquest_loyalty_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_loyalty"
"""
input conquest_loyalty_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_loyalty_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_loyalty_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "conquest.loyalty_text"
"""
type conquest_loyalty_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.loyalty_text"
"""
type conquest_loyalty_text_aggregate {
  aggregate: conquest_loyalty_text_aggregate_fields
  nodes: [conquest_loyalty_text!]!
}

"""
aggregate fields of "conquest.loyalty_text"
"""
type conquest_loyalty_text_aggregate_fields {
  count(columns: [conquest_loyalty_text_select_column!], distinct: Boolean): Int!
  max: conquest_loyalty_text_max_fields
  min: conquest_loyalty_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.loyalty_text". All fields are combined with a logical 'AND'.
"""
input conquest_loyalty_text_bool_exp {
  _and: [conquest_loyalty_text_bool_exp!]
  _not: conquest_loyalty_text_bool_exp
  _or: [conquest_loyalty_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.loyalty_text"
"""
enum conquest_loyalty_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  loyalty_text_pkey
}

"""
input type for inserting data into table "conquest.loyalty_text"
"""
input conquest_loyalty_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_loyalty_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_loyalty_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.loyalty_text"
"""
type conquest_loyalty_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_loyalty_text!]!
}

"""
on_conflict condition type for table "conquest.loyalty_text"
"""
input conquest_loyalty_text_on_conflict {
  constraint: conquest_loyalty_text_constraint!
  update_columns: [conquest_loyalty_text_update_column!]! = []
  where: conquest_loyalty_text_bool_exp
}

"""Ordering options when selecting data from "conquest.loyalty_text"."""
input conquest_loyalty_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.loyalty_text"""
input conquest_loyalty_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.loyalty_text"
"""
enum conquest_loyalty_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.loyalty_text"
"""
input conquest_loyalty_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_loyalty_text"
"""
input conquest_loyalty_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_loyalty_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_loyalty_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.loyalty_text"
"""
enum conquest_loyalty_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_loyalty_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_loyalty_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_loyalty_text_bool_exp!
}

"""
update columns of table "conquest.loyalty"
"""
enum conquest_loyalty_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_loyalty_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_loyalty_set_input

  """filter the rows which have to be updated"""
  where: conquest_loyalty_bool_exp!
}

"""
columns and relationships of "conquest.pack"
"""
type conquest_pack {
  cycle_id: String!
  id: String!
  name: String!
  position: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.pack"
"""
type conquest_pack_aggregate {
  aggregate: conquest_pack_aggregate_fields
  nodes: [conquest_pack!]!
}

"""
aggregate fields of "conquest.pack"
"""
type conquest_pack_aggregate_fields {
  avg: conquest_pack_avg_fields
  count(columns: [conquest_pack_select_column!], distinct: Boolean): Int!
  max: conquest_pack_max_fields
  min: conquest_pack_min_fields
  stddev: conquest_pack_stddev_fields
  stddev_pop: conquest_pack_stddev_pop_fields
  stddev_samp: conquest_pack_stddev_samp_fields
  sum: conquest_pack_sum_fields
  var_pop: conquest_pack_var_pop_fields
  var_samp: conquest_pack_var_samp_fields
  variance: conquest_pack_variance_fields
}

"""aggregate avg on columns"""
type conquest_pack_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "conquest.pack". All fields are combined with a logical 'AND'.
"""
input conquest_pack_bool_exp {
  _and: [conquest_pack_bool_exp!]
  _not: conquest_pack_bool_exp
  _or: [conquest_pack_bool_exp!]
  cycle_id: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  position: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.pack"
"""
enum conquest_pack_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pack_pkey
}

"""
input type for incrementing numeric columns in table "conquest.pack"
"""
input conquest_pack_inc_input {
  position: Int
}

"""
input type for inserting data into table "conquest.pack"
"""
input conquest_pack_insert_input {
  cycle_id: String
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_pack_max_fields {
  cycle_id: String
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_pack_min_fields {
  cycle_id: String
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.pack"
"""
type conquest_pack_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_pack!]!
}

"""
on_conflict condition type for table "conquest.pack"
"""
input conquest_pack_on_conflict {
  constraint: conquest_pack_constraint!
  update_columns: [conquest_pack_update_column!]! = []
  where: conquest_pack_bool_exp
}

"""Ordering options when selecting data from "conquest.pack"."""
input conquest_pack_order_by {
  cycle_id: order_by
  id: order_by
  name: order_by
  position: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.pack"""
input conquest_pack_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.pack"
"""
enum conquest_pack_select_column {
  """column name"""
  cycle_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.pack"
"""
input conquest_pack_set_input {
  cycle_id: String
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type conquest_pack_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type conquest_pack_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type conquest_pack_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "conquest_pack"
"""
input conquest_pack_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_pack_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_pack_stream_cursor_value_input {
  cycle_id: String
  id: String
  name: String
  position: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type conquest_pack_sum_fields {
  position: Int
}

"""
columns and relationships of "conquest.pack_text"
"""
type conquest_pack_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.pack_text"
"""
type conquest_pack_text_aggregate {
  aggregate: conquest_pack_text_aggregate_fields
  nodes: [conquest_pack_text!]!
}

"""
aggregate fields of "conquest.pack_text"
"""
type conquest_pack_text_aggregate_fields {
  count(columns: [conquest_pack_text_select_column!], distinct: Boolean): Int!
  max: conquest_pack_text_max_fields
  min: conquest_pack_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.pack_text". All fields are combined with a logical 'AND'.
"""
input conquest_pack_text_bool_exp {
  _and: [conquest_pack_text_bool_exp!]
  _not: conquest_pack_text_bool_exp
  _or: [conquest_pack_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.pack_text"
"""
enum conquest_pack_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  pack_text_pkey
}

"""
input type for inserting data into table "conquest.pack_text"
"""
input conquest_pack_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_pack_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_pack_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.pack_text"
"""
type conquest_pack_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_pack_text!]!
}

"""
on_conflict condition type for table "conquest.pack_text"
"""
input conquest_pack_text_on_conflict {
  constraint: conquest_pack_text_constraint!
  update_columns: [conquest_pack_text_update_column!]! = []
  where: conquest_pack_text_bool_exp
}

"""Ordering options when selecting data from "conquest.pack_text"."""
input conquest_pack_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.pack_text"""
input conquest_pack_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.pack_text"
"""
enum conquest_pack_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.pack_text"
"""
input conquest_pack_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_pack_text"
"""
input conquest_pack_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_pack_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_pack_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.pack_text"
"""
enum conquest_pack_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_pack_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_pack_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_pack_text_bool_exp!
}

"""
update columns of table "conquest.pack"
"""
enum conquest_pack_update_column {
  """column name"""
  cycle_id

  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  updated_at
}

input conquest_pack_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conquest_pack_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conquest_pack_set_input

  """filter the rows which have to be updated"""
  where: conquest_pack_bool_exp!
}

"""aggregate var_pop on columns"""
type conquest_pack_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type conquest_pack_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type conquest_pack_variance_fields {
  position: Float
}

input conquest_publish_deck_args {
  deck_id: Int
}

"""
columns and relationships of "conquest.type"
"""
type conquest_type {
  id: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "conquest.type"
"""
type conquest_type_aggregate {
  aggregate: conquest_type_aggregate_fields
  nodes: [conquest_type!]!
}

"""
aggregate fields of "conquest.type"
"""
type conquest_type_aggregate_fields {
  count(columns: [conquest_type_select_column!], distinct: Boolean): Int!
  max: conquest_type_max_fields
  min: conquest_type_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.type". All fields are combined with a logical 'AND'.
"""
input conquest_type_bool_exp {
  _and: [conquest_type_bool_exp!]
  _not: conquest_type_bool_exp
  _or: [conquest_type_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.type"
"""
enum conquest_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  type_pkey
}

"""
input type for inserting data into table "conquest.type"
"""
input conquest_type_insert_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_type_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_type_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.type"
"""
type conquest_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_type!]!
}

"""
on_conflict condition type for table "conquest.type"
"""
input conquest_type_on_conflict {
  constraint: conquest_type_constraint!
  update_columns: [conquest_type_update_column!]! = []
  where: conquest_type_bool_exp
}

"""Ordering options when selecting data from "conquest.type"."""
input conquest_type_order_by {
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.type"""
input conquest_type_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.type"
"""
enum conquest_type_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.type"
"""
input conquest_type_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_type"
"""
input conquest_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_type_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "conquest.type_text"
"""
type conquest_type_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.type_text"
"""
type conquest_type_text_aggregate {
  aggregate: conquest_type_text_aggregate_fields
  nodes: [conquest_type_text!]!
}

"""
aggregate fields of "conquest.type_text"
"""
type conquest_type_text_aggregate_fields {
  count(columns: [conquest_type_text_select_column!], distinct: Boolean): Int!
  max: conquest_type_text_max_fields
  min: conquest_type_text_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.type_text". All fields are combined with a logical 'AND'.
"""
input conquest_type_text_bool_exp {
  _and: [conquest_type_text_bool_exp!]
  _not: conquest_type_text_bool_exp
  _or: [conquest_type_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.type_text"
"""
enum conquest_type_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  type_text_pkey
}

"""
input type for inserting data into table "conquest.type_text"
"""
input conquest_type_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_type_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_type_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.type_text"
"""
type conquest_type_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_type_text!]!
}

"""
on_conflict condition type for table "conquest.type_text"
"""
input conquest_type_text_on_conflict {
  constraint: conquest_type_text_constraint!
  update_columns: [conquest_type_text_update_column!]! = []
  where: conquest_type_text_bool_exp
}

"""Ordering options when selecting data from "conquest.type_text"."""
input conquest_type_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.type_text"""
input conquest_type_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "conquest.type_text"
"""
enum conquest_type_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.type_text"
"""
input conquest_type_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_type_text"
"""
input conquest_type_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_type_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_type_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "conquest.type_text"
"""
enum conquest_type_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_type_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_type_text_set_input

  """filter the rows which have to be updated"""
  where: conquest_type_text_bool_exp!
}

"""
update columns of table "conquest.type"
"""
enum conquest_type_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input conquest_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_type_set_input

  """filter the rows which have to be updated"""
  where: conquest_type_bool_exp!
}

"""
columns and relationships of "conquest.user_role"
"""
type conquest_user_role {
  id: String!
}

"""
aggregated selection of "conquest.user_role"
"""
type conquest_user_role_aggregate {
  aggregate: conquest_user_role_aggregate_fields
  nodes: [conquest_user_role!]!
}

"""
aggregate fields of "conquest.user_role"
"""
type conquest_user_role_aggregate_fields {
  count(columns: [conquest_user_role_select_column!], distinct: Boolean): Int!
  max: conquest_user_role_max_fields
  min: conquest_user_role_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.user_role". All fields are combined with a logical 'AND'.
"""
input conquest_user_role_bool_exp {
  _and: [conquest_user_role_bool_exp!]
  _not: conquest_user_role_bool_exp
  _or: [conquest_user_role_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.user_role"
"""
enum conquest_user_role_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_role_pkey
}

enum conquest_user_role_enum {
  admin
  moderator
}

"""
Boolean expression to compare columns of type "conquest_user_role_enum". All fields are combined with logical 'AND'.
"""
input conquest_user_role_enum_comparison_exp {
  _eq: conquest_user_role_enum
  _in: [conquest_user_role_enum!]
  _is_null: Boolean
  _neq: conquest_user_role_enum
  _nin: [conquest_user_role_enum!]
}

"""
input type for inserting data into table "conquest.user_role"
"""
input conquest_user_role_insert_input {
  id: String
}

"""aggregate max on columns"""
type conquest_user_role_max_fields {
  id: String
}

"""aggregate min on columns"""
type conquest_user_role_min_fields {
  id: String
}

"""
response of any mutation on the table "conquest.user_role"
"""
type conquest_user_role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_user_role!]!
}

"""
on_conflict condition type for table "conquest.user_role"
"""
input conquest_user_role_on_conflict {
  constraint: conquest_user_role_constraint!
  update_columns: [conquest_user_role_update_column!]! = []
  where: conquest_user_role_bool_exp
}

"""Ordering options when selecting data from "conquest.user_role"."""
input conquest_user_role_order_by {
  id: order_by
}

"""primary key columns input for table: conquest.user_role"""
input conquest_user_role_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.user_role"
"""
enum conquest_user_role_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "conquest.user_role"
"""
input conquest_user_role_set_input {
  id: String
}

"""
Streaming cursor of the table "conquest_user_role"
"""
input conquest_user_role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_user_role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_user_role_stream_cursor_value_input {
  id: String
}

"""
update columns of table "conquest.user_role"
"""
enum conquest_user_role_update_column {
  """column name"""
  id
}

input conquest_user_role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_user_role_set_input

  """filter the rows which have to be updated"""
  where: conquest_user_role_bool_exp!
}

"""
columns and relationships of "conquest.user_settings"
"""
type conquest_user_settings {
  private_decks: Boolean!
  user_id: String!
}

"""
aggregated selection of "conquest.user_settings"
"""
type conquest_user_settings_aggregate {
  aggregate: conquest_user_settings_aggregate_fields
  nodes: [conquest_user_settings!]!
}

input conquest_user_settings_aggregate_bool_exp {
  bool_and: conquest_user_settings_aggregate_bool_exp_bool_and
  bool_or: conquest_user_settings_aggregate_bool_exp_bool_or
  count: conquest_user_settings_aggregate_bool_exp_count
}

input conquest_user_settings_aggregate_bool_exp_bool_and {
  arguments: conquest_user_settings_select_column_conquest_user_settings_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: conquest_user_settings_bool_exp
  predicate: Boolean_comparison_exp!
}

input conquest_user_settings_aggregate_bool_exp_bool_or {
  arguments: conquest_user_settings_select_column_conquest_user_settings_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: conquest_user_settings_bool_exp
  predicate: Boolean_comparison_exp!
}

input conquest_user_settings_aggregate_bool_exp_count {
  arguments: [conquest_user_settings_select_column!]
  distinct: Boolean
  filter: conquest_user_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "conquest.user_settings"
"""
type conquest_user_settings_aggregate_fields {
  count(columns: [conquest_user_settings_select_column!], distinct: Boolean): Int!
  max: conquest_user_settings_max_fields
  min: conquest_user_settings_min_fields
}

"""
order by aggregate values of table "conquest.user_settings"
"""
input conquest_user_settings_aggregate_order_by {
  count: order_by
  max: conquest_user_settings_max_order_by
  min: conquest_user_settings_min_order_by
}

"""
input type for inserting array relation for remote table "conquest.user_settings"
"""
input conquest_user_settings_arr_rel_insert_input {
  data: [conquest_user_settings_insert_input!]!

  """upsert condition"""
  on_conflict: conquest_user_settings_on_conflict
}

"""
Boolean expression to filter rows from the table "conquest.user_settings". All fields are combined with a logical 'AND'.
"""
input conquest_user_settings_bool_exp {
  _and: [conquest_user_settings_bool_exp!]
  _not: conquest_user_settings_bool_exp
  _or: [conquest_user_settings_bool_exp!]
  private_decks: Boolean_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "conquest.user_settings"
"""
enum conquest_user_settings_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  user_settings_pkey
}

"""
input type for inserting data into table "conquest.user_settings"
"""
input conquest_user_settings_insert_input {
  private_decks: Boolean
  user_id: String
}

"""aggregate max on columns"""
type conquest_user_settings_max_fields {
  user_id: String
}

"""
order by max() on columns of table "conquest.user_settings"
"""
input conquest_user_settings_max_order_by {
  user_id: order_by
}

"""aggregate min on columns"""
type conquest_user_settings_min_fields {
  user_id: String
}

"""
order by min() on columns of table "conquest.user_settings"
"""
input conquest_user_settings_min_order_by {
  user_id: order_by
}

"""
response of any mutation on the table "conquest.user_settings"
"""
type conquest_user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_user_settings!]!
}

"""
on_conflict condition type for table "conquest.user_settings"
"""
input conquest_user_settings_on_conflict {
  constraint: conquest_user_settings_constraint!
  update_columns: [conquest_user_settings_update_column!]! = []
  where: conquest_user_settings_bool_exp
}

"""Ordering options when selecting data from "conquest.user_settings"."""
input conquest_user_settings_order_by {
  private_decks: order_by
  user_id: order_by
}

"""primary key columns input for table: conquest.user_settings"""
input conquest_user_settings_pk_columns_input {
  user_id: String!
}

"""
select columns of table "conquest.user_settings"
"""
enum conquest_user_settings_select_column {
  """column name"""
  private_decks

  """column name"""
  user_id
}

"""
select "conquest_user_settings_aggregate_bool_exp_bool_and_arguments_columns" columns of table "conquest.user_settings"
"""
enum conquest_user_settings_select_column_conquest_user_settings_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  private_decks
}

"""
select "conquest_user_settings_aggregate_bool_exp_bool_or_arguments_columns" columns of table "conquest.user_settings"
"""
enum conquest_user_settings_select_column_conquest_user_settings_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  private_decks
}

"""
input type for updating data in table "conquest.user_settings"
"""
input conquest_user_settings_set_input {
  private_decks: Boolean
  user_id: String
}

"""
Streaming cursor of the table "conquest_user_settings"
"""
input conquest_user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_user_settings_stream_cursor_value_input {
  private_decks: Boolean
  user_id: String
}

"""
update columns of table "conquest.user_settings"
"""
enum conquest_user_settings_update_column {
  """column name"""
  private_decks

  """column name"""
  user_id
}

input conquest_user_settings_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_user_settings_set_input

  """filter the rows which have to be updated"""
  where: conquest_user_settings_bool_exp!
}

"""
columns and relationships of "conquest.users"
"""
type conquest_users {
  created_at: timestamptz!
  handle: String
  id: String!
  normalized_handle: String
  role: conquest_user_role_enum

  """An array relationship"""
  settings(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): [conquest_user_settings!]!

  """An aggregate relationship"""
  settings_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): conquest_user_settings_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "conquest.users"
"""
type conquest_users_aggregate {
  aggregate: conquest_users_aggregate_fields
  nodes: [conquest_users!]!
}

"""
aggregate fields of "conquest.users"
"""
type conquest_users_aggregate_fields {
  count(columns: [conquest_users_select_column!], distinct: Boolean): Int!
  max: conquest_users_max_fields
  min: conquest_users_min_fields
}

"""
Boolean expression to filter rows from the table "conquest.users". All fields are combined with a logical 'AND'.
"""
input conquest_users_bool_exp {
  _and: [conquest_users_bool_exp!]
  _not: conquest_users_bool_exp
  _or: [conquest_users_bool_exp!]
  created_at: timestamptz_comparison_exp
  handle: String_comparison_exp
  id: String_comparison_exp
  normalized_handle: String_comparison_exp
  role: conquest_user_role_enum_comparison_exp
  settings: conquest_user_settings_bool_exp
  settings_aggregate: conquest_user_settings_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "conquest.users"
"""
enum conquest_users_constraint {
  """
  unique or primary key constraint on columns "normalized_handle"
  """
  users_normalized_handle_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "conquest.users"
"""
input conquest_users_insert_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  role: conquest_user_role_enum
  settings: conquest_user_settings_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type conquest_users_max_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type conquest_users_min_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "conquest.users"
"""
type conquest_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conquest_users!]!
}

"""
input type for inserting object relation for remote table "conquest.users"
"""
input conquest_users_obj_rel_insert_input {
  data: conquest_users_insert_input!

  """upsert condition"""
  on_conflict: conquest_users_on_conflict
}

"""
on_conflict condition type for table "conquest.users"
"""
input conquest_users_on_conflict {
  constraint: conquest_users_constraint!
  update_columns: [conquest_users_update_column!]! = []
  where: conquest_users_bool_exp
}

"""Ordering options when selecting data from "conquest.users"."""
input conquest_users_order_by {
  created_at: order_by
  handle: order_by
  id: order_by
  normalized_handle: order_by
  role: order_by
  settings_aggregate: conquest_user_settings_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: conquest.users"""
input conquest_users_pk_columns_input {
  id: String!
}

"""
select columns of table "conquest.users"
"""
enum conquest_users_select_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  role

  """column name"""
  updated_at
}

"""
input type for updating data in table "conquest.users"
"""
input conquest_users_set_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  role: conquest_user_role_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "conquest_users"
"""
input conquest_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conquest_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conquest_users_stream_cursor_value_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  role: conquest_user_role_enum
  updated_at: timestamptz
}

"""
update columns of table "conquest.users"
"""
enum conquest_users_update_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  role

  """column name"""
  updated_at
}

input conquest_users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: conquest_users_set_input

  """filter the rows which have to be updated"""
  where: conquest_users_bool_exp!
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "cycle"
"""
type cycle {
  code: String!
  official: Boolean!

  """An array relationship"""
  packs(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): [pack!]!

  """An aggregate relationship"""
  packs_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): pack_aggregate!
  position: Int!
  real_name: String!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): [cycle_name!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): cycle_name_aggregate!
}

"""
aggregated selection of "cycle"
"""
type cycle_aggregate {
  aggregate: cycle_aggregate_fields
  nodes: [cycle!]!
}

"""
aggregate fields of "cycle"
"""
type cycle_aggregate_fields {
  avg: cycle_avg_fields
  count(columns: [cycle_select_column!], distinct: Boolean): Int!
  max: cycle_max_fields
  min: cycle_min_fields
  stddev: cycle_stddev_fields
  stddev_pop: cycle_stddev_pop_fields
  stddev_samp: cycle_stddev_samp_fields
  sum: cycle_sum_fields
  var_pop: cycle_var_pop_fields
  var_samp: cycle_var_samp_fields
  variance: cycle_variance_fields
}

"""aggregate avg on columns"""
type cycle_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "cycle". All fields are combined with a logical 'AND'.
"""
input cycle_bool_exp {
  _and: [cycle_bool_exp!]
  _not: cycle_bool_exp
  _or: [cycle_bool_exp!]
  code: String_comparison_exp
  official: Boolean_comparison_exp
  packs: pack_bool_exp
  packs_aggregate: pack_aggregate_bool_exp
  position: Int_comparison_exp
  real_name: String_comparison_exp
  translations: cycle_name_bool_exp
  translations_aggregate: cycle_name_aggregate_bool_exp
}

"""
unique or primary key constraints on table "cycle"
"""
enum cycle_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  cycle_pkey
}

"""
input type for incrementing numeric columns in table "cycle"
"""
input cycle_inc_input {
  position: Int
}

"""
input type for inserting data into table "cycle"
"""
input cycle_insert_input {
  code: String
  official: Boolean
  packs: pack_arr_rel_insert_input
  position: Int
  real_name: String
  translations: cycle_name_arr_rel_insert_input
}

"""aggregate max on columns"""
type cycle_max_fields {
  code: String
  position: Int
  real_name: String
}

"""aggregate min on columns"""
type cycle_min_fields {
  code: String
  position: Int
  real_name: String
}

"""
response of any mutation on the table "cycle"
"""
type cycle_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cycle!]!
}

"""
columns and relationships of "cycle_name"
"""
type cycle_name {
  code: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "cycle_name"
"""
type cycle_name_aggregate {
  aggregate: cycle_name_aggregate_fields
  nodes: [cycle_name!]!
}

input cycle_name_aggregate_bool_exp {
  count: cycle_name_aggregate_bool_exp_count
}

input cycle_name_aggregate_bool_exp_count {
  arguments: [cycle_name_select_column!]
  distinct: Boolean
  filter: cycle_name_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "cycle_name"
"""
type cycle_name_aggregate_fields {
  count(columns: [cycle_name_select_column!], distinct: Boolean): Int!
  max: cycle_name_max_fields
  min: cycle_name_min_fields
}

"""
order by aggregate values of table "cycle_name"
"""
input cycle_name_aggregate_order_by {
  count: order_by
  max: cycle_name_max_order_by
  min: cycle_name_min_order_by
}

"""
input type for inserting array relation for remote table "cycle_name"
"""
input cycle_name_arr_rel_insert_input {
  data: [cycle_name_insert_input!]!

  """upsert condition"""
  on_conflict: cycle_name_on_conflict
}

"""
Boolean expression to filter rows from the table "cycle_name". All fields are combined with a logical 'AND'.
"""
input cycle_name_bool_exp {
  _and: [cycle_name_bool_exp!]
  _not: cycle_name_bool_exp
  _or: [cycle_name_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "cycle_name"
"""
enum cycle_name_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  cycle_name_pkey
}

"""
input type for inserting data into table "cycle_name"
"""
input cycle_name_insert_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type cycle_name_max_fields {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "cycle_name"
"""
input cycle_name_max_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type cycle_name_min_fields {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "cycle_name"
"""
input cycle_name_min_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "cycle_name"
"""
type cycle_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cycle_name!]!
}

"""
on_conflict condition type for table "cycle_name"
"""
input cycle_name_on_conflict {
  constraint: cycle_name_constraint!
  update_columns: [cycle_name_update_column!]! = []
  where: cycle_name_bool_exp
}

"""Ordering options when selecting data from "cycle_name"."""
input cycle_name_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: cycle_name"""
input cycle_name_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "cycle_name"
"""
enum cycle_name_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "cycle_name"
"""
input cycle_name_set_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "cycle_name"
"""
input cycle_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cycle_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cycle_name_stream_cursor_value_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "cycle_name"
"""
enum cycle_name_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input cycle_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: cycle_name_set_input

  """filter the rows which have to be updated"""
  where: cycle_name_bool_exp!
}

"""
input type for inserting object relation for remote table "cycle"
"""
input cycle_obj_rel_insert_input {
  data: cycle_insert_input!

  """upsert condition"""
  on_conflict: cycle_on_conflict
}

"""
on_conflict condition type for table "cycle"
"""
input cycle_on_conflict {
  constraint: cycle_constraint!
  update_columns: [cycle_update_column!]! = []
  where: cycle_bool_exp
}

"""Ordering options when selecting data from "cycle"."""
input cycle_order_by {
  code: order_by
  official: order_by
  packs_aggregate: pack_aggregate_order_by
  position: order_by
  real_name: order_by
  translations_aggregate: cycle_name_aggregate_order_by
}

"""primary key columns input for table: cycle"""
input cycle_pk_columns_input {
  code: String!
}

"""
select columns of table "cycle"
"""
enum cycle_select_column {
  """column name"""
  code

  """column name"""
  official

  """column name"""
  position

  """column name"""
  real_name
}

"""
input type for updating data in table "cycle"
"""
input cycle_set_input {
  code: String
  official: Boolean
  position: Int
  real_name: String
}

"""aggregate stddev on columns"""
type cycle_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type cycle_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type cycle_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "cycle"
"""
input cycle_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cycle_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cycle_stream_cursor_value_input {
  code: String
  official: Boolean
  position: Int
  real_name: String
}

"""aggregate sum on columns"""
type cycle_sum_fields {
  position: Int
}

"""
update columns of table "cycle"
"""
enum cycle_update_column {
  """column name"""
  code

  """column name"""
  official

  """column name"""
  position

  """column name"""
  real_name
}

input cycle_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: cycle_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: cycle_set_input

  """filter the rows which have to be updated"""
  where: cycle_bool_exp!
}

"""aggregate var_pop on columns"""
type cycle_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type cycle_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type cycle_variance_fields {
  position: Float
}

"""
columns and relationships of "faction_name"
"""
type faction_name {
  code: String!
  locale: String!
  name: String!
}

"""
aggregated selection of "faction_name"
"""
type faction_name_aggregate {
  aggregate: faction_name_aggregate_fields
  nodes: [faction_name!]!
}

"""
aggregate fields of "faction_name"
"""
type faction_name_aggregate_fields {
  count(columns: [faction_name_select_column!], distinct: Boolean): Int!
  max: faction_name_max_fields
  min: faction_name_min_fields
}

"""
Boolean expression to filter rows from the table "faction_name". All fields are combined with a logical 'AND'.
"""
input faction_name_bool_exp {
  _and: [faction_name_bool_exp!]
  _not: faction_name_bool_exp
  _or: [faction_name_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "faction_name"
"""
enum faction_name_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  faction_name_pkey
}

"""
input type for inserting data into table "faction_name"
"""
input faction_name_insert_input {
  code: String
  locale: String
  name: String
}

"""aggregate max on columns"""
type faction_name_max_fields {
  code: String
  locale: String
  name: String
}

"""aggregate min on columns"""
type faction_name_min_fields {
  code: String
  locale: String
  name: String
}

"""
response of any mutation on the table "faction_name"
"""
type faction_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [faction_name!]!
}

"""
on_conflict condition type for table "faction_name"
"""
input faction_name_on_conflict {
  constraint: faction_name_constraint!
  update_columns: [faction_name_update_column!]! = []
  where: faction_name_bool_exp
}

"""Ordering options when selecting data from "faction_name"."""
input faction_name_order_by {
  code: order_by
  locale: order_by
  name: order_by
}

"""primary key columns input for table: faction_name"""
input faction_name_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "faction_name"
"""
enum faction_name_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

"""
input type for updating data in table "faction_name"
"""
input faction_name_set_input {
  code: String
  locale: String
  name: String
}

"""
Streaming cursor of the table "faction_name"
"""
input faction_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: faction_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input faction_name_stream_cursor_value_input {
  code: String
  locale: String
  name: String
}

"""
update columns of table "faction_name"
"""
enum faction_name_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name
}

input faction_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: faction_name_set_input

  """filter the rows which have to be updated"""
  where: faction_name_bool_exp!
}

"""
columns and relationships of "faq"
"""
type faq {
  code: String!

  """An array relationship"""
  faq_texts(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): [faq_text!]!

  """An aggregate relationship"""
  faq_texts_aggregate(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): faq_text_aggregate!
  text: String!
}

"""
aggregated selection of "faq"
"""
type faq_aggregate {
  aggregate: faq_aggregate_fields
  nodes: [faq!]!
}

"""
aggregate fields of "faq"
"""
type faq_aggregate_fields {
  count(columns: [faq_select_column!], distinct: Boolean): Int!
  max: faq_max_fields
  min: faq_min_fields
}

"""
Boolean expression to filter rows from the table "faq". All fields are combined with a logical 'AND'.
"""
input faq_bool_exp {
  _and: [faq_bool_exp!]
  _not: faq_bool_exp
  _or: [faq_bool_exp!]
  code: String_comparison_exp
  faq_texts: faq_text_bool_exp
  faq_texts_aggregate: faq_text_aggregate_bool_exp
  text: String_comparison_exp
}

"""
unique or primary key constraints on table "faq"
"""
enum faq_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  faq_pkey
}

"""
input type for inserting data into table "faq"
"""
input faq_insert_input {
  code: String
  faq_texts: faq_text_arr_rel_insert_input
  text: String
}

"""aggregate max on columns"""
type faq_max_fields {
  code: String
  text: String
}

"""aggregate min on columns"""
type faq_min_fields {
  code: String
  text: String
}

"""
response of any mutation on the table "faq"
"""
type faq_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [faq!]!
}

"""
on_conflict condition type for table "faq"
"""
input faq_on_conflict {
  constraint: faq_constraint!
  update_columns: [faq_update_column!]! = []
  where: faq_bool_exp
}

"""Ordering options when selecting data from "faq"."""
input faq_order_by {
  code: order_by
  faq_texts_aggregate: faq_text_aggregate_order_by
  text: order_by
}

"""primary key columns input for table: faq"""
input faq_pk_columns_input {
  code: String!
}

"""
select columns of table "faq"
"""
enum faq_select_column {
  """column name"""
  code

  """column name"""
  text
}

"""
input type for updating data in table "faq"
"""
input faq_set_input {
  code: String
  text: String
}

"""
Streaming cursor of the table "faq"
"""
input faq_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: faq_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input faq_stream_cursor_value_input {
  code: String
  text: String
}

"""
columns and relationships of "faq_text"
"""
type faq_text {
  code: String!
  locale: String!
  text: String!
}

"""
aggregated selection of "faq_text"
"""
type faq_text_aggregate {
  aggregate: faq_text_aggregate_fields
  nodes: [faq_text!]!
}

input faq_text_aggregate_bool_exp {
  count: faq_text_aggregate_bool_exp_count
}

input faq_text_aggregate_bool_exp_count {
  arguments: [faq_text_select_column!]
  distinct: Boolean
  filter: faq_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "faq_text"
"""
type faq_text_aggregate_fields {
  count(columns: [faq_text_select_column!], distinct: Boolean): Int!
  max: faq_text_max_fields
  min: faq_text_min_fields
}

"""
order by aggregate values of table "faq_text"
"""
input faq_text_aggregate_order_by {
  count: order_by
  max: faq_text_max_order_by
  min: faq_text_min_order_by
}

"""
input type for inserting array relation for remote table "faq_text"
"""
input faq_text_arr_rel_insert_input {
  data: [faq_text_insert_input!]!

  """upsert condition"""
  on_conflict: faq_text_on_conflict
}

"""
Boolean expression to filter rows from the table "faq_text". All fields are combined with a logical 'AND'.
"""
input faq_text_bool_exp {
  _and: [faq_text_bool_exp!]
  _not: faq_text_bool_exp
  _or: [faq_text_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  text: String_comparison_exp
}

"""
unique or primary key constraints on table "faq_text"
"""
enum faq_text_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  faq_text_pkey
}

"""
input type for inserting data into table "faq_text"
"""
input faq_text_insert_input {
  code: String
  locale: String
  text: String
}

"""aggregate max on columns"""
type faq_text_max_fields {
  code: String
  locale: String
  text: String
}

"""
order by max() on columns of table "faq_text"
"""
input faq_text_max_order_by {
  code: order_by
  locale: order_by
  text: order_by
}

"""aggregate min on columns"""
type faq_text_min_fields {
  code: String
  locale: String
  text: String
}

"""
order by min() on columns of table "faq_text"
"""
input faq_text_min_order_by {
  code: order_by
  locale: order_by
  text: order_by
}

"""
response of any mutation on the table "faq_text"
"""
type faq_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [faq_text!]!
}

"""
on_conflict condition type for table "faq_text"
"""
input faq_text_on_conflict {
  constraint: faq_text_constraint!
  update_columns: [faq_text_update_column!]! = []
  where: faq_text_bool_exp
}

"""Ordering options when selecting data from "faq_text"."""
input faq_text_order_by {
  code: order_by
  locale: order_by
  text: order_by
}

"""primary key columns input for table: faq_text"""
input faq_text_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "faq_text"
"""
enum faq_text_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  text
}

"""
input type for updating data in table "faq_text"
"""
input faq_text_set_input {
  code: String
  locale: String
  text: String
}

"""
Streaming cursor of the table "faq_text"
"""
input faq_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: faq_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input faq_text_stream_cursor_value_input {
  code: String
  locale: String
  text: String
}

"""
update columns of table "faq_text"
"""
enum faq_text_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  text
}

input faq_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: faq_text_set_input

  """filter the rows which have to be updated"""
  where: faq_text_bool_exp!
}

"""
update columns of table "faq"
"""
enum faq_update_column {
  """column name"""
  code

  """column name"""
  text
}

input faq_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: faq_set_input

  """filter the rows which have to be updated"""
  where: faq_bool_exp!
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "friend_status"
"""
type friend_status {
  """
  A computed field, executes function "friend_status_id"
  """
  id: String
  status: friend_status_type_enum!
  user_id_a: String!
  user_id_b: String!
}

"""
aggregated selection of "friend_status"
"""
type friend_status_aggregate {
  aggregate: friend_status_aggregate_fields
  nodes: [friend_status!]!
}

"""
aggregate fields of "friend_status"
"""
type friend_status_aggregate_fields {
  count(columns: [friend_status_select_column!], distinct: Boolean): Int!
  max: friend_status_max_fields
  min: friend_status_min_fields
}

"""
Boolean expression to filter rows from the table "friend_status". All fields are combined with a logical 'AND'.
"""
input friend_status_bool_exp {
  _and: [friend_status_bool_exp!]
  _not: friend_status_bool_exp
  _or: [friend_status_bool_exp!]
  id: String_comparison_exp
  status: friend_status_type_enum_comparison_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
unique or primary key constraints on table "friend_status"
"""
enum friend_status_constraint {
  """
  unique or primary key constraint on columns "user_id_b", "user_id_a"
  """
  friend_status_pkey
}

"""
input type for inserting data into table "friend_status"
"""
input friend_status_insert_input {
  status: friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type friend_status_max_fields {
  """
  A computed field, executes function "friend_status_id"
  """
  id: String
  user_id_a: String
  user_id_b: String
}

"""aggregate min on columns"""
type friend_status_min_fields {
  """
  A computed field, executes function "friend_status_id"
  """
  id: String
  user_id_a: String
  user_id_b: String
}

"""
response of any mutation on the table "friend_status"
"""
type friend_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [friend_status!]!
}

"""
on_conflict condition type for table "friend_status"
"""
input friend_status_on_conflict {
  constraint: friend_status_constraint!
  update_columns: [friend_status_update_column!]! = []
  where: friend_status_bool_exp
}

"""Ordering options when selecting data from "friend_status"."""
input friend_status_order_by {
  id: order_by
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""primary key columns input for table: friend_status"""
input friend_status_pk_columns_input {
  user_id_a: String!
  user_id_b: String!
}

"""
select columns of table "friend_status"
"""
enum friend_status_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "friend_status"
"""
input friend_status_set_input {
  status: friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "friend_status"
"""
input friend_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: friend_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input friend_status_stream_cursor_value_input {
  status: friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""
columns and relationships of "friend_status_type"
"""
type friend_status_type {
  value: String!
}

"""
aggregated selection of "friend_status_type"
"""
type friend_status_type_aggregate {
  aggregate: friend_status_type_aggregate_fields
  nodes: [friend_status_type!]!
}

"""
aggregate fields of "friend_status_type"
"""
type friend_status_type_aggregate_fields {
  count(columns: [friend_status_type_select_column!], distinct: Boolean): Int!
  max: friend_status_type_max_fields
  min: friend_status_type_min_fields
}

"""
Boolean expression to filter rows from the table "friend_status_type". All fields are combined with a logical 'AND'.
"""
input friend_status_type_bool_exp {
  _and: [friend_status_type_bool_exp!]
  _not: friend_status_type_bool_exp
  _or: [friend_status_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "friend_status_type"
"""
enum friend_status_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  friend_status_type_pkey
}

enum friend_status_type_enum {
  friend
  none
  received
  sent
}

"""
Boolean expression to compare columns of type "friend_status_type_enum". All fields are combined with logical 'AND'.
"""
input friend_status_type_enum_comparison_exp {
  _eq: friend_status_type_enum
  _in: [friend_status_type_enum!]
  _is_null: Boolean
  _neq: friend_status_type_enum
  _nin: [friend_status_type_enum!]
}

"""
input type for inserting data into table "friend_status_type"
"""
input friend_status_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type friend_status_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type friend_status_type_min_fields {
  value: String
}

"""
response of any mutation on the table "friend_status_type"
"""
type friend_status_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [friend_status_type!]!
}

"""
on_conflict condition type for table "friend_status_type"
"""
input friend_status_type_on_conflict {
  constraint: friend_status_type_constraint!
  update_columns: [friend_status_type_update_column!]! = []
  where: friend_status_type_bool_exp
}

"""Ordering options when selecting data from "friend_status_type"."""
input friend_status_type_order_by {
  value: order_by
}

"""primary key columns input for table: friend_status_type"""
input friend_status_type_pk_columns_input {
  value: String!
}

"""
select columns of table "friend_status_type"
"""
enum friend_status_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "friend_status_type"
"""
input friend_status_type_set_input {
  value: String
}

"""
Streaming cursor of the table "friend_status_type"
"""
input friend_status_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: friend_status_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input friend_status_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "friend_status_type"
"""
enum friend_status_type_update_column {
  """column name"""
  value
}

input friend_status_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: friend_status_type_set_input

  """filter the rows which have to be updated"""
  where: friend_status_type_bool_exp!
}

"""
update columns of table "friend_status"
"""
enum friend_status_update_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

input friend_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: friend_status_set_input

  """filter the rows which have to be updated"""
  where: friend_status_bool_exp!
}

"""
columns and relationships of "full_card"
"""
type full_card {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  clues_fixed: Boolean
  code: String!
  cost: Int
  deck_limit: Int
  deck_options(
    """JSON select path"""
    path: String
  ): jsonb
  deck_requirements(
    """JSON select path"""
    path: String
  ): jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int

  """An array relationship"""
  encounter_sets(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): [card_encounter_set!]!

  """An aggregate relationship"""
  encounter_sets_aggregate(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): card_encounter_set_aggregate!
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String!
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  illustrator: String
  imagesrc: String
  is_unique: Boolean

  """An object relationship"""
  linked_card: full_card
  myriad: Boolean
  pack_code: String!
  pack_position: Int!

  """An array relationship"""
  packs(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """An aggregate relationship"""
  packs_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!
  permanent: Boolean
  position: Int!
  quantity: Int!
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String!
  real_pack_name: String!
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions(
    """JSON select path"""
    path: String
  ): jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): [full_card_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): full_card_text_aggregate!
  type_code: card_type_code_enum!
  updated_at: timestamptz
  vengeance: Int
  version: Int!
  victory: Int
  xp: Int
}

"""
aggregated selection of "full_card"
"""
type full_card_aggregate {
  aggregate: full_card_aggregate_fields
  nodes: [full_card!]!
}

"""
aggregate fields of "full_card"
"""
type full_card_aggregate_fields {
  avg: full_card_avg_fields
  count(columns: [full_card_select_column!], distinct: Boolean): Int!
  max: full_card_max_fields
  min: full_card_min_fields
  stddev: full_card_stddev_fields
  stddev_pop: full_card_stddev_pop_fields
  stddev_samp: full_card_stddev_samp_fields
  sum: full_card_sum_fields
  var_pop: full_card_var_pop_fields
  var_samp: full_card_var_samp_fields
  variance: full_card_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input full_card_append_input {
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
}

"""aggregate avg on columns"""
type full_card_avg_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
Boolean expression to filter rows from the table "full_card". All fields are combined with a logical 'AND'.
"""
input full_card_bool_exp {
  _and: [full_card_bool_exp!]
  _not: full_card_bool_exp
  _or: [full_card_bool_exp!]
  alternate_required_code: String_comparison_exp
  back_link: String_comparison_exp
  backimagesrc: String_comparison_exp
  clues: Int_comparison_exp
  clues_fixed: Boolean_comparison_exp
  code: String_comparison_exp
  cost: Int_comparison_exp
  deck_limit: Int_comparison_exp
  deck_options: jsonb_comparison_exp
  deck_requirements: jsonb_comparison_exp
  doom: Int_comparison_exp
  double_sided: Boolean_comparison_exp
  encounter_code: String_comparison_exp
  encounter_position: Int_comparison_exp
  encounter_sets: card_encounter_set_bool_exp
  encounter_sets_aggregate: card_encounter_set_aggregate_bool_exp
  enemy_damage: Int_comparison_exp
  enemy_evade: Int_comparison_exp
  enemy_fight: Int_comparison_exp
  enemy_horror: Int_comparison_exp
  exceptional: Boolean_comparison_exp
  exile: Boolean_comparison_exp
  faction2_code: String_comparison_exp
  faction3_code: String_comparison_exp
  faction_code: String_comparison_exp
  health: Int_comparison_exp
  health_per_investigator: Boolean_comparison_exp
  hidden: Boolean_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  is_unique: Boolean_comparison_exp
  linked_card: full_card_bool_exp
  myriad: Boolean_comparison_exp
  pack_code: String_comparison_exp
  pack_position: Int_comparison_exp
  packs: card_pack_bool_exp
  packs_aggregate: card_pack_aggregate_bool_exp
  permanent: Boolean_comparison_exp
  position: Int_comparison_exp
  quantity: Int_comparison_exp
  real_back_flavor: String_comparison_exp
  real_back_name: String_comparison_exp
  real_back_text: String_comparison_exp
  real_encounter_set_name: String_comparison_exp
  real_flavor: String_comparison_exp
  real_name: String_comparison_exp
  real_pack_name: String_comparison_exp
  real_slot: String_comparison_exp
  real_subname: String_comparison_exp
  real_text: String_comparison_exp
  real_traits: String_comparison_exp
  restrictions: jsonb_comparison_exp
  sanity: Int_comparison_exp
  shroud: Int_comparison_exp
  skill_agility: Int_comparison_exp
  skill_combat: Int_comparison_exp
  skill_intellect: Int_comparison_exp
  skill_wild: Int_comparison_exp
  skill_willpower: Int_comparison_exp
  stage: Int_comparison_exp
  subtype_code: String_comparison_exp
  translations: full_card_text_bool_exp
  translations_aggregate: full_card_text_aggregate_bool_exp
  type_code: card_type_code_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  vengeance: Int_comparison_exp
  version: Int_comparison_exp
  victory: Int_comparison_exp
  xp: Int_comparison_exp
}

"""
unique or primary key constraints on table "full_card"
"""
enum full_card_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  full_card_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input full_card_delete_at_path_input {
  deck_options: [String!]
  deck_requirements: [String!]
  restrictions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input full_card_delete_elem_input {
  deck_options: Int
  deck_requirements: Int
  restrictions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input full_card_delete_key_input {
  deck_options: String
  deck_requirements: String
  restrictions: String
}

"""
input type for incrementing numeric columns in table "full_card"
"""
input full_card_inc_input {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
input type for inserting data into table "full_card"
"""
input full_card_insert_input {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  encounter_sets: card_encounter_set_arr_rel_insert_input
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  illustrator: String
  imagesrc: String
  is_unique: Boolean
  linked_card: full_card_obj_rel_insert_input
  myriad: Boolean
  pack_code: String
  pack_position: Int
  packs: card_pack_arr_rel_insert_input
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  translations: full_card_text_arr_rel_insert_input
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate max on columns"""
type full_card_max_fields {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  illustrator: String
  imagesrc: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate min on columns"""
type full_card_min_fields {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  code: String
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  illustrator: String
  imagesrc: String
  pack_code: String
  pack_position: Int
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
response of any mutation on the table "full_card"
"""
type full_card_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [full_card!]!
}

"""
input type for inserting object relation for remote table "full_card"
"""
input full_card_obj_rel_insert_input {
  data: full_card_insert_input!

  """upsert condition"""
  on_conflict: full_card_on_conflict
}

"""
on_conflict condition type for table "full_card"
"""
input full_card_on_conflict {
  constraint: full_card_constraint!
  update_columns: [full_card_update_column!]! = []
  where: full_card_bool_exp
}

"""Ordering options when selecting data from "full_card"."""
input full_card_order_by {
  alternate_required_code: order_by
  back_link: order_by
  backimagesrc: order_by
  clues: order_by
  clues_fixed: order_by
  code: order_by
  cost: order_by
  deck_limit: order_by
  deck_options: order_by
  deck_requirements: order_by
  doom: order_by
  double_sided: order_by
  encounter_code: order_by
  encounter_position: order_by
  encounter_sets_aggregate: card_encounter_set_aggregate_order_by
  enemy_damage: order_by
  enemy_evade: order_by
  enemy_fight: order_by
  enemy_horror: order_by
  exceptional: order_by
  exile: order_by
  faction2_code: order_by
  faction3_code: order_by
  faction_code: order_by
  health: order_by
  health_per_investigator: order_by
  hidden: order_by
  illustrator: order_by
  imagesrc: order_by
  is_unique: order_by
  linked_card: full_card_order_by
  myriad: order_by
  pack_code: order_by
  pack_position: order_by
  packs_aggregate: card_pack_aggregate_order_by
  permanent: order_by
  position: order_by
  quantity: order_by
  real_back_flavor: order_by
  real_back_name: order_by
  real_back_text: order_by
  real_encounter_set_name: order_by
  real_flavor: order_by
  real_name: order_by
  real_pack_name: order_by
  real_slot: order_by
  real_subname: order_by
  real_text: order_by
  real_traits: order_by
  restrictions: order_by
  sanity: order_by
  shroud: order_by
  skill_agility: order_by
  skill_combat: order_by
  skill_intellect: order_by
  skill_wild: order_by
  skill_willpower: order_by
  stage: order_by
  subtype_code: order_by
  translations_aggregate: full_card_text_aggregate_order_by
  type_code: order_by
  updated_at: order_by
  vengeance: order_by
  version: order_by
  victory: order_by
  xp: order_by
}

"""primary key columns input for table: full_card"""
input full_card_pk_columns_input {
  code: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input full_card_prepend_input {
  deck_options: jsonb
  deck_requirements: jsonb
  restrictions: jsonb
}

"""
select columns of table "full_card"
"""
enum full_card_select_column {
  """column name"""
  alternate_required_code

  """column name"""
  back_link

  """column name"""
  backimagesrc

  """column name"""
  clues

  """column name"""
  clues_fixed

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction2_code

  """column name"""
  faction3_code

  """column name"""
  faction_code

  """column name"""
  health

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  is_unique

  """column name"""
  myriad

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_encounter_set_name

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  type_code

  """column name"""
  updated_at

  """column name"""
  vengeance

  """column name"""
  version

  """column name"""
  victory

  """column name"""
  xp
}

"""
input type for updating data in table "full_card"
"""
input full_card_set_input {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  illustrator: String
  imagesrc: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate stddev on columns"""
type full_card_stddev_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""aggregate stddev_pop on columns"""
type full_card_stddev_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""aggregate stddev_samp on columns"""
type full_card_stddev_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
Streaming cursor of the table "full_card"
"""
input full_card_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: full_card_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input full_card_stream_cursor_value_input {
  alternate_required_code: String
  back_link: String
  backimagesrc: String
  clues: Int
  clues_fixed: Boolean
  code: String
  cost: Int
  deck_limit: Int
  deck_options: jsonb
  deck_requirements: jsonb
  doom: Int
  double_sided: Boolean
  encounter_code: String
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  exceptional: Boolean
  exile: Boolean
  faction2_code: String
  faction3_code: String
  faction_code: String
  health: Int
  health_per_investigator: Boolean
  hidden: Boolean
  illustrator: String
  imagesrc: String
  is_unique: Boolean
  myriad: Boolean
  pack_code: String
  pack_position: Int
  permanent: Boolean
  position: Int
  quantity: Int
  real_back_flavor: String
  real_back_name: String
  real_back_text: String
  real_encounter_set_name: String
  real_flavor: String
  real_name: String
  real_pack_name: String
  real_slot: String
  real_subname: String
  real_text: String
  real_traits: String
  restrictions: jsonb
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  subtype_code: String
  type_code: card_type_code_enum
  updated_at: timestamptz
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""aggregate sum on columns"""
type full_card_sum_fields {
  clues: Int
  cost: Int
  deck_limit: Int
  doom: Int
  encounter_position: Int
  enemy_damage: Int
  enemy_evade: Int
  enemy_fight: Int
  enemy_horror: Int
  health: Int
  pack_position: Int
  position: Int
  quantity: Int
  sanity: Int
  shroud: Int
  skill_agility: Int
  skill_combat: Int
  skill_intellect: Int
  skill_wild: Int
  skill_willpower: Int
  stage: Int
  vengeance: Int
  version: Int
  victory: Int
  xp: Int
}

"""
columns and relationships of "full_card_text"
"""
type full_card_text {
  back_flavor: String
  back_name: String
  back_text: String
  code: String!
  encounter_name: String
  flavor: String
  locale: String!
  name: String!
  slot: String
  subname: String
  text: String
  traits: String
}

"""
aggregated selection of "full_card_text"
"""
type full_card_text_aggregate {
  aggregate: full_card_text_aggregate_fields
  nodes: [full_card_text!]!
}

input full_card_text_aggregate_bool_exp {
  count: full_card_text_aggregate_bool_exp_count
}

input full_card_text_aggregate_bool_exp_count {
  arguments: [full_card_text_select_column!]
  distinct: Boolean
  filter: full_card_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "full_card_text"
"""
type full_card_text_aggregate_fields {
  count(columns: [full_card_text_select_column!], distinct: Boolean): Int!
  max: full_card_text_max_fields
  min: full_card_text_min_fields
}

"""
order by aggregate values of table "full_card_text"
"""
input full_card_text_aggregate_order_by {
  count: order_by
  max: full_card_text_max_order_by
  min: full_card_text_min_order_by
}

"""
input type for inserting array relation for remote table "full_card_text"
"""
input full_card_text_arr_rel_insert_input {
  data: [full_card_text_insert_input!]!

  """upsert condition"""
  on_conflict: full_card_text_on_conflict
}

"""
Boolean expression to filter rows from the table "full_card_text". All fields are combined with a logical 'AND'.
"""
input full_card_text_bool_exp {
  _and: [full_card_text_bool_exp!]
  _not: full_card_text_bool_exp
  _or: [full_card_text_bool_exp!]
  back_flavor: String_comparison_exp
  back_name: String_comparison_exp
  back_text: String_comparison_exp
  code: String_comparison_exp
  encounter_name: String_comparison_exp
  flavor: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  slot: String_comparison_exp
  subname: String_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
}

"""
unique or primary key constraints on table "full_card_text"
"""
enum full_card_text_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  full_card_text_pkey
}

"""
input type for inserting data into table "full_card_text"
"""
input full_card_text_insert_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""aggregate max on columns"""
type full_card_text_max_fields {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
order by max() on columns of table "full_card_text"
"""
input full_card_text_max_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""aggregate min on columns"""
type full_card_text_min_fields {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
order by min() on columns of table "full_card_text"
"""
input full_card_text_min_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""
response of any mutation on the table "full_card_text"
"""
type full_card_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [full_card_text!]!
}

"""
on_conflict condition type for table "full_card_text"
"""
input full_card_text_on_conflict {
  constraint: full_card_text_constraint!
  update_columns: [full_card_text_update_column!]! = []
  where: full_card_text_bool_exp
}

"""Ordering options when selecting data from "full_card_text"."""
input full_card_text_order_by {
  back_flavor: order_by
  back_name: order_by
  back_text: order_by
  code: order_by
  encounter_name: order_by
  flavor: order_by
  locale: order_by
  name: order_by
  slot: order_by
  subname: order_by
  text: order_by
  traits: order_by
}

"""primary key columns input for table: full_card_text"""
input full_card_text_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "full_card_text"
"""
enum full_card_text_select_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  code

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  text

  """column name"""
  traits
}

"""
input type for updating data in table "full_card_text"
"""
input full_card_text_set_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
Streaming cursor of the table "full_card_text"
"""
input full_card_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: full_card_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input full_card_text_stream_cursor_value_input {
  back_flavor: String
  back_name: String
  back_text: String
  code: String
  encounter_name: String
  flavor: String
  locale: String
  name: String
  slot: String
  subname: String
  text: String
  traits: String
}

"""
update columns of table "full_card_text"
"""
enum full_card_text_update_column {
  """column name"""
  back_flavor

  """column name"""
  back_name

  """column name"""
  back_text

  """column name"""
  code

  """column name"""
  encounter_name

  """column name"""
  flavor

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  slot

  """column name"""
  subname

  """column name"""
  text

  """column name"""
  traits
}

input full_card_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: full_card_text_set_input

  """filter the rows which have to be updated"""
  where: full_card_text_bool_exp!
}

"""
update columns of table "full_card"
"""
enum full_card_update_column {
  """column name"""
  alternate_required_code

  """column name"""
  back_link

  """column name"""
  backimagesrc

  """column name"""
  clues

  """column name"""
  clues_fixed

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  deck_limit

  """column name"""
  deck_options

  """column name"""
  deck_requirements

  """column name"""
  doom

  """column name"""
  double_sided

  """column name"""
  encounter_code

  """column name"""
  encounter_position

  """column name"""
  enemy_damage

  """column name"""
  enemy_evade

  """column name"""
  enemy_fight

  """column name"""
  enemy_horror

  """column name"""
  exceptional

  """column name"""
  exile

  """column name"""
  faction2_code

  """column name"""
  faction3_code

  """column name"""
  faction_code

  """column name"""
  health

  """column name"""
  health_per_investigator

  """column name"""
  hidden

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  is_unique

  """column name"""
  myriad

  """column name"""
  pack_code

  """column name"""
  pack_position

  """column name"""
  permanent

  """column name"""
  position

  """column name"""
  quantity

  """column name"""
  real_back_flavor

  """column name"""
  real_back_name

  """column name"""
  real_back_text

  """column name"""
  real_encounter_set_name

  """column name"""
  real_flavor

  """column name"""
  real_name

  """column name"""
  real_pack_name

  """column name"""
  real_slot

  """column name"""
  real_subname

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  restrictions

  """column name"""
  sanity

  """column name"""
  shroud

  """column name"""
  skill_agility

  """column name"""
  skill_combat

  """column name"""
  skill_intellect

  """column name"""
  skill_wild

  """column name"""
  skill_willpower

  """column name"""
  stage

  """column name"""
  subtype_code

  """column name"""
  type_code

  """column name"""
  updated_at

  """column name"""
  vengeance

  """column name"""
  version

  """column name"""
  victory

  """column name"""
  xp
}

input full_card_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: full_card_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: full_card_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: full_card_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: full_card_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: full_card_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: full_card_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: full_card_set_input

  """filter the rows which have to be updated"""
  where: full_card_bool_exp!
}

"""aggregate var_pop on columns"""
type full_card_var_pop_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""aggregate var_samp on columns"""
type full_card_var_samp_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""aggregate variance on columns"""
type full_card_variance_fields {
  clues: Float
  cost: Float
  deck_limit: Float
  doom: Float
  encounter_position: Float
  enemy_damage: Float
  enemy_evade: Float
  enemy_fight: Float
  enemy_horror: Float
  health: Float
  pack_position: Float
  position: Float
  quantity: Float
  sanity: Float
  shroud: Float
  skill_agility: Float
  skill_combat: Float
  skill_intellect: Float
  skill_wild: Float
  skill_willpower: Float
  stage: Float
  vengeance: Float
  version: Float
  victory: Float
  xp: Float
}

"""
columns and relationships of "gender"
"""
type gender {
  code: String!
}

"""
aggregated selection of "gender"
"""
type gender_aggregate {
  aggregate: gender_aggregate_fields
  nodes: [gender!]!
}

"""
aggregate fields of "gender"
"""
type gender_aggregate_fields {
  count(columns: [gender_select_column!], distinct: Boolean): Int!
  max: gender_max_fields
  min: gender_min_fields
}

"""
Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'.
"""
input gender_bool_exp {
  _and: [gender_bool_exp!]
  _not: gender_bool_exp
  _or: [gender_bool_exp!]
  code: String_comparison_exp
}

"""
unique or primary key constraints on table "gender"
"""
enum gender_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  gender_pkey
}

enum gender_enum {
  f
  m
  nb
}

"""
Boolean expression to compare columns of type "gender_enum". All fields are combined with logical 'AND'.
"""
input gender_enum_comparison_exp {
  _eq: gender_enum
  _in: [gender_enum!]
  _is_null: Boolean
  _neq: gender_enum
  _nin: [gender_enum!]
}

"""
input type for inserting data into table "gender"
"""
input gender_insert_input {
  code: String
}

"""aggregate max on columns"""
type gender_max_fields {
  code: String
}

"""aggregate min on columns"""
type gender_min_fields {
  code: String
}

"""
response of any mutation on the table "gender"
"""
type gender_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gender!]!
}

"""
on_conflict condition type for table "gender"
"""
input gender_on_conflict {
  constraint: gender_constraint!
  update_columns: [gender_update_column!]! = []
  where: gender_bool_exp
}

"""Ordering options when selecting data from "gender"."""
input gender_order_by {
  code: order_by
}

"""primary key columns input for table: gender"""
input gender_pk_columns_input {
  code: String!
}

"""
select columns of table "gender"
"""
enum gender_select_column {
  """column name"""
  code
}

"""
input type for updating data in table "gender"
"""
input gender_set_input {
  code: String
}

"""
Streaming cursor of the table "gender"
"""
input gender_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: gender_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input gender_stream_cursor_value_input {
  code: String
}

"""
update columns of table "gender"
"""
enum gender_update_column {
  """column name"""
  code
}

input gender_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: gender_set_input

  """filter the rows which have to be updated"""
  where: gender_bool_exp!
}

"""
columns and relationships of "guide_achievement"
"""
type guide_achievement {
  bool_value: Boolean

  """An object relationship"""
  campaign: campaign!
  campaign_id: Int!
  created_at: timestamptz!
  id: String!
  type: String!
  updated_at: timestamptz!
  value: Int
}

"""
aggregated selection of "guide_achievement"
"""
type guide_achievement_aggregate {
  aggregate: guide_achievement_aggregate_fields
  nodes: [guide_achievement!]!
}

input guide_achievement_aggregate_bool_exp {
  bool_and: guide_achievement_aggregate_bool_exp_bool_and
  bool_or: guide_achievement_aggregate_bool_exp_bool_or
  count: guide_achievement_aggregate_bool_exp_count
}

input guide_achievement_aggregate_bool_exp_bool_and {
  arguments: guide_achievement_select_column_guide_achievement_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: guide_achievement_bool_exp
  predicate: Boolean_comparison_exp!
}

input guide_achievement_aggregate_bool_exp_bool_or {
  arguments: guide_achievement_select_column_guide_achievement_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: guide_achievement_bool_exp
  predicate: Boolean_comparison_exp!
}

input guide_achievement_aggregate_bool_exp_count {
  arguments: [guide_achievement_select_column!]
  distinct: Boolean
  filter: guide_achievement_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "guide_achievement"
"""
type guide_achievement_aggregate_fields {
  avg: guide_achievement_avg_fields
  count(columns: [guide_achievement_select_column!], distinct: Boolean): Int!
  max: guide_achievement_max_fields
  min: guide_achievement_min_fields
  stddev: guide_achievement_stddev_fields
  stddev_pop: guide_achievement_stddev_pop_fields
  stddev_samp: guide_achievement_stddev_samp_fields
  sum: guide_achievement_sum_fields
  var_pop: guide_achievement_var_pop_fields
  var_samp: guide_achievement_var_samp_fields
  variance: guide_achievement_variance_fields
}

"""
order by aggregate values of table "guide_achievement"
"""
input guide_achievement_aggregate_order_by {
  avg: guide_achievement_avg_order_by
  count: order_by
  max: guide_achievement_max_order_by
  min: guide_achievement_min_order_by
  stddev: guide_achievement_stddev_order_by
  stddev_pop: guide_achievement_stddev_pop_order_by
  stddev_samp: guide_achievement_stddev_samp_order_by
  sum: guide_achievement_sum_order_by
  var_pop: guide_achievement_var_pop_order_by
  var_samp: guide_achievement_var_samp_order_by
  variance: guide_achievement_variance_order_by
}

"""
input type for inserting array relation for remote table "guide_achievement"
"""
input guide_achievement_arr_rel_insert_input {
  data: [guide_achievement_insert_input!]!

  """upsert condition"""
  on_conflict: guide_achievement_on_conflict
}

"""aggregate avg on columns"""
type guide_achievement_avg_fields {
  campaign_id: Float
  value: Float
}

"""
order by avg() on columns of table "guide_achievement"
"""
input guide_achievement_avg_order_by {
  campaign_id: order_by
  value: order_by
}

"""
Boolean expression to filter rows from the table "guide_achievement". All fields are combined with a logical 'AND'.
"""
input guide_achievement_bool_exp {
  _and: [guide_achievement_bool_exp!]
  _not: guide_achievement_bool_exp
  _or: [guide_achievement_bool_exp!]
  bool_value: Boolean_comparison_exp
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "guide_achievement"
"""
enum guide_achievement_constraint {
  """
  unique or primary key constraint on columns "id", "campaign_id"
  """
  guide_achievement_pkey
}

"""
input type for incrementing numeric columns in table "guide_achievement"
"""
input guide_achievement_inc_input {
  campaign_id: Int
  value: Int
}

"""
input type for inserting data into table "guide_achievement"
"""
input guide_achievement_insert_input {
  bool_value: Boolean
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  created_at: timestamptz
  id: String
  type: String
  updated_at: timestamptz
  value: Int
}

"""aggregate max on columns"""
type guide_achievement_max_fields {
  campaign_id: Int
  created_at: timestamptz
  id: String
  type: String
  updated_at: timestamptz
  value: Int
}

"""
order by max() on columns of table "guide_achievement"
"""
input guide_achievement_max_order_by {
  campaign_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""aggregate min on columns"""
type guide_achievement_min_fields {
  campaign_id: Int
  created_at: timestamptz
  id: String
  type: String
  updated_at: timestamptz
  value: Int
}

"""
order by min() on columns of table "guide_achievement"
"""
input guide_achievement_min_order_by {
  campaign_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""
response of any mutation on the table "guide_achievement"
"""
type guide_achievement_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [guide_achievement!]!
}

"""
on_conflict condition type for table "guide_achievement"
"""
input guide_achievement_on_conflict {
  constraint: guide_achievement_constraint!
  update_columns: [guide_achievement_update_column!]! = []
  where: guide_achievement_bool_exp
}

"""Ordering options when selecting data from "guide_achievement"."""
input guide_achievement_order_by {
  bool_value: order_by
  campaign: campaign_order_by
  campaign_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""primary key columns input for table: guide_achievement"""
input guide_achievement_pk_columns_input {
  campaign_id: Int!
  id: String!
}

"""
select columns of table "guide_achievement"
"""
enum guide_achievement_select_column {
  """column name"""
  bool_value

  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  value
}

"""
select "guide_achievement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "guide_achievement"
"""
enum guide_achievement_select_column_guide_achievement_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  bool_value
}

"""
select "guide_achievement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "guide_achievement"
"""
enum guide_achievement_select_column_guide_achievement_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  bool_value
}

"""
input type for updating data in table "guide_achievement"
"""
input guide_achievement_set_input {
  bool_value: Boolean
  campaign_id: Int
  created_at: timestamptz
  id: String
  type: String
  updated_at: timestamptz
  value: Int
}

"""aggregate stddev on columns"""
type guide_achievement_stddev_fields {
  campaign_id: Float
  value: Float
}

"""
order by stddev() on columns of table "guide_achievement"
"""
input guide_achievement_stddev_order_by {
  campaign_id: order_by
  value: order_by
}

"""aggregate stddev_pop on columns"""
type guide_achievement_stddev_pop_fields {
  campaign_id: Float
  value: Float
}

"""
order by stddev_pop() on columns of table "guide_achievement"
"""
input guide_achievement_stddev_pop_order_by {
  campaign_id: order_by
  value: order_by
}

"""aggregate stddev_samp on columns"""
type guide_achievement_stddev_samp_fields {
  campaign_id: Float
  value: Float
}

"""
order by stddev_samp() on columns of table "guide_achievement"
"""
input guide_achievement_stddev_samp_order_by {
  campaign_id: order_by
  value: order_by
}

"""
Streaming cursor of the table "guide_achievement"
"""
input guide_achievement_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: guide_achievement_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input guide_achievement_stream_cursor_value_input {
  bool_value: Boolean
  campaign_id: Int
  created_at: timestamptz
  id: String
  type: String
  updated_at: timestamptz
  value: Int
}

"""aggregate sum on columns"""
type guide_achievement_sum_fields {
  campaign_id: Int
  value: Int
}

"""
order by sum() on columns of table "guide_achievement"
"""
input guide_achievement_sum_order_by {
  campaign_id: order_by
  value: order_by
}

"""
update columns of table "guide_achievement"
"""
enum guide_achievement_update_column {
  """column name"""
  bool_value

  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  value
}

input guide_achievement_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: guide_achievement_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: guide_achievement_set_input

  """filter the rows which have to be updated"""
  where: guide_achievement_bool_exp!
}

"""aggregate var_pop on columns"""
type guide_achievement_var_pop_fields {
  campaign_id: Float
  value: Float
}

"""
order by var_pop() on columns of table "guide_achievement"
"""
input guide_achievement_var_pop_order_by {
  campaign_id: order_by
  value: order_by
}

"""aggregate var_samp on columns"""
type guide_achievement_var_samp_fields {
  campaign_id: Float
  value: Float
}

"""
order by var_samp() on columns of table "guide_achievement"
"""
input guide_achievement_var_samp_order_by {
  campaign_id: order_by
  value: order_by
}

"""aggregate variance on columns"""
type guide_achievement_variance_fields {
  campaign_id: Float
  value: Float
}

"""
order by variance() on columns of table "guide_achievement"
"""
input guide_achievement_variance_order_by {
  campaign_id: order_by
  value: order_by
}

"""
columns and relationships of "guide_input"
"""
type guide_input {
  """An object relationship"""
  campaign: campaign!
  campaign_id: Int!
  created_at: timestamptz!
  id: String!
  inserted_idx: Int
  payload(
    """JSON select path"""
    path: String
  ): jsonb
  scenario: String
  step: String
  type: String!
  updated_at: timestamptz
}

"""
aggregated selection of "guide_input"
"""
type guide_input_aggregate {
  aggregate: guide_input_aggregate_fields
  nodes: [guide_input!]!
}

input guide_input_aggregate_bool_exp {
  count: guide_input_aggregate_bool_exp_count
}

input guide_input_aggregate_bool_exp_count {
  arguments: [guide_input_select_column!]
  distinct: Boolean
  filter: guide_input_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "guide_input"
"""
type guide_input_aggregate_fields {
  avg: guide_input_avg_fields
  count(columns: [guide_input_select_column!], distinct: Boolean): Int!
  max: guide_input_max_fields
  min: guide_input_min_fields
  stddev: guide_input_stddev_fields
  stddev_pop: guide_input_stddev_pop_fields
  stddev_samp: guide_input_stddev_samp_fields
  sum: guide_input_sum_fields
  var_pop: guide_input_var_pop_fields
  var_samp: guide_input_var_samp_fields
  variance: guide_input_variance_fields
}

"""
order by aggregate values of table "guide_input"
"""
input guide_input_aggregate_order_by {
  avg: guide_input_avg_order_by
  count: order_by
  max: guide_input_max_order_by
  min: guide_input_min_order_by
  stddev: guide_input_stddev_order_by
  stddev_pop: guide_input_stddev_pop_order_by
  stddev_samp: guide_input_stddev_samp_order_by
  sum: guide_input_sum_order_by
  var_pop: guide_input_var_pop_order_by
  var_samp: guide_input_var_samp_order_by
  variance: guide_input_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input guide_input_append_input {
  payload: jsonb
}

"""
input type for inserting array relation for remote table "guide_input"
"""
input guide_input_arr_rel_insert_input {
  data: [guide_input_insert_input!]!

  """upsert condition"""
  on_conflict: guide_input_on_conflict
}

"""aggregate avg on columns"""
type guide_input_avg_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by avg() on columns of table "guide_input"
"""
input guide_input_avg_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""
Boolean expression to filter rows from the table "guide_input". All fields are combined with a logical 'AND'.
"""
input guide_input_bool_exp {
  _and: [guide_input_bool_exp!]
  _not: guide_input_bool_exp
  _or: [guide_input_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  inserted_idx: Int_comparison_exp
  payload: jsonb_comparison_exp
  scenario: String_comparison_exp
  step: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "guide_input"
"""
enum guide_input_constraint {
  """
  unique or primary key constraint on columns "id", "campaign_id"
  """
  guide_input_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input guide_input_delete_at_path_input {
  payload: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input guide_input_delete_elem_input {
  payload: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input guide_input_delete_key_input {
  payload: String
}

"""
input type for incrementing numeric columns in table "guide_input"
"""
input guide_input_inc_input {
  campaign_id: Int
  inserted_idx: Int
}

"""
input type for inserting data into table "guide_input"
"""
input guide_input_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  created_at: timestamptz
  id: String
  inserted_idx: Int
  payload: jsonb
  scenario: String
  step: String
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type guide_input_max_fields {
  campaign_id: Int
  created_at: timestamptz
  id: String
  inserted_idx: Int
  scenario: String
  step: String
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "guide_input"
"""
input guide_input_max_order_by {
  campaign_id: order_by
  created_at: order_by
  id: order_by
  inserted_idx: order_by
  scenario: order_by
  step: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type guide_input_min_fields {
  campaign_id: Int
  created_at: timestamptz
  id: String
  inserted_idx: Int
  scenario: String
  step: String
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "guide_input"
"""
input guide_input_min_order_by {
  campaign_id: order_by
  created_at: order_by
  id: order_by
  inserted_idx: order_by
  scenario: order_by
  step: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "guide_input"
"""
type guide_input_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [guide_input!]!
}

"""
on_conflict condition type for table "guide_input"
"""
input guide_input_on_conflict {
  constraint: guide_input_constraint!
  update_columns: [guide_input_update_column!]! = []
  where: guide_input_bool_exp
}

"""Ordering options when selecting data from "guide_input"."""
input guide_input_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  created_at: order_by
  id: order_by
  inserted_idx: order_by
  payload: order_by
  scenario: order_by
  step: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: guide_input"""
input guide_input_pk_columns_input {
  campaign_id: Int!
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input guide_input_prepend_input {
  payload: jsonb
}

"""
select columns of table "guide_input"
"""
enum guide_input_select_column {
  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  inserted_idx

  """column name"""
  payload

  """column name"""
  scenario

  """column name"""
  step

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "guide_input"
"""
input guide_input_set_input {
  campaign_id: Int
  created_at: timestamptz
  id: String
  inserted_idx: Int
  payload: jsonb
  scenario: String
  step: String
  type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type guide_input_stddev_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by stddev() on columns of table "guide_input"
"""
input guide_input_stddev_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""aggregate stddev_pop on columns"""
type guide_input_stddev_pop_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by stddev_pop() on columns of table "guide_input"
"""
input guide_input_stddev_pop_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""aggregate stddev_samp on columns"""
type guide_input_stddev_samp_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by stddev_samp() on columns of table "guide_input"
"""
input guide_input_stddev_samp_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""
Streaming cursor of the table "guide_input"
"""
input guide_input_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: guide_input_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input guide_input_stream_cursor_value_input {
  campaign_id: Int
  created_at: timestamptz
  id: String
  inserted_idx: Int
  payload: jsonb
  scenario: String
  step: String
  type: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type guide_input_sum_fields {
  campaign_id: Int
  inserted_idx: Int
}

"""
order by sum() on columns of table "guide_input"
"""
input guide_input_sum_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""
update columns of table "guide_input"
"""
enum guide_input_update_column {
  """column name"""
  campaign_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  inserted_idx

  """column name"""
  payload

  """column name"""
  scenario

  """column name"""
  step

  """column name"""
  type

  """column name"""
  updated_at
}

input guide_input_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: guide_input_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: guide_input_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: guide_input_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: guide_input_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: guide_input_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: guide_input_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: guide_input_set_input

  """filter the rows which have to be updated"""
  where: guide_input_bool_exp!
}

"""aggregate var_pop on columns"""
type guide_input_var_pop_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by var_pop() on columns of table "guide_input"
"""
input guide_input_var_pop_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""aggregate var_samp on columns"""
type guide_input_var_samp_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by var_samp() on columns of table "guide_input"
"""
input guide_input_var_samp_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""aggregate variance on columns"""
type guide_input_variance_fields {
  campaign_id: Float
  inserted_idx: Float
}

"""
order by variance() on columns of table "guide_input"
"""
input guide_input_variance_order_by {
  campaign_id: order_by
  inserted_idx: order_by
}

"""
columns and relationships of "investigator_data"
"""
type investigator_data {
  addedCards(
    """JSON select path"""
    path: String
  ): jsonb
  availableXp: Int

  """An object relationship"""
  campaign_data: campaign!
  campaign_id: Int!
  cardCounts(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!

  """
  A computed field, executes function "investigator_data_id"
  """
  id: String
  ignoreStoryAssets(
    """JSON select path"""
    path: String
  ): jsonb
  insane: Boolean
  investigator: String!
  killed: Boolean
  mental: Int
  physical: Int
  removedCards(
    """JSON select path"""
    path: String
  ): jsonb
  specialXp(
    """JSON select path"""
    path: String
  ): jsonb
  spentXp: Int
  storyAssets(
    """JSON select path"""
    path: String
  ): jsonb
  updated_at: timestamptz!
}

"""
aggregated selection of "investigator_data"
"""
type investigator_data_aggregate {
  aggregate: investigator_data_aggregate_fields
  nodes: [investigator_data!]!
}

input investigator_data_aggregate_bool_exp {
  bool_and: investigator_data_aggregate_bool_exp_bool_and
  bool_or: investigator_data_aggregate_bool_exp_bool_or
  count: investigator_data_aggregate_bool_exp_count
}

input investigator_data_aggregate_bool_exp_bool_and {
  arguments: investigator_data_select_column_investigator_data_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: investigator_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input investigator_data_aggregate_bool_exp_bool_or {
  arguments: investigator_data_select_column_investigator_data_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: investigator_data_bool_exp
  predicate: Boolean_comparison_exp!
}

input investigator_data_aggregate_bool_exp_count {
  arguments: [investigator_data_select_column!]
  distinct: Boolean
  filter: investigator_data_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "investigator_data"
"""
type investigator_data_aggregate_fields {
  avg: investigator_data_avg_fields
  count(columns: [investigator_data_select_column!], distinct: Boolean): Int!
  max: investigator_data_max_fields
  min: investigator_data_min_fields
  stddev: investigator_data_stddev_fields
  stddev_pop: investigator_data_stddev_pop_fields
  stddev_samp: investigator_data_stddev_samp_fields
  sum: investigator_data_sum_fields
  var_pop: investigator_data_var_pop_fields
  var_samp: investigator_data_var_samp_fields
  variance: investigator_data_variance_fields
}

"""
order by aggregate values of table "investigator_data"
"""
input investigator_data_aggregate_order_by {
  avg: investigator_data_avg_order_by
  count: order_by
  max: investigator_data_max_order_by
  min: investigator_data_min_order_by
  stddev: investigator_data_stddev_order_by
  stddev_pop: investigator_data_stddev_pop_order_by
  stddev_samp: investigator_data_stddev_samp_order_by
  sum: investigator_data_sum_order_by
  var_pop: investigator_data_var_pop_order_by
  var_samp: investigator_data_var_samp_order_by
  variance: investigator_data_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input investigator_data_append_input {
  addedCards: jsonb
  cardCounts: jsonb
  ignoreStoryAssets: jsonb
  removedCards: jsonb
  specialXp: jsonb
  storyAssets: jsonb
}

"""
input type for inserting array relation for remote table "investigator_data"
"""
input investigator_data_arr_rel_insert_input {
  data: [investigator_data_insert_input!]!

  """upsert condition"""
  on_conflict: investigator_data_on_conflict
}

"""aggregate avg on columns"""
type investigator_data_avg_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by avg() on columns of table "investigator_data"
"""
input investigator_data_avg_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""
Boolean expression to filter rows from the table "investigator_data". All fields are combined with a logical 'AND'.
"""
input investigator_data_bool_exp {
  _and: [investigator_data_bool_exp!]
  _not: investigator_data_bool_exp
  _or: [investigator_data_bool_exp!]
  addedCards: jsonb_comparison_exp
  availableXp: Int_comparison_exp
  campaign_data: campaign_bool_exp
  campaign_id: Int_comparison_exp
  cardCounts: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  ignoreStoryAssets: jsonb_comparison_exp
  insane: Boolean_comparison_exp
  investigator: String_comparison_exp
  killed: Boolean_comparison_exp
  mental: Int_comparison_exp
  physical: Int_comparison_exp
  removedCards: jsonb_comparison_exp
  specialXp: jsonb_comparison_exp
  spentXp: Int_comparison_exp
  storyAssets: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "investigator_data"
"""
enum investigator_data_constraint {
  """
  unique or primary key constraint on columns "campaign_id", "investigator"
  """
  investigator_data_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input investigator_data_delete_at_path_input {
  addedCards: [String!]
  cardCounts: [String!]
  ignoreStoryAssets: [String!]
  removedCards: [String!]
  specialXp: [String!]
  storyAssets: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input investigator_data_delete_elem_input {
  addedCards: Int
  cardCounts: Int
  ignoreStoryAssets: Int
  removedCards: Int
  specialXp: Int
  storyAssets: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input investigator_data_delete_key_input {
  addedCards: String
  cardCounts: String
  ignoreStoryAssets: String
  removedCards: String
  specialXp: String
  storyAssets: String
}

"""
input type for incrementing numeric columns in table "investigator_data"
"""
input investigator_data_inc_input {
  availableXp: Int
  campaign_id: Int
  mental: Int
  physical: Int
  spentXp: Int
}

"""
input type for inserting data into table "investigator_data"
"""
input investigator_data_insert_input {
  addedCards: jsonb
  availableXp: Int
  campaign_data: campaign_obj_rel_insert_input
  campaign_id: Int
  cardCounts: jsonb
  created_at: timestamptz
  ignoreStoryAssets: jsonb
  insane: Boolean
  investigator: String
  killed: Boolean
  mental: Int
  physical: Int
  removedCards: jsonb
  specialXp: jsonb
  spentXp: Int
  storyAssets: jsonb
  updated_at: timestamptz
}

"""aggregate max on columns"""
type investigator_data_max_fields {
  availableXp: Int
  campaign_id: Int
  created_at: timestamptz

  """
  A computed field, executes function "investigator_data_id"
  """
  id: String
  investigator: String
  mental: Int
  physical: Int
  spentXp: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "investigator_data"
"""
input investigator_data_max_order_by {
  availableXp: order_by
  campaign_id: order_by
  created_at: order_by
  investigator: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type investigator_data_min_fields {
  availableXp: Int
  campaign_id: Int
  created_at: timestamptz

  """
  A computed field, executes function "investigator_data_id"
  """
  id: String
  investigator: String
  mental: Int
  physical: Int
  spentXp: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "investigator_data"
"""
input investigator_data_min_order_by {
  availableXp: order_by
  campaign_id: order_by
  created_at: order_by
  investigator: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "investigator_data"
"""
type investigator_data_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [investigator_data!]!
}

"""
input type for inserting object relation for remote table "investigator_data"
"""
input investigator_data_obj_rel_insert_input {
  data: investigator_data_insert_input!

  """upsert condition"""
  on_conflict: investigator_data_on_conflict
}

"""
on_conflict condition type for table "investigator_data"
"""
input investigator_data_on_conflict {
  constraint: investigator_data_constraint!
  update_columns: [investigator_data_update_column!]! = []
  where: investigator_data_bool_exp
}

"""Ordering options when selecting data from "investigator_data"."""
input investigator_data_order_by {
  addedCards: order_by
  availableXp: order_by
  campaign_data: campaign_order_by
  campaign_id: order_by
  cardCounts: order_by
  created_at: order_by
  id: order_by
  ignoreStoryAssets: order_by
  insane: order_by
  investigator: order_by
  killed: order_by
  mental: order_by
  physical: order_by
  removedCards: order_by
  specialXp: order_by
  spentXp: order_by
  storyAssets: order_by
  updated_at: order_by
}

"""primary key columns input for table: investigator_data"""
input investigator_data_pk_columns_input {
  campaign_id: Int!
  investigator: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input investigator_data_prepend_input {
  addedCards: jsonb
  cardCounts: jsonb
  ignoreStoryAssets: jsonb
  removedCards: jsonb
  specialXp: jsonb
  storyAssets: jsonb
}

"""
select columns of table "investigator_data"
"""
enum investigator_data_select_column {
  """column name"""
  addedCards

  """column name"""
  availableXp

  """column name"""
  campaign_id

  """column name"""
  cardCounts

  """column name"""
  created_at

  """column name"""
  ignoreStoryAssets

  """column name"""
  insane

  """column name"""
  investigator

  """column name"""
  killed

  """column name"""
  mental

  """column name"""
  physical

  """column name"""
  removedCards

  """column name"""
  specialXp

  """column name"""
  spentXp

  """column name"""
  storyAssets

  """column name"""
  updated_at
}

"""
select "investigator_data_aggregate_bool_exp_bool_and_arguments_columns" columns of table "investigator_data"
"""
enum investigator_data_select_column_investigator_data_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  insane

  """column name"""
  killed
}

"""
select "investigator_data_aggregate_bool_exp_bool_or_arguments_columns" columns of table "investigator_data"
"""
enum investigator_data_select_column_investigator_data_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  insane

  """column name"""
  killed
}

"""
input type for updating data in table "investigator_data"
"""
input investigator_data_set_input {
  addedCards: jsonb
  availableXp: Int
  campaign_id: Int
  cardCounts: jsonb
  created_at: timestamptz
  ignoreStoryAssets: jsonb
  insane: Boolean
  investigator: String
  killed: Boolean
  mental: Int
  physical: Int
  removedCards: jsonb
  specialXp: jsonb
  spentXp: Int
  storyAssets: jsonb
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type investigator_data_stddev_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by stddev() on columns of table "investigator_data"
"""
input investigator_data_stddev_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""aggregate stddev_pop on columns"""
type investigator_data_stddev_pop_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by stddev_pop() on columns of table "investigator_data"
"""
input investigator_data_stddev_pop_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""aggregate stddev_samp on columns"""
type investigator_data_stddev_samp_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by stddev_samp() on columns of table "investigator_data"
"""
input investigator_data_stddev_samp_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""
Streaming cursor of the table "investigator_data"
"""
input investigator_data_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: investigator_data_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input investigator_data_stream_cursor_value_input {
  addedCards: jsonb
  availableXp: Int
  campaign_id: Int
  cardCounts: jsonb
  created_at: timestamptz
  ignoreStoryAssets: jsonb
  insane: Boolean
  investigator: String
  killed: Boolean
  mental: Int
  physical: Int
  removedCards: jsonb
  specialXp: jsonb
  spentXp: Int
  storyAssets: jsonb
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type investigator_data_sum_fields {
  availableXp: Int
  campaign_id: Int
  mental: Int
  physical: Int
  spentXp: Int
}

"""
order by sum() on columns of table "investigator_data"
"""
input investigator_data_sum_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""
update columns of table "investigator_data"
"""
enum investigator_data_update_column {
  """column name"""
  addedCards

  """column name"""
  availableXp

  """column name"""
  campaign_id

  """column name"""
  cardCounts

  """column name"""
  created_at

  """column name"""
  ignoreStoryAssets

  """column name"""
  insane

  """column name"""
  investigator

  """column name"""
  killed

  """column name"""
  mental

  """column name"""
  physical

  """column name"""
  removedCards

  """column name"""
  specialXp

  """column name"""
  spentXp

  """column name"""
  storyAssets

  """column name"""
  updated_at
}

input investigator_data_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: investigator_data_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: investigator_data_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: investigator_data_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: investigator_data_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: investigator_data_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: investigator_data_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: investigator_data_set_input

  """filter the rows which have to be updated"""
  where: investigator_data_bool_exp!
}

"""aggregate var_pop on columns"""
type investigator_data_var_pop_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by var_pop() on columns of table "investigator_data"
"""
input investigator_data_var_pop_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""aggregate var_samp on columns"""
type investigator_data_var_samp_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by var_samp() on columns of table "investigator_data"
"""
input investigator_data_var_samp_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

"""aggregate variance on columns"""
type investigator_data_variance_fields {
  availableXp: Float
  campaign_id: Float
  mental: Float
  physical: Float
  spentXp: Float
}

"""
order by variance() on columns of table "investigator_data"
"""
input investigator_data_variance_order_by {
  availableXp: order_by
  campaign_id: order_by
  mental: order_by
  physical: order_by
  spentXp: order_by
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "latest_decks"
"""
type latest_decks {
  """An object relationship"""
  campaign: campaign
  campaign_id: Int

  """An object relationship"""
  deck: campaign_deck
  id: Int
  owner_id: String
}

"""
aggregated selection of "latest_decks"
"""
type latest_decks_aggregate {
  aggregate: latest_decks_aggregate_fields
  nodes: [latest_decks!]!
}

input latest_decks_aggregate_bool_exp {
  count: latest_decks_aggregate_bool_exp_count
}

input latest_decks_aggregate_bool_exp_count {
  arguments: [latest_decks_select_column!]
  distinct: Boolean
  filter: latest_decks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "latest_decks"
"""
type latest_decks_aggregate_fields {
  avg: latest_decks_avg_fields
  count(columns: [latest_decks_select_column!], distinct: Boolean): Int!
  max: latest_decks_max_fields
  min: latest_decks_min_fields
  stddev: latest_decks_stddev_fields
  stddev_pop: latest_decks_stddev_pop_fields
  stddev_samp: latest_decks_stddev_samp_fields
  sum: latest_decks_sum_fields
  var_pop: latest_decks_var_pop_fields
  var_samp: latest_decks_var_samp_fields
  variance: latest_decks_variance_fields
}

"""
order by aggregate values of table "latest_decks"
"""
input latest_decks_aggregate_order_by {
  avg: latest_decks_avg_order_by
  count: order_by
  max: latest_decks_max_order_by
  min: latest_decks_min_order_by
  stddev: latest_decks_stddev_order_by
  stddev_pop: latest_decks_stddev_pop_order_by
  stddev_samp: latest_decks_stddev_samp_order_by
  sum: latest_decks_sum_order_by
  var_pop: latest_decks_var_pop_order_by
  var_samp: latest_decks_var_samp_order_by
  variance: latest_decks_variance_order_by
}

"""
input type for inserting array relation for remote table "latest_decks"
"""
input latest_decks_arr_rel_insert_input {
  data: [latest_decks_insert_input!]!
}

"""aggregate avg on columns"""
type latest_decks_avg_fields {
  campaign_id: Float
  id: Float
}

"""
order by avg() on columns of table "latest_decks"
"""
input latest_decks_avg_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "latest_decks". All fields are combined with a logical 'AND'.
"""
input latest_decks_bool_exp {
  _and: [latest_decks_bool_exp!]
  _not: latest_decks_bool_exp
  _or: [latest_decks_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  deck: campaign_deck_bool_exp
  id: Int_comparison_exp
  owner_id: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "latest_decks"
"""
input latest_decks_inc_input {
  campaign_id: Int
  id: Int
}

"""
input type for inserting data into table "latest_decks"
"""
input latest_decks_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  deck: campaign_deck_obj_rel_insert_input
  id: Int
  owner_id: String
}

"""aggregate max on columns"""
type latest_decks_max_fields {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""
order by max() on columns of table "latest_decks"
"""
input latest_decks_max_order_by {
  campaign_id: order_by
  id: order_by
  owner_id: order_by
}

"""aggregate min on columns"""
type latest_decks_min_fields {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""
order by min() on columns of table "latest_decks"
"""
input latest_decks_min_order_by {
  campaign_id: order_by
  id: order_by
  owner_id: order_by
}

"""
response of any mutation on the table "latest_decks"
"""
type latest_decks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [latest_decks!]!
}

"""Ordering options when selecting data from "latest_decks"."""
input latest_decks_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  deck: campaign_deck_order_by
  id: order_by
  owner_id: order_by
}

"""
select columns of table "latest_decks"
"""
enum latest_decks_select_column {
  """column name"""
  campaign_id

  """column name"""
  id

  """column name"""
  owner_id
}

"""
input type for updating data in table "latest_decks"
"""
input latest_decks_set_input {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""aggregate stddev on columns"""
type latest_decks_stddev_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev() on columns of table "latest_decks"
"""
input latest_decks_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type latest_decks_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "latest_decks"
"""
input latest_decks_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type latest_decks_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "latest_decks"
"""
input latest_decks_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "latest_decks"
"""
input latest_decks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: latest_decks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input latest_decks_stream_cursor_value_input {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""aggregate sum on columns"""
type latest_decks_sum_fields {
  campaign_id: Int
  id: Int
}

"""
order by sum() on columns of table "latest_decks"
"""
input latest_decks_sum_order_by {
  campaign_id: order_by
  id: order_by
}

input latest_decks_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: latest_decks_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: latest_decks_set_input

  """filter the rows which have to be updated"""
  where: latest_decks_bool_exp!
}

"""aggregate var_pop on columns"""
type latest_decks_var_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "latest_decks"
"""
input latest_decks_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type latest_decks_var_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "latest_decks"
"""
input latest_decks_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type latest_decks_variance_fields {
  campaign_id: Float
  id: Float
}

"""
order by variance() on columns of table "latest_decks"
"""
input latest_decks_variance_order_by {
  campaign_id: order_by
  id: order_by
}

"""
columns and relationships of "local_decks"
"""
type local_decks {
  """An object relationship"""
  campaign: campaign
  campaign_id: Int

  """An object relationship"""
  deck: campaign_deck
  id: Int
  owner_id: String
}

"""
aggregated selection of "local_decks"
"""
type local_decks_aggregate {
  aggregate: local_decks_aggregate_fields
  nodes: [local_decks!]!
}

input local_decks_aggregate_bool_exp {
  count: local_decks_aggregate_bool_exp_count
}

input local_decks_aggregate_bool_exp_count {
  arguments: [local_decks_select_column!]
  distinct: Boolean
  filter: local_decks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "local_decks"
"""
type local_decks_aggregate_fields {
  avg: local_decks_avg_fields
  count(columns: [local_decks_select_column!], distinct: Boolean): Int!
  max: local_decks_max_fields
  min: local_decks_min_fields
  stddev: local_decks_stddev_fields
  stddev_pop: local_decks_stddev_pop_fields
  stddev_samp: local_decks_stddev_samp_fields
  sum: local_decks_sum_fields
  var_pop: local_decks_var_pop_fields
  var_samp: local_decks_var_samp_fields
  variance: local_decks_variance_fields
}

"""
order by aggregate values of table "local_decks"
"""
input local_decks_aggregate_order_by {
  avg: local_decks_avg_order_by
  count: order_by
  max: local_decks_max_order_by
  min: local_decks_min_order_by
  stddev: local_decks_stddev_order_by
  stddev_pop: local_decks_stddev_pop_order_by
  stddev_samp: local_decks_stddev_samp_order_by
  sum: local_decks_sum_order_by
  var_pop: local_decks_var_pop_order_by
  var_samp: local_decks_var_samp_order_by
  variance: local_decks_variance_order_by
}

"""
input type for inserting array relation for remote table "local_decks"
"""
input local_decks_arr_rel_insert_input {
  data: [local_decks_insert_input!]!
}

"""aggregate avg on columns"""
type local_decks_avg_fields {
  campaign_id: Float
  id: Float
}

"""
order by avg() on columns of table "local_decks"
"""
input local_decks_avg_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "local_decks". All fields are combined with a logical 'AND'.
"""
input local_decks_bool_exp {
  _and: [local_decks_bool_exp!]
  _not: local_decks_bool_exp
  _or: [local_decks_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  deck: campaign_deck_bool_exp
  id: Int_comparison_exp
  owner_id: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "local_decks"
"""
input local_decks_inc_input {
  campaign_id: Int
  id: Int
}

"""
input type for inserting data into table "local_decks"
"""
input local_decks_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  deck: campaign_deck_obj_rel_insert_input
  id: Int
  owner_id: String
}

"""aggregate max on columns"""
type local_decks_max_fields {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""
order by max() on columns of table "local_decks"
"""
input local_decks_max_order_by {
  campaign_id: order_by
  id: order_by
  owner_id: order_by
}

"""aggregate min on columns"""
type local_decks_min_fields {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""
order by min() on columns of table "local_decks"
"""
input local_decks_min_order_by {
  campaign_id: order_by
  id: order_by
  owner_id: order_by
}

"""
response of any mutation on the table "local_decks"
"""
type local_decks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [local_decks!]!
}

"""Ordering options when selecting data from "local_decks"."""
input local_decks_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  deck: campaign_deck_order_by
  id: order_by
  owner_id: order_by
}

"""
select columns of table "local_decks"
"""
enum local_decks_select_column {
  """column name"""
  campaign_id

  """column name"""
  id

  """column name"""
  owner_id
}

"""
input type for updating data in table "local_decks"
"""
input local_decks_set_input {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""aggregate stddev on columns"""
type local_decks_stddev_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev() on columns of table "local_decks"
"""
input local_decks_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type local_decks_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "local_decks"
"""
input local_decks_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type local_decks_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "local_decks"
"""
input local_decks_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "local_decks"
"""
input local_decks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: local_decks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input local_decks_stream_cursor_value_input {
  campaign_id: Int
  id: Int
  owner_id: String
}

"""aggregate sum on columns"""
type local_decks_sum_fields {
  campaign_id: Int
  id: Int
}

"""
order by sum() on columns of table "local_decks"
"""
input local_decks_sum_order_by {
  campaign_id: order_by
  id: order_by
}

input local_decks_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: local_decks_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: local_decks_set_input

  """filter the rows which have to be updated"""
  where: local_decks_bool_exp!
}

"""aggregate var_pop on columns"""
type local_decks_var_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "local_decks"
"""
input local_decks_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type local_decks_var_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "local_decks"
"""
input local_decks_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type local_decks_variance_fields {
  campaign_id: Float
  id: Float
}

"""
order by variance() on columns of table "local_decks"
"""
input local_decks_variance_order_by {
  campaign_id: order_by
  id: order_by
}

"""mutation root"""
type mutation_root {
  apiDeleteArkhamDbDeck(args: DeleteDeckInput!): DeleteDeckOutput

  """
  execute VOLATILE function "conquest.publish_deck" which returns "conquest.deck"
  """
  conquest_publish_deck(
    """
    input parameters for function "conquest_publish_deck"
    """
    args: conquest_publish_deck_args!

    """distinct select on columns"""
    distinct_on: [conquest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_order_by!]

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): conquest_deck
  createArkhamDbDeck(args: CreateDeckInput!): CreateDeckOutput
  createCampaign(args: CreateCampaignInput!): CreateCampaignOutput
  deleteCampaign(args: DeleteCampaignInput!): DeleteCampaignOutput

  """
  delete data from the table: "all_card"
  """
  delete_all_card(
    """filter the rows which have to be deleted"""
    where: all_card_bool_exp!
  ): all_card_mutation_response

  """
  delete single row from the table: "all_card"
  """
  delete_all_card_by_pk(id: String!): all_card

  """
  delete data from the table: "all_card_text"
  """
  delete_all_card_text(
    """filter the rows which have to be deleted"""
    where: all_card_text_bool_exp!
  ): all_card_text_mutation_response

  """
  delete single row from the table: "all_card_text"
  """
  delete_all_card_text_by_pk(id: String!, locale: String!): all_card_text

  """
  delete data from the table: "all_card_updated"
  """
  delete_all_card_updated(
    """filter the rows which have to be deleted"""
    where: all_card_updated_bool_exp!
  ): all_card_updated_mutation_response

  """
  delete single row from the table: "all_card_updated"
  """
  delete_all_card_updated_by_pk(locale: String!): all_card_updated

  """
  delete data from the table: "all_card_updated_by_version"
  """
  delete_all_card_updated_by_version(
    """filter the rows which have to be deleted"""
    where: all_card_updated_by_version_bool_exp!
  ): all_card_updated_by_version_mutation_response

  """
  delete single row from the table: "all_card_updated_by_version"
  """
  delete_all_card_updated_by_version_by_pk(locale: String!, version: Int!): all_card_updated_by_version

  """
  delete data from the table: "arkhamdb_auth"
  """
  delete_arkhamdb_auth(
    """filter the rows which have to be deleted"""
    where: arkhamdb_auth_bool_exp!
  ): arkhamdb_auth_mutation_response

  """
  delete single row from the table: "arkhamdb_auth"
  """
  delete_arkhamdb_auth_by_pk(user_id: String!): arkhamdb_auth

  """
  delete data from the table: "arkhamdb_deck"
  """
  delete_arkhamdb_deck(
    """filter the rows which have to be deleted"""
    where: arkhamdb_deck_bool_exp!
  ): arkhamdb_deck_mutation_response

  """
  delete single row from the table: "arkhamdb_deck"
  """
  delete_arkhamdb_deck_by_pk(id: Int!): arkhamdb_deck

  """
  delete data from the table: "base_decks"
  """
  delete_base_decks(
    """filter the rows which have to be deleted"""
    where: base_decks_bool_exp!
  ): base_decks_mutation_response

  """
  delete data from the table: "campaign"
  """
  delete_campaign(
    """filter the rows which have to be deleted"""
    where: campaign_bool_exp!
  ): campaign_mutation_response

  """
  delete data from the table: "campaign_access"
  """
  delete_campaign_access(
    """filter the rows which have to be deleted"""
    where: campaign_access_bool_exp!
  ): campaign_access_mutation_response

  """
  delete single row from the table: "campaign_access"
  """
  delete_campaign_access_by_pk(id: Int!): campaign_access

  """
  delete single row from the table: "campaign"
  """
  delete_campaign_by_pk(id: Int!): campaign

  """
  delete data from the table: "campaign_deck"
  """
  delete_campaign_deck(
    """filter the rows which have to be deleted"""
    where: campaign_deck_bool_exp!
  ): campaign_deck_mutation_response

  """
  delete single row from the table: "campaign_deck"
  """
  delete_campaign_deck_by_pk(id: Int!): campaign_deck

  """
  delete data from the table: "campaign_difficulty"
  """
  delete_campaign_difficulty(
    """filter the rows which have to be deleted"""
    where: campaign_difficulty_bool_exp!
  ): campaign_difficulty_mutation_response

  """
  delete single row from the table: "campaign_difficulty"
  """
  delete_campaign_difficulty_by_pk(value: String!): campaign_difficulty

  """
  delete data from the table: "campaign_guide"
  """
  delete_campaign_guide(
    """filter the rows which have to be deleted"""
    where: campaign_guide_bool_exp!
  ): campaign_guide_mutation_response

  """
  delete data from the table: "campaign_investigator"
  """
  delete_campaign_investigator(
    """filter the rows which have to be deleted"""
    where: campaign_investigator_bool_exp!
  ): campaign_investigator_mutation_response

  """
  delete single row from the table: "campaign_investigator"
  """
  delete_campaign_investigator_by_pk(campaign_id: Int!, investigator: String!): campaign_investigator

  """
  delete data from the table: "card"
  """
  delete_card(
    """filter the rows which have to be deleted"""
    where: card_bool_exp!
  ): card_mutation_response

  """
  delete single row from the table: "card"
  """
  delete_card_by_pk(code: String!): card

  """
  delete data from the table: "card_cycle"
  """
  delete_card_cycle(
    """filter the rows which have to be deleted"""
    where: card_cycle_bool_exp!
  ): card_cycle_mutation_response

  """
  delete single row from the table: "card_cycle"
  """
  delete_card_cycle_by_pk(code: String!, locale: String!): card_cycle

  """
  delete data from the table: "card_encounter_set"
  """
  delete_card_encounter_set(
    """filter the rows which have to be deleted"""
    where: card_encounter_set_bool_exp!
  ): card_encounter_set_mutation_response

  """
  delete single row from the table: "card_encounter_set"
  """
  delete_card_encounter_set_by_pk(code: String!, locale: String!): card_encounter_set

  """
  delete data from the table: "card_pack"
  """
  delete_card_pack(
    """filter the rows which have to be deleted"""
    where: card_pack_bool_exp!
  ): card_pack_mutation_response

  """
  delete single row from the table: "card_pack"
  """
  delete_card_pack_by_pk(code: String!, locale: String!): card_pack

  """
  delete data from the table: "card_subtype_name"
  """
  delete_card_subtype_name(
    """filter the rows which have to be deleted"""
    where: card_subtype_name_bool_exp!
  ): card_subtype_name_mutation_response

  """
  delete single row from the table: "card_subtype_name"
  """
  delete_card_subtype_name_by_pk(code: String!, locale: String!): card_subtype_name

  """
  delete data from the table: "card_text"
  """
  delete_card_text(
    """filter the rows which have to be deleted"""
    where: card_text_bool_exp!
  ): card_text_mutation_response

  """
  delete single row from the table: "card_text"
  """
  delete_card_text_by_pk(code: String!, locale: String!): card_text

  """
  delete data from the table: "card_type_code"
  """
  delete_card_type_code(
    """filter the rows which have to be deleted"""
    where: card_type_code_bool_exp!
  ): card_type_code_mutation_response

  """
  delete single row from the table: "card_type_code"
  """
  delete_card_type_code_by_pk(code: String!): card_type_code

  """
  delete data from the table: "card_type_name"
  """
  delete_card_type_name(
    """filter the rows which have to be deleted"""
    where: card_type_name_bool_exp!
  ): card_type_name_mutation_response

  """
  delete single row from the table: "card_type_name"
  """
  delete_card_type_name_by_pk(code: card_type_code_enum!, locale: String!): card_type_name

  """
  delete data from the table: "chaos_bag_result"
  """
  delete_chaos_bag_result(
    """filter the rows which have to be deleted"""
    where: chaos_bag_result_bool_exp!
  ): chaos_bag_result_mutation_response

  """
  delete single row from the table: "chaos_bag_result"
  """
  delete_chaos_bag_result_by_pk(id: Int!): chaos_bag_result

  """
  delete data from the table: "chaos_bag_tarot_mode"
  """
  delete_chaos_bag_tarot_mode(
    """filter the rows which have to be deleted"""
    where: chaos_bag_tarot_mode_bool_exp!
  ): chaos_bag_tarot_mode_mutation_response

  """
  delete single row from the table: "chaos_bag_tarot_mode"
  """
  delete_chaos_bag_tarot_mode_by_pk(value: String!): chaos_bag_tarot_mode

  """
  delete data from the table: "conquest.card"
  """
  delete_conquest_card(
    """filter the rows which have to be deleted"""
    where: conquest_card_bool_exp!
  ): conquest_card_mutation_response

  """
  delete single row from the table: "conquest.card"
  """
  delete_conquest_card_by_pk(id: String!): conquest_card

  """
  delete data from the table: "conquest.card_text"
  """
  delete_conquest_card_text(
    """filter the rows which have to be deleted"""
    where: conquest_card_text_bool_exp!
  ): conquest_card_text_mutation_response

  """
  delete single row from the table: "conquest.card_text"
  """
  delete_conquest_card_text_by_pk(id: String!, locale: String!): conquest_card_text

  """
  delete data from the table: "conquest.comment"
  """
  delete_conquest_comment(
    """filter the rows which have to be deleted"""
    where: conquest_comment_bool_exp!
  ): conquest_comment_mutation_response

  """
  delete single row from the table: "conquest.comment"
  """
  delete_conquest_comment_by_pk(id: uuid!): conquest_comment

  """
  delete data from the table: "conquest.cycle"
  """
  delete_conquest_cycle(
    """filter the rows which have to be deleted"""
    where: conquest_cycle_bool_exp!
  ): conquest_cycle_mutation_response

  """
  delete single row from the table: "conquest.cycle"
  """
  delete_conquest_cycle_by_pk(id: String!): conquest_cycle

  """
  delete data from the table: "conquest.cycle_text"
  """
  delete_conquest_cycle_text(
    """filter the rows which have to be deleted"""
    where: conquest_cycle_text_bool_exp!
  ): conquest_cycle_text_mutation_response

  """
  delete single row from the table: "conquest.cycle_text"
  """
  delete_conquest_cycle_text_by_pk(id: String!, locale: String!): conquest_cycle_text

  """
  delete data from the table: "conquest.deck"
  """
  delete_conquest_deck(
    """filter the rows which have to be deleted"""
    where: conquest_deck_bool_exp!
  ): conquest_deck_mutation_response

  """
  delete single row from the table: "conquest.deck"
  """
  delete_conquest_deck_by_pk(id: Int!): conquest_deck

  """
  delete data from the table: "conquest.deck_copy"
  """
  delete_conquest_deck_copy(
    """filter the rows which have to be deleted"""
    where: conquest_deck_copy_bool_exp!
  ): conquest_deck_copy_mutation_response

  """
  delete single row from the table: "conquest.deck_copy"
  """
  delete_conquest_deck_copy_by_pk(copy_deck_id: Int!): conquest_deck_copy

  """
  delete data from the table: "conquest.deck_like"
  """
  delete_conquest_deck_like(
    """filter the rows which have to be deleted"""
    where: conquest_deck_like_bool_exp!
  ): conquest_deck_like_mutation_response

  """
  delete single row from the table: "conquest.deck_like"
  """
  delete_conquest_deck_like_by_pk(deck_id: Int!, user_id: String!): conquest_deck_like

  """
  delete data from the table: "conquest.faction"
  """
  delete_conquest_faction(
    """filter the rows which have to be deleted"""
    where: conquest_faction_bool_exp!
  ): conquest_faction_mutation_response

  """
  delete single row from the table: "conquest.faction"
  """
  delete_conquest_faction_by_pk(id: String!): conquest_faction

  """
  delete data from the table: "conquest.faction_text"
  """
  delete_conquest_faction_text(
    """filter the rows which have to be deleted"""
    where: conquest_faction_text_bool_exp!
  ): conquest_faction_text_mutation_response

  """
  delete single row from the table: "conquest.faction_text"
  """
  delete_conquest_faction_text_by_pk(id: String!, locale: String!): conquest_faction_text

  """
  delete data from the table: "conquest.loyalty"
  """
  delete_conquest_loyalty(
    """filter the rows which have to be deleted"""
    where: conquest_loyalty_bool_exp!
  ): conquest_loyalty_mutation_response

  """
  delete single row from the table: "conquest.loyalty"
  """
  delete_conquest_loyalty_by_pk(id: String!): conquest_loyalty

  """
  delete data from the table: "conquest.loyalty_text"
  """
  delete_conquest_loyalty_text(
    """filter the rows which have to be deleted"""
    where: conquest_loyalty_text_bool_exp!
  ): conquest_loyalty_text_mutation_response

  """
  delete single row from the table: "conquest.loyalty_text"
  """
  delete_conquest_loyalty_text_by_pk(id: String!, locale: String!): conquest_loyalty_text

  """
  delete data from the table: "conquest.pack"
  """
  delete_conquest_pack(
    """filter the rows which have to be deleted"""
    where: conquest_pack_bool_exp!
  ): conquest_pack_mutation_response

  """
  delete single row from the table: "conquest.pack"
  """
  delete_conquest_pack_by_pk(id: String!): conquest_pack

  """
  delete data from the table: "conquest.pack_text"
  """
  delete_conquest_pack_text(
    """filter the rows which have to be deleted"""
    where: conquest_pack_text_bool_exp!
  ): conquest_pack_text_mutation_response

  """
  delete single row from the table: "conquest.pack_text"
  """
  delete_conquest_pack_text_by_pk(id: String!, locale: String!): conquest_pack_text

  """
  delete data from the table: "conquest.type"
  """
  delete_conquest_type(
    """filter the rows which have to be deleted"""
    where: conquest_type_bool_exp!
  ): conquest_type_mutation_response

  """
  delete single row from the table: "conquest.type"
  """
  delete_conquest_type_by_pk(id: String!): conquest_type

  """
  delete data from the table: "conquest.type_text"
  """
  delete_conquest_type_text(
    """filter the rows which have to be deleted"""
    where: conquest_type_text_bool_exp!
  ): conquest_type_text_mutation_response

  """
  delete single row from the table: "conquest.type_text"
  """
  delete_conquest_type_text_by_pk(id: String!, locale: String!): conquest_type_text

  """
  delete data from the table: "conquest.user_role"
  """
  delete_conquest_user_role(
    """filter the rows which have to be deleted"""
    where: conquest_user_role_bool_exp!
  ): conquest_user_role_mutation_response

  """
  delete single row from the table: "conquest.user_role"
  """
  delete_conquest_user_role_by_pk(id: String!): conquest_user_role

  """
  delete data from the table: "conquest.user_settings"
  """
  delete_conquest_user_settings(
    """filter the rows which have to be deleted"""
    where: conquest_user_settings_bool_exp!
  ): conquest_user_settings_mutation_response

  """
  delete single row from the table: "conquest.user_settings"
  """
  delete_conquest_user_settings_by_pk(user_id: String!): conquest_user_settings

  """
  delete data from the table: "conquest.users"
  """
  delete_conquest_users(
    """filter the rows which have to be deleted"""
    where: conquest_users_bool_exp!
  ): conquest_users_mutation_response

  """
  delete single row from the table: "conquest.users"
  """
  delete_conquest_users_by_pk(id: String!): conquest_users

  """
  delete data from the table: "cycle"
  """
  delete_cycle(
    """filter the rows which have to be deleted"""
    where: cycle_bool_exp!
  ): cycle_mutation_response

  """
  delete single row from the table: "cycle"
  """
  delete_cycle_by_pk(code: String!): cycle

  """
  delete data from the table: "cycle_name"
  """
  delete_cycle_name(
    """filter the rows which have to be deleted"""
    where: cycle_name_bool_exp!
  ): cycle_name_mutation_response

  """
  delete single row from the table: "cycle_name"
  """
  delete_cycle_name_by_pk(code: String!, locale: String!): cycle_name

  """
  delete data from the table: "faction_name"
  """
  delete_faction_name(
    """filter the rows which have to be deleted"""
    where: faction_name_bool_exp!
  ): faction_name_mutation_response

  """
  delete single row from the table: "faction_name"
  """
  delete_faction_name_by_pk(code: String!, locale: String!): faction_name

  """
  delete data from the table: "faq"
  """
  delete_faq(
    """filter the rows which have to be deleted"""
    where: faq_bool_exp!
  ): faq_mutation_response

  """
  delete single row from the table: "faq"
  """
  delete_faq_by_pk(code: String!): faq

  """
  delete data from the table: "faq_text"
  """
  delete_faq_text(
    """filter the rows which have to be deleted"""
    where: faq_text_bool_exp!
  ): faq_text_mutation_response

  """
  delete single row from the table: "faq_text"
  """
  delete_faq_text_by_pk(code: String!, locale: String!): faq_text

  """
  delete data from the table: "friend_status"
  """
  delete_friend_status(
    """filter the rows which have to be deleted"""
    where: friend_status_bool_exp!
  ): friend_status_mutation_response

  """
  delete single row from the table: "friend_status"
  """
  delete_friend_status_by_pk(user_id_a: String!, user_id_b: String!): friend_status

  """
  delete data from the table: "friend_status_type"
  """
  delete_friend_status_type(
    """filter the rows which have to be deleted"""
    where: friend_status_type_bool_exp!
  ): friend_status_type_mutation_response

  """
  delete single row from the table: "friend_status_type"
  """
  delete_friend_status_type_by_pk(value: String!): friend_status_type

  """
  delete data from the table: "full_card"
  """
  delete_full_card(
    """filter the rows which have to be deleted"""
    where: full_card_bool_exp!
  ): full_card_mutation_response

  """
  delete single row from the table: "full_card"
  """
  delete_full_card_by_pk(code: String!): full_card

  """
  delete data from the table: "full_card_text"
  """
  delete_full_card_text(
    """filter the rows which have to be deleted"""
    where: full_card_text_bool_exp!
  ): full_card_text_mutation_response

  """
  delete single row from the table: "full_card_text"
  """
  delete_full_card_text_by_pk(code: String!, locale: String!): full_card_text

  """
  delete data from the table: "gender"
  """
  delete_gender(
    """filter the rows which have to be deleted"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  delete single row from the table: "gender"
  """
  delete_gender_by_pk(code: String!): gender

  """
  delete data from the table: "guide_achievement"
  """
  delete_guide_achievement(
    """filter the rows which have to be deleted"""
    where: guide_achievement_bool_exp!
  ): guide_achievement_mutation_response

  """
  delete single row from the table: "guide_achievement"
  """
  delete_guide_achievement_by_pk(campaign_id: Int!, id: String!): guide_achievement

  """
  delete data from the table: "guide_input"
  """
  delete_guide_input(
    """filter the rows which have to be deleted"""
    where: guide_input_bool_exp!
  ): guide_input_mutation_response

  """
  delete single row from the table: "guide_input"
  """
  delete_guide_input_by_pk(campaign_id: Int!, id: String!): guide_input

  """
  delete data from the table: "investigator_data"
  """
  delete_investigator_data(
    """filter the rows which have to be deleted"""
    where: investigator_data_bool_exp!
  ): investigator_data_mutation_response

  """
  delete single row from the table: "investigator_data"
  """
  delete_investigator_data_by_pk(campaign_id: Int!, investigator: String!): investigator_data

  """
  delete data from the table: "latest_decks"
  """
  delete_latest_decks(
    """filter the rows which have to be deleted"""
    where: latest_decks_bool_exp!
  ): latest_decks_mutation_response

  """
  delete data from the table: "local_decks"
  """
  delete_local_decks(
    """filter the rows which have to be deleted"""
    where: local_decks_bool_exp!
  ): local_decks_mutation_response

  """
  delete data from the table: "pack"
  """
  delete_pack(
    """filter the rows which have to be deleted"""
    where: pack_bool_exp!
  ): pack_mutation_response

  """
  delete single row from the table: "pack"
  """
  delete_pack_by_pk(code: String!): pack

  """
  delete data from the table: "pack_name"
  """
  delete_pack_name(
    """filter the rows which have to be deleted"""
    where: pack_name_bool_exp!
  ): pack_name_mutation_response

  """
  delete single row from the table: "pack_name"
  """
  delete_pack_name_by_pk(code: String!, locale: String!): pack_name

  """
  delete data from the table: "rangers.area"
  """
  delete_rangers_area(
    """filter the rows which have to be deleted"""
    where: rangers_area_bool_exp!
  ): rangers_area_mutation_response

  """
  delete single row from the table: "rangers.area"
  """
  delete_rangers_area_by_pk(id: String!): rangers_area

  """
  delete data from the table: "rangers.area_text"
  """
  delete_rangers_area_text(
    """filter the rows which have to be deleted"""
    where: rangers_area_text_bool_exp!
  ): rangers_area_text_mutation_response

  """
  delete single row from the table: "rangers.area_text"
  """
  delete_rangers_area_text_by_pk(id: String!, locale: String!): rangers_area_text

  """
  delete data from the table: "rangers.aspect"
  """
  delete_rangers_aspect(
    """filter the rows which have to be deleted"""
    where: rangers_aspect_bool_exp!
  ): rangers_aspect_mutation_response

  """
  delete single row from the table: "rangers.aspect"
  """
  delete_rangers_aspect_by_pk(id: String!): rangers_aspect

  """
  delete data from the table: "rangers.aspect_text"
  """
  delete_rangers_aspect_text(
    """filter the rows which have to be deleted"""
    where: rangers_aspect_text_bool_exp!
  ): rangers_aspect_text_mutation_response

  """
  delete single row from the table: "rangers.aspect_text"
  """
  delete_rangers_aspect_text_by_pk(id: String!, locale: String!): rangers_aspect_text

  """
  delete data from the table: "rangers.campaign"
  """
  delete_rangers_campaign(
    """filter the rows which have to be deleted"""
    where: rangers_campaign_bool_exp!
  ): rangers_campaign_mutation_response

  """
  delete data from the table: "rangers.campaign_access"
  """
  delete_rangers_campaign_access(
    """filter the rows which have to be deleted"""
    where: rangers_campaign_access_bool_exp!
  ): rangers_campaign_access_mutation_response

  """
  delete single row from the table: "rangers.campaign_access"
  """
  delete_rangers_campaign_access_by_pk(campaign_id: Int!, user_id: String!): rangers_campaign_access

  """
  delete single row from the table: "rangers.campaign"
  """
  delete_rangers_campaign_by_pk(id: Int!): rangers_campaign

  """
  delete data from the table: "rangers.card"
  """
  delete_rangers_card(
    """filter the rows which have to be deleted"""
    where: rangers_card_bool_exp!
  ): rangers_card_mutation_response

  """
  delete single row from the table: "rangers.card"
  """
  delete_rangers_card_by_pk(id: String!): rangers_card

  """
  delete data from the table: "rangers.card_text"
  """
  delete_rangers_card_text(
    """filter the rows which have to be deleted"""
    where: rangers_card_text_bool_exp!
  ): rangers_card_text_mutation_response

  """
  delete single row from the table: "rangers.card_text"
  """
  delete_rangers_card_text_by_pk(id: String!, locale: String!): rangers_card_text

  """
  delete data from the table: "rangers.comment"
  """
  delete_rangers_comment(
    """filter the rows which have to be deleted"""
    where: rangers_comment_bool_exp!
  ): rangers_comment_mutation_response

  """
  delete single row from the table: "rangers.comment"
  """
  delete_rangers_comment_by_pk(id: uuid!): rangers_comment

  """
  delete data from the table: "rangers.deck"
  """
  delete_rangers_deck(
    """filter the rows which have to be deleted"""
    where: rangers_deck_bool_exp!
  ): rangers_deck_mutation_response

  """
  delete single row from the table: "rangers.deck"
  """
  delete_rangers_deck_by_pk(id: Int!): rangers_deck

  """
  delete data from the table: "rangers.deck_copy"
  """
  delete_rangers_deck_copy(
    """filter the rows which have to be deleted"""
    where: rangers_deck_copy_bool_exp!
  ): rangers_deck_copy_mutation_response

  """
  delete single row from the table: "rangers.deck_copy"
  """
  delete_rangers_deck_copy_by_pk(copy_deck_id: Int!): rangers_deck_copy

  """
  delete data from the table: "rangers.deck_like"
  """
  delete_rangers_deck_like(
    """filter the rows which have to be deleted"""
    where: rangers_deck_like_bool_exp!
  ): rangers_deck_like_mutation_response

  """
  delete single row from the table: "rangers.deck_like"
  """
  delete_rangers_deck_like_by_pk(deck_id: Int!, user_id: String!): rangers_deck_like

  """
  delete data from the table: "rangers.deck_like_count"
  """
  delete_rangers_deck_like_count(
    """filter the rows which have to be deleted"""
    where: rangers_deck_like_count_bool_exp!
  ): rangers_deck_like_count_mutation_response

  """
  delete single row from the table: "rangers.deck_like_count"
  """
  delete_rangers_deck_like_count_by_pk(deck_id: Int!): rangers_deck_like_count

  """
  delete data from the table: "rangers.faq_entry"
  """
  delete_rangers_faq_entry(
    """filter the rows which have to be deleted"""
    where: rangers_faq_entry_bool_exp!
  ): rangers_faq_entry_mutation_response

  """
  delete single row from the table: "rangers.faq_entry"
  """
  delete_rangers_faq_entry_by_pk(id: String!): rangers_faq_entry

  """
  delete data from the table: "rangers.friend_status"
  """
  delete_rangers_friend_status(
    """filter the rows which have to be deleted"""
    where: rangers_friend_status_bool_exp!
  ): rangers_friend_status_mutation_response

  """
  delete single row from the table: "rangers.friend_status"
  """
  delete_rangers_friend_status_by_pk(user_id_a: String!, user_id_b: String!): rangers_friend_status

  """
  delete data from the table: "rangers.friend_status_type"
  """
  delete_rangers_friend_status_type(
    """filter the rows which have to be deleted"""
    where: rangers_friend_status_type_bool_exp!
  ): rangers_friend_status_type_mutation_response

  """
  delete single row from the table: "rangers.friend_status_type"
  """
  delete_rangers_friend_status_type_by_pk(value: String!): rangers_friend_status_type

  """
  delete data from the table: "rangers.latest_deck"
  """
  delete_rangers_latest_deck(
    """filter the rows which have to be deleted"""
    where: rangers_latest_deck_bool_exp!
  ): rangers_latest_deck_mutation_response

  """
  delete data from the table: "rangers.locale"
  """
  delete_rangers_locale(
    """filter the rows which have to be deleted"""
    where: rangers_locale_bool_exp!
  ): rangers_locale_mutation_response

  """
  delete single row from the table: "rangers.locale"
  """
  delete_rangers_locale_by_pk(locale: String!): rangers_locale

  """
  delete data from the table: "rangers.pack"
  """
  delete_rangers_pack(
    """filter the rows which have to be deleted"""
    where: rangers_pack_bool_exp!
  ): rangers_pack_mutation_response

  """
  delete single row from the table: "rangers.pack"
  """
  delete_rangers_pack_by_pk(id: String!): rangers_pack

  """
  delete data from the table: "rangers.pack_text"
  """
  delete_rangers_pack_text(
    """filter the rows which have to be deleted"""
    where: rangers_pack_text_bool_exp!
  ): rangers_pack_text_mutation_response

  """
  delete single row from the table: "rangers.pack_text"
  """
  delete_rangers_pack_text_by_pk(id: String!, locale: String!): rangers_pack_text

  """
  delete data from the table: "rangers.search_deck"
  """
  delete_rangers_search_deck(
    """filter the rows which have to be deleted"""
    where: rangers_search_deck_bool_exp!
  ): rangers_search_deck_mutation_response

  """
  delete data from the table: "rangers.set"
  """
  delete_rangers_set(
    """filter the rows which have to be deleted"""
    where: rangers_set_bool_exp!
  ): rangers_set_mutation_response

  """
  delete single row from the table: "rangers.set"
  """
  delete_rangers_set_by_pk(id: String!): rangers_set

  """
  delete data from the table: "rangers.set_text"
  """
  delete_rangers_set_text(
    """filter the rows which have to be deleted"""
    where: rangers_set_text_bool_exp!
  ): rangers_set_text_mutation_response

  """
  delete single row from the table: "rangers.set_text"
  """
  delete_rangers_set_text_by_pk(id: String!, locale: String!): rangers_set_text

  """
  delete data from the table: "rangers.set_type"
  """
  delete_rangers_set_type(
    """filter the rows which have to be deleted"""
    where: rangers_set_type_bool_exp!
  ): rangers_set_type_mutation_response

  """
  delete single row from the table: "rangers.set_type"
  """
  delete_rangers_set_type_by_pk(id: String!): rangers_set_type

  """
  delete data from the table: "rangers.set_type_text"
  """
  delete_rangers_set_type_text(
    """filter the rows which have to be deleted"""
    where: rangers_set_type_text_bool_exp!
  ): rangers_set_type_text_mutation_response

  """
  delete single row from the table: "rangers.set_type_text"
  """
  delete_rangers_set_type_text_by_pk(id: String!, locale: String!): rangers_set_type_text

  """
  delete data from the table: "rangers.subset"
  """
  delete_rangers_subset(
    """filter the rows which have to be deleted"""
    where: rangers_subset_bool_exp!
  ): rangers_subset_mutation_response

  """
  delete single row from the table: "rangers.subset"
  """
  delete_rangers_subset_by_pk(id: String!): rangers_subset

  """
  delete data from the table: "rangers.subset_text"
  """
  delete_rangers_subset_text(
    """filter the rows which have to be deleted"""
    where: rangers_subset_text_bool_exp!
  ): rangers_subset_text_mutation_response

  """
  delete single row from the table: "rangers.subset_text"
  """
  delete_rangers_subset_text_by_pk(id: String!, locale: String!): rangers_subset_text

  """
  delete data from the table: "rangers.taboo_set"
  """
  delete_rangers_taboo_set(
    """filter the rows which have to be deleted"""
    where: rangers_taboo_set_bool_exp!
  ): rangers_taboo_set_mutation_response

  """
  delete single row from the table: "rangers.taboo_set"
  """
  delete_rangers_taboo_set_by_pk(id: String!): rangers_taboo_set

  """
  delete data from the table: "rangers.taboo_set_text"
  """
  delete_rangers_taboo_set_text(
    """filter the rows which have to be deleted"""
    where: rangers_taboo_set_text_bool_exp!
  ): rangers_taboo_set_text_mutation_response

  """
  delete single row from the table: "rangers.taboo_set_text"
  """
  delete_rangers_taboo_set_text_by_pk(id: String!, locale: String!): rangers_taboo_set_text

  """
  delete data from the table: "rangers.token"
  """
  delete_rangers_token(
    """filter the rows which have to be deleted"""
    where: rangers_token_bool_exp!
  ): rangers_token_mutation_response

  """
  delete single row from the table: "rangers.token"
  """
  delete_rangers_token_by_pk(id: String!): rangers_token

  """
  delete data from the table: "rangers.token_text"
  """
  delete_rangers_token_text(
    """filter the rows which have to be deleted"""
    where: rangers_token_text_bool_exp!
  ): rangers_token_text_mutation_response

  """
  delete single row from the table: "rangers.token_text"
  """
  delete_rangers_token_text_by_pk(id: String!, locale: String!): rangers_token_text

  """
  delete data from the table: "rangers.type"
  """
  delete_rangers_type(
    """filter the rows which have to be deleted"""
    where: rangers_type_bool_exp!
  ): rangers_type_mutation_response

  """
  delete single row from the table: "rangers.type"
  """
  delete_rangers_type_by_pk(id: String!): rangers_type

  """
  delete data from the table: "rangers.type_text"
  """
  delete_rangers_type_text(
    """filter the rows which have to be deleted"""
    where: rangers_type_text_bool_exp!
  ): rangers_type_text_mutation_response

  """
  delete single row from the table: "rangers.type_text"
  """
  delete_rangers_type_text_by_pk(id: String!, locale: String!): rangers_type_text

  """
  delete data from the table: "rangers.user_friends"
  """
  delete_rangers_user_friends(
    """filter the rows which have to be deleted"""
    where: rangers_user_friends_bool_exp!
  ): rangers_user_friends_mutation_response

  """
  delete data from the table: "rangers.user_received_friend_requests"
  """
  delete_rangers_user_received_friend_requests(
    """filter the rows which have to be deleted"""
    where: rangers_user_received_friend_requests_bool_exp!
  ): rangers_user_received_friend_requests_mutation_response

  """
  delete data from the table: "rangers.user_role"
  """
  delete_rangers_user_role(
    """filter the rows which have to be deleted"""
    where: rangers_user_role_bool_exp!
  ): rangers_user_role_mutation_response

  """
  delete single row from the table: "rangers.user_role"
  """
  delete_rangers_user_role_by_pk(id: String!): rangers_user_role

  """
  delete data from the table: "rangers.user_sent_friend_requests"
  """
  delete_rangers_user_sent_friend_requests(
    """filter the rows which have to be deleted"""
    where: rangers_user_sent_friend_requests_bool_exp!
  ): rangers_user_sent_friend_requests_mutation_response

  """
  delete data from the table: "rangers.user_settings"
  """
  delete_rangers_user_settings(
    """filter the rows which have to be deleted"""
    where: rangers_user_settings_bool_exp!
  ): rangers_user_settings_mutation_response

  """
  delete single row from the table: "rangers.user_settings"
  """
  delete_rangers_user_settings_by_pk(user_id: String!): rangers_user_settings

  """
  delete data from the table: "rangers.users"
  """
  delete_rangers_users(
    """filter the rows which have to be deleted"""
    where: rangers_users_bool_exp!
  ): rangers_users_mutation_response

  """
  delete single row from the table: "rangers.users"
  """
  delete_rangers_users_by_pk(id: String!): rangers_users

  """
  delete data from the table: "taboo_set"
  """
  delete_taboo_set(
    """filter the rows which have to be deleted"""
    where: taboo_set_bool_exp!
  ): taboo_set_mutation_response

  """
  delete single row from the table: "taboo_set"
  """
  delete_taboo_set_by_pk(id: Int!): taboo_set

  """
  delete data from the table: "user_campaigns"
  """
  delete_user_campaigns(
    """filter the rows which have to be deleted"""
    where: user_campaigns_bool_exp!
  ): user_campaigns_mutation_response

  """
  delete data from the table: "user_flag"
  """
  delete_user_flag(
    """filter the rows which have to be deleted"""
    where: user_flag_bool_exp!
  ): user_flag_mutation_response

  """
  delete single row from the table: "user_flag"
  """
  delete_user_flag_by_pk(flag: user_flag_type_enum!, user_id: String!): user_flag

  """
  delete data from the table: "user_flag_type"
  """
  delete_user_flag_type(
    """filter the rows which have to be deleted"""
    where: user_flag_type_bool_exp!
  ): user_flag_type_mutation_response

  """
  delete single row from the table: "user_flag_type"
  """
  delete_user_flag_type_by_pk(value: String!): user_flag_type

  """
  delete data from the table: "user_friends"
  """
  delete_user_friends(
    """filter the rows which have to be deleted"""
    where: user_friends_bool_exp!
  ): user_friends_mutation_response

  """
  delete data from the table: "user_received_friend_requests"
  """
  delete_user_received_friend_requests(
    """filter the rows which have to be deleted"""
    where: user_received_friend_requests_bool_exp!
  ): user_received_friend_requests_mutation_response

  """
  delete data from the table: "user_sent_friend_requests"
  """
  delete_user_sent_friend_requests(
    """filter the rows which have to be deleted"""
    where: user_sent_friend_requests_bool_exp!
  ): user_sent_friend_requests_mutation_response

  """
  delete data from the table: "user_settings"
  """
  delete_user_settings(
    """filter the rows which have to be deleted"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  delete single row from the table: "user_settings"
  """
  delete_user_settings_by_pk(user_id: String!): user_settings

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: String!): users
  editCampaignAccess(args: EditCampaignAccessInput!): EditCampaignAccessOutput

  """
  insert data into the table: "all_card"
  """
  insert_all_card(
    """the rows to be inserted"""
    objects: [all_card_insert_input!]!

    """upsert condition"""
    on_conflict: all_card_on_conflict
  ): all_card_mutation_response

  """
  insert a single row into the table: "all_card"
  """
  insert_all_card_one(
    """the row to be inserted"""
    object: all_card_insert_input!

    """upsert condition"""
    on_conflict: all_card_on_conflict
  ): all_card

  """
  insert data into the table: "all_card_text"
  """
  insert_all_card_text(
    """the rows to be inserted"""
    objects: [all_card_text_insert_input!]!

    """upsert condition"""
    on_conflict: all_card_text_on_conflict
  ): all_card_text_mutation_response

  """
  insert a single row into the table: "all_card_text"
  """
  insert_all_card_text_one(
    """the row to be inserted"""
    object: all_card_text_insert_input!

    """upsert condition"""
    on_conflict: all_card_text_on_conflict
  ): all_card_text

  """
  insert data into the table: "all_card_updated"
  """
  insert_all_card_updated(
    """the rows to be inserted"""
    objects: [all_card_updated_insert_input!]!

    """upsert condition"""
    on_conflict: all_card_updated_on_conflict
  ): all_card_updated_mutation_response

  """
  insert data into the table: "all_card_updated_by_version"
  """
  insert_all_card_updated_by_version(
    """the rows to be inserted"""
    objects: [all_card_updated_by_version_insert_input!]!

    """upsert condition"""
    on_conflict: all_card_updated_by_version_on_conflict
  ): all_card_updated_by_version_mutation_response

  """
  insert a single row into the table: "all_card_updated_by_version"
  """
  insert_all_card_updated_by_version_one(
    """the row to be inserted"""
    object: all_card_updated_by_version_insert_input!

    """upsert condition"""
    on_conflict: all_card_updated_by_version_on_conflict
  ): all_card_updated_by_version

  """
  insert a single row into the table: "all_card_updated"
  """
  insert_all_card_updated_one(
    """the row to be inserted"""
    object: all_card_updated_insert_input!

    """upsert condition"""
    on_conflict: all_card_updated_on_conflict
  ): all_card_updated

  """
  insert data into the table: "arkhamdb_auth"
  """
  insert_arkhamdb_auth(
    """the rows to be inserted"""
    objects: [arkhamdb_auth_insert_input!]!

    """upsert condition"""
    on_conflict: arkhamdb_auth_on_conflict
  ): arkhamdb_auth_mutation_response

  """
  insert a single row into the table: "arkhamdb_auth"
  """
  insert_arkhamdb_auth_one(
    """the row to be inserted"""
    object: arkhamdb_auth_insert_input!

    """upsert condition"""
    on_conflict: arkhamdb_auth_on_conflict
  ): arkhamdb_auth

  """
  insert data into the table: "arkhamdb_deck"
  """
  insert_arkhamdb_deck(
    """the rows to be inserted"""
    objects: [arkhamdb_deck_insert_input!]!

    """upsert condition"""
    on_conflict: arkhamdb_deck_on_conflict
  ): arkhamdb_deck_mutation_response

  """
  insert a single row into the table: "arkhamdb_deck"
  """
  insert_arkhamdb_deck_one(
    """the row to be inserted"""
    object: arkhamdb_deck_insert_input!

    """upsert condition"""
    on_conflict: arkhamdb_deck_on_conflict
  ): arkhamdb_deck

  """
  insert data into the table: "base_decks"
  """
  insert_base_decks(
    """the rows to be inserted"""
    objects: [base_decks_insert_input!]!
  ): base_decks_mutation_response

  """
  insert a single row into the table: "base_decks"
  """
  insert_base_decks_one(
    """the row to be inserted"""
    object: base_decks_insert_input!
  ): base_decks

  """
  insert data into the table: "campaign"
  """
  insert_campaign(
    """the rows to be inserted"""
    objects: [campaign_insert_input!]!

    """upsert condition"""
    on_conflict: campaign_on_conflict
  ): campaign_mutation_response

  """
  insert data into the table: "campaign_access"
  """
  insert_campaign_access(
    """the rows to be inserted"""
    objects: [campaign_access_insert_input!]!

    """upsert condition"""
    on_conflict: campaign_access_on_conflict
  ): campaign_access_mutation_response

  """
  insert a single row into the table: "campaign_access"
  """
  insert_campaign_access_one(
    """the row to be inserted"""
    object: campaign_access_insert_input!

    """upsert condition"""
    on_conflict: campaign_access_on_conflict
  ): campaign_access

  """
  insert data into the table: "campaign_deck"
  """
  insert_campaign_deck(
    """the rows to be inserted"""
    objects: [campaign_deck_insert_input!]!

    """upsert condition"""
    on_conflict: campaign_deck_on_conflict
  ): campaign_deck_mutation_response

  """
  insert a single row into the table: "campaign_deck"
  """
  insert_campaign_deck_one(
    """the row to be inserted"""
    object: campaign_deck_insert_input!

    """upsert condition"""
    on_conflict: campaign_deck_on_conflict
  ): campaign_deck

  """
  insert data into the table: "campaign_difficulty"
  """
  insert_campaign_difficulty(
    """the rows to be inserted"""
    objects: [campaign_difficulty_insert_input!]!

    """upsert condition"""
    on_conflict: campaign_difficulty_on_conflict
  ): campaign_difficulty_mutation_response

  """
  insert a single row into the table: "campaign_difficulty"
  """
  insert_campaign_difficulty_one(
    """the row to be inserted"""
    object: campaign_difficulty_insert_input!

    """upsert condition"""
    on_conflict: campaign_difficulty_on_conflict
  ): campaign_difficulty

  """
  insert data into the table: "campaign_guide"
  """
  insert_campaign_guide(
    """the rows to be inserted"""
    objects: [campaign_guide_insert_input!]!
  ): campaign_guide_mutation_response

  """
  insert a single row into the table: "campaign_guide"
  """
  insert_campaign_guide_one(
    """the row to be inserted"""
    object: campaign_guide_insert_input!
  ): campaign_guide

  """
  insert data into the table: "campaign_investigator"
  """
  insert_campaign_investigator(
    """the rows to be inserted"""
    objects: [campaign_investigator_insert_input!]!

    """upsert condition"""
    on_conflict: campaign_investigator_on_conflict
  ): campaign_investigator_mutation_response

  """
  insert a single row into the table: "campaign_investigator"
  """
  insert_campaign_investigator_one(
    """the row to be inserted"""
    object: campaign_investigator_insert_input!

    """upsert condition"""
    on_conflict: campaign_investigator_on_conflict
  ): campaign_investigator

  """
  insert a single row into the table: "campaign"
  """
  insert_campaign_one(
    """the row to be inserted"""
    object: campaign_insert_input!

    """upsert condition"""
    on_conflict: campaign_on_conflict
  ): campaign

  """
  insert data into the table: "card"
  """
  insert_card(
    """the rows to be inserted"""
    objects: [card_insert_input!]!

    """upsert condition"""
    on_conflict: card_on_conflict
  ): card_mutation_response

  """
  insert data into the table: "card_cycle"
  """
  insert_card_cycle(
    """the rows to be inserted"""
    objects: [card_cycle_insert_input!]!

    """upsert condition"""
    on_conflict: card_cycle_on_conflict
  ): card_cycle_mutation_response

  """
  insert a single row into the table: "card_cycle"
  """
  insert_card_cycle_one(
    """the row to be inserted"""
    object: card_cycle_insert_input!

    """upsert condition"""
    on_conflict: card_cycle_on_conflict
  ): card_cycle

  """
  insert data into the table: "card_encounter_set"
  """
  insert_card_encounter_set(
    """the rows to be inserted"""
    objects: [card_encounter_set_insert_input!]!

    """upsert condition"""
    on_conflict: card_encounter_set_on_conflict
  ): card_encounter_set_mutation_response

  """
  insert a single row into the table: "card_encounter_set"
  """
  insert_card_encounter_set_one(
    """the row to be inserted"""
    object: card_encounter_set_insert_input!

    """upsert condition"""
    on_conflict: card_encounter_set_on_conflict
  ): card_encounter_set

  """
  insert a single row into the table: "card"
  """
  insert_card_one(
    """the row to be inserted"""
    object: card_insert_input!

    """upsert condition"""
    on_conflict: card_on_conflict
  ): card

  """
  insert data into the table: "card_pack"
  """
  insert_card_pack(
    """the rows to be inserted"""
    objects: [card_pack_insert_input!]!

    """upsert condition"""
    on_conflict: card_pack_on_conflict
  ): card_pack_mutation_response

  """
  insert a single row into the table: "card_pack"
  """
  insert_card_pack_one(
    """the row to be inserted"""
    object: card_pack_insert_input!

    """upsert condition"""
    on_conflict: card_pack_on_conflict
  ): card_pack

  """
  insert data into the table: "card_subtype_name"
  """
  insert_card_subtype_name(
    """the rows to be inserted"""
    objects: [card_subtype_name_insert_input!]!

    """upsert condition"""
    on_conflict: card_subtype_name_on_conflict
  ): card_subtype_name_mutation_response

  """
  insert a single row into the table: "card_subtype_name"
  """
  insert_card_subtype_name_one(
    """the row to be inserted"""
    object: card_subtype_name_insert_input!

    """upsert condition"""
    on_conflict: card_subtype_name_on_conflict
  ): card_subtype_name

  """
  insert data into the table: "card_text"
  """
  insert_card_text(
    """the rows to be inserted"""
    objects: [card_text_insert_input!]!

    """upsert condition"""
    on_conflict: card_text_on_conflict
  ): card_text_mutation_response

  """
  insert a single row into the table: "card_text"
  """
  insert_card_text_one(
    """the row to be inserted"""
    object: card_text_insert_input!

    """upsert condition"""
    on_conflict: card_text_on_conflict
  ): card_text

  """
  insert data into the table: "card_type_code"
  """
  insert_card_type_code(
    """the rows to be inserted"""
    objects: [card_type_code_insert_input!]!

    """upsert condition"""
    on_conflict: card_type_code_on_conflict
  ): card_type_code_mutation_response

  """
  insert a single row into the table: "card_type_code"
  """
  insert_card_type_code_one(
    """the row to be inserted"""
    object: card_type_code_insert_input!

    """upsert condition"""
    on_conflict: card_type_code_on_conflict
  ): card_type_code

  """
  insert data into the table: "card_type_name"
  """
  insert_card_type_name(
    """the rows to be inserted"""
    objects: [card_type_name_insert_input!]!

    """upsert condition"""
    on_conflict: card_type_name_on_conflict
  ): card_type_name_mutation_response

  """
  insert a single row into the table: "card_type_name"
  """
  insert_card_type_name_one(
    """the row to be inserted"""
    object: card_type_name_insert_input!

    """upsert condition"""
    on_conflict: card_type_name_on_conflict
  ): card_type_name

  """
  insert data into the table: "chaos_bag_result"
  """
  insert_chaos_bag_result(
    """the rows to be inserted"""
    objects: [chaos_bag_result_insert_input!]!

    """upsert condition"""
    on_conflict: chaos_bag_result_on_conflict
  ): chaos_bag_result_mutation_response

  """
  insert a single row into the table: "chaos_bag_result"
  """
  insert_chaos_bag_result_one(
    """the row to be inserted"""
    object: chaos_bag_result_insert_input!

    """upsert condition"""
    on_conflict: chaos_bag_result_on_conflict
  ): chaos_bag_result

  """
  insert data into the table: "chaos_bag_tarot_mode"
  """
  insert_chaos_bag_tarot_mode(
    """the rows to be inserted"""
    objects: [chaos_bag_tarot_mode_insert_input!]!

    """upsert condition"""
    on_conflict: chaos_bag_tarot_mode_on_conflict
  ): chaos_bag_tarot_mode_mutation_response

  """
  insert a single row into the table: "chaos_bag_tarot_mode"
  """
  insert_chaos_bag_tarot_mode_one(
    """the row to be inserted"""
    object: chaos_bag_tarot_mode_insert_input!

    """upsert condition"""
    on_conflict: chaos_bag_tarot_mode_on_conflict
  ): chaos_bag_tarot_mode

  """
  insert data into the table: "conquest.card"
  """
  insert_conquest_card(
    """the rows to be inserted"""
    objects: [conquest_card_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_card_on_conflict
  ): conquest_card_mutation_response

  """
  insert a single row into the table: "conquest.card"
  """
  insert_conquest_card_one(
    """the row to be inserted"""
    object: conquest_card_insert_input!

    """upsert condition"""
    on_conflict: conquest_card_on_conflict
  ): conquest_card

  """
  insert data into the table: "conquest.card_text"
  """
  insert_conquest_card_text(
    """the rows to be inserted"""
    objects: [conquest_card_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_card_text_on_conflict
  ): conquest_card_text_mutation_response

  """
  insert a single row into the table: "conquest.card_text"
  """
  insert_conquest_card_text_one(
    """the row to be inserted"""
    object: conquest_card_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_card_text_on_conflict
  ): conquest_card_text

  """
  insert data into the table: "conquest.comment"
  """
  insert_conquest_comment(
    """the rows to be inserted"""
    objects: [conquest_comment_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_comment_on_conflict
  ): conquest_comment_mutation_response

  """
  insert a single row into the table: "conquest.comment"
  """
  insert_conquest_comment_one(
    """the row to be inserted"""
    object: conquest_comment_insert_input!

    """upsert condition"""
    on_conflict: conquest_comment_on_conflict
  ): conquest_comment

  """
  insert data into the table: "conquest.cycle"
  """
  insert_conquest_cycle(
    """the rows to be inserted"""
    objects: [conquest_cycle_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_cycle_on_conflict
  ): conquest_cycle_mutation_response

  """
  insert a single row into the table: "conquest.cycle"
  """
  insert_conquest_cycle_one(
    """the row to be inserted"""
    object: conquest_cycle_insert_input!

    """upsert condition"""
    on_conflict: conquest_cycle_on_conflict
  ): conquest_cycle

  """
  insert data into the table: "conquest.cycle_text"
  """
  insert_conquest_cycle_text(
    """the rows to be inserted"""
    objects: [conquest_cycle_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_cycle_text_on_conflict
  ): conquest_cycle_text_mutation_response

  """
  insert a single row into the table: "conquest.cycle_text"
  """
  insert_conquest_cycle_text_one(
    """the row to be inserted"""
    object: conquest_cycle_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_cycle_text_on_conflict
  ): conquest_cycle_text

  """
  insert data into the table: "conquest.deck"
  """
  insert_conquest_deck(
    """the rows to be inserted"""
    objects: [conquest_deck_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_deck_on_conflict
  ): conquest_deck_mutation_response

  """
  insert data into the table: "conquest.deck_copy"
  """
  insert_conquest_deck_copy(
    """the rows to be inserted"""
    objects: [conquest_deck_copy_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_deck_copy_on_conflict
  ): conquest_deck_copy_mutation_response

  """
  insert a single row into the table: "conquest.deck_copy"
  """
  insert_conquest_deck_copy_one(
    """the row to be inserted"""
    object: conquest_deck_copy_insert_input!

    """upsert condition"""
    on_conflict: conquest_deck_copy_on_conflict
  ): conquest_deck_copy

  """
  insert data into the table: "conquest.deck_like"
  """
  insert_conquest_deck_like(
    """the rows to be inserted"""
    objects: [conquest_deck_like_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_deck_like_on_conflict
  ): conquest_deck_like_mutation_response

  """
  insert a single row into the table: "conquest.deck_like"
  """
  insert_conquest_deck_like_one(
    """the row to be inserted"""
    object: conquest_deck_like_insert_input!

    """upsert condition"""
    on_conflict: conquest_deck_like_on_conflict
  ): conquest_deck_like

  """
  insert a single row into the table: "conquest.deck"
  """
  insert_conquest_deck_one(
    """the row to be inserted"""
    object: conquest_deck_insert_input!

    """upsert condition"""
    on_conflict: conquest_deck_on_conflict
  ): conquest_deck

  """
  insert data into the table: "conquest.faction"
  """
  insert_conquest_faction(
    """the rows to be inserted"""
    objects: [conquest_faction_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_faction_on_conflict
  ): conquest_faction_mutation_response

  """
  insert a single row into the table: "conquest.faction"
  """
  insert_conquest_faction_one(
    """the row to be inserted"""
    object: conquest_faction_insert_input!

    """upsert condition"""
    on_conflict: conquest_faction_on_conflict
  ): conquest_faction

  """
  insert data into the table: "conquest.faction_text"
  """
  insert_conquest_faction_text(
    """the rows to be inserted"""
    objects: [conquest_faction_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_faction_text_on_conflict
  ): conquest_faction_text_mutation_response

  """
  insert a single row into the table: "conquest.faction_text"
  """
  insert_conquest_faction_text_one(
    """the row to be inserted"""
    object: conquest_faction_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_faction_text_on_conflict
  ): conquest_faction_text

  """
  insert data into the table: "conquest.loyalty"
  """
  insert_conquest_loyalty(
    """the rows to be inserted"""
    objects: [conquest_loyalty_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_loyalty_on_conflict
  ): conquest_loyalty_mutation_response

  """
  insert a single row into the table: "conquest.loyalty"
  """
  insert_conquest_loyalty_one(
    """the row to be inserted"""
    object: conquest_loyalty_insert_input!

    """upsert condition"""
    on_conflict: conquest_loyalty_on_conflict
  ): conquest_loyalty

  """
  insert data into the table: "conquest.loyalty_text"
  """
  insert_conquest_loyalty_text(
    """the rows to be inserted"""
    objects: [conquest_loyalty_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_loyalty_text_on_conflict
  ): conquest_loyalty_text_mutation_response

  """
  insert a single row into the table: "conquest.loyalty_text"
  """
  insert_conquest_loyalty_text_one(
    """the row to be inserted"""
    object: conquest_loyalty_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_loyalty_text_on_conflict
  ): conquest_loyalty_text

  """
  insert data into the table: "conquest.pack"
  """
  insert_conquest_pack(
    """the rows to be inserted"""
    objects: [conquest_pack_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_pack_on_conflict
  ): conquest_pack_mutation_response

  """
  insert a single row into the table: "conquest.pack"
  """
  insert_conquest_pack_one(
    """the row to be inserted"""
    object: conquest_pack_insert_input!

    """upsert condition"""
    on_conflict: conquest_pack_on_conflict
  ): conquest_pack

  """
  insert data into the table: "conquest.pack_text"
  """
  insert_conquest_pack_text(
    """the rows to be inserted"""
    objects: [conquest_pack_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_pack_text_on_conflict
  ): conquest_pack_text_mutation_response

  """
  insert a single row into the table: "conquest.pack_text"
  """
  insert_conquest_pack_text_one(
    """the row to be inserted"""
    object: conquest_pack_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_pack_text_on_conflict
  ): conquest_pack_text

  """
  insert data into the table: "conquest.type"
  """
  insert_conquest_type(
    """the rows to be inserted"""
    objects: [conquest_type_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_type_on_conflict
  ): conquest_type_mutation_response

  """
  insert a single row into the table: "conquest.type"
  """
  insert_conquest_type_one(
    """the row to be inserted"""
    object: conquest_type_insert_input!

    """upsert condition"""
    on_conflict: conquest_type_on_conflict
  ): conquest_type

  """
  insert data into the table: "conquest.type_text"
  """
  insert_conquest_type_text(
    """the rows to be inserted"""
    objects: [conquest_type_text_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_type_text_on_conflict
  ): conquest_type_text_mutation_response

  """
  insert a single row into the table: "conquest.type_text"
  """
  insert_conquest_type_text_one(
    """the row to be inserted"""
    object: conquest_type_text_insert_input!

    """upsert condition"""
    on_conflict: conquest_type_text_on_conflict
  ): conquest_type_text

  """
  insert data into the table: "conquest.user_role"
  """
  insert_conquest_user_role(
    """the rows to be inserted"""
    objects: [conquest_user_role_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_user_role_on_conflict
  ): conquest_user_role_mutation_response

  """
  insert a single row into the table: "conquest.user_role"
  """
  insert_conquest_user_role_one(
    """the row to be inserted"""
    object: conquest_user_role_insert_input!

    """upsert condition"""
    on_conflict: conquest_user_role_on_conflict
  ): conquest_user_role

  """
  insert data into the table: "conquest.user_settings"
  """
  insert_conquest_user_settings(
    """the rows to be inserted"""
    objects: [conquest_user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_user_settings_on_conflict
  ): conquest_user_settings_mutation_response

  """
  insert a single row into the table: "conquest.user_settings"
  """
  insert_conquest_user_settings_one(
    """the row to be inserted"""
    object: conquest_user_settings_insert_input!

    """upsert condition"""
    on_conflict: conquest_user_settings_on_conflict
  ): conquest_user_settings

  """
  insert data into the table: "conquest.users"
  """
  insert_conquest_users(
    """the rows to be inserted"""
    objects: [conquest_users_insert_input!]!

    """upsert condition"""
    on_conflict: conquest_users_on_conflict
  ): conquest_users_mutation_response

  """
  insert a single row into the table: "conquest.users"
  """
  insert_conquest_users_one(
    """the row to be inserted"""
    object: conquest_users_insert_input!

    """upsert condition"""
    on_conflict: conquest_users_on_conflict
  ): conquest_users

  """
  insert data into the table: "cycle"
  """
  insert_cycle(
    """the rows to be inserted"""
    objects: [cycle_insert_input!]!

    """upsert condition"""
    on_conflict: cycle_on_conflict
  ): cycle_mutation_response

  """
  insert data into the table: "cycle_name"
  """
  insert_cycle_name(
    """the rows to be inserted"""
    objects: [cycle_name_insert_input!]!

    """upsert condition"""
    on_conflict: cycle_name_on_conflict
  ): cycle_name_mutation_response

  """
  insert a single row into the table: "cycle_name"
  """
  insert_cycle_name_one(
    """the row to be inserted"""
    object: cycle_name_insert_input!

    """upsert condition"""
    on_conflict: cycle_name_on_conflict
  ): cycle_name

  """
  insert a single row into the table: "cycle"
  """
  insert_cycle_one(
    """the row to be inserted"""
    object: cycle_insert_input!

    """upsert condition"""
    on_conflict: cycle_on_conflict
  ): cycle

  """
  insert data into the table: "faction_name"
  """
  insert_faction_name(
    """the rows to be inserted"""
    objects: [faction_name_insert_input!]!

    """upsert condition"""
    on_conflict: faction_name_on_conflict
  ): faction_name_mutation_response

  """
  insert a single row into the table: "faction_name"
  """
  insert_faction_name_one(
    """the row to be inserted"""
    object: faction_name_insert_input!

    """upsert condition"""
    on_conflict: faction_name_on_conflict
  ): faction_name

  """
  insert data into the table: "faq"
  """
  insert_faq(
    """the rows to be inserted"""
    objects: [faq_insert_input!]!

    """upsert condition"""
    on_conflict: faq_on_conflict
  ): faq_mutation_response

  """
  insert a single row into the table: "faq"
  """
  insert_faq_one(
    """the row to be inserted"""
    object: faq_insert_input!

    """upsert condition"""
    on_conflict: faq_on_conflict
  ): faq

  """
  insert data into the table: "faq_text"
  """
  insert_faq_text(
    """the rows to be inserted"""
    objects: [faq_text_insert_input!]!

    """upsert condition"""
    on_conflict: faq_text_on_conflict
  ): faq_text_mutation_response

  """
  insert a single row into the table: "faq_text"
  """
  insert_faq_text_one(
    """the row to be inserted"""
    object: faq_text_insert_input!

    """upsert condition"""
    on_conflict: faq_text_on_conflict
  ): faq_text

  """
  insert data into the table: "friend_status"
  """
  insert_friend_status(
    """the rows to be inserted"""
    objects: [friend_status_insert_input!]!

    """upsert condition"""
    on_conflict: friend_status_on_conflict
  ): friend_status_mutation_response

  """
  insert a single row into the table: "friend_status"
  """
  insert_friend_status_one(
    """the row to be inserted"""
    object: friend_status_insert_input!

    """upsert condition"""
    on_conflict: friend_status_on_conflict
  ): friend_status

  """
  insert data into the table: "friend_status_type"
  """
  insert_friend_status_type(
    """the rows to be inserted"""
    objects: [friend_status_type_insert_input!]!

    """upsert condition"""
    on_conflict: friend_status_type_on_conflict
  ): friend_status_type_mutation_response

  """
  insert a single row into the table: "friend_status_type"
  """
  insert_friend_status_type_one(
    """the row to be inserted"""
    object: friend_status_type_insert_input!

    """upsert condition"""
    on_conflict: friend_status_type_on_conflict
  ): friend_status_type

  """
  insert data into the table: "full_card"
  """
  insert_full_card(
    """the rows to be inserted"""
    objects: [full_card_insert_input!]!

    """upsert condition"""
    on_conflict: full_card_on_conflict
  ): full_card_mutation_response

  """
  insert a single row into the table: "full_card"
  """
  insert_full_card_one(
    """the row to be inserted"""
    object: full_card_insert_input!

    """upsert condition"""
    on_conflict: full_card_on_conflict
  ): full_card

  """
  insert data into the table: "full_card_text"
  """
  insert_full_card_text(
    """the rows to be inserted"""
    objects: [full_card_text_insert_input!]!

    """upsert condition"""
    on_conflict: full_card_text_on_conflict
  ): full_card_text_mutation_response

  """
  insert a single row into the table: "full_card_text"
  """
  insert_full_card_text_one(
    """the row to be inserted"""
    object: full_card_text_insert_input!

    """upsert condition"""
    on_conflict: full_card_text_on_conflict
  ): full_card_text

  """
  insert data into the table: "gender"
  """
  insert_gender(
    """the rows to be inserted"""
    objects: [gender_insert_input!]!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender_mutation_response

  """
  insert a single row into the table: "gender"
  """
  insert_gender_one(
    """the row to be inserted"""
    object: gender_insert_input!

    """upsert condition"""
    on_conflict: gender_on_conflict
  ): gender

  """
  insert data into the table: "guide_achievement"
  """
  insert_guide_achievement(
    """the rows to be inserted"""
    objects: [guide_achievement_insert_input!]!

    """upsert condition"""
    on_conflict: guide_achievement_on_conflict
  ): guide_achievement_mutation_response

  """
  insert a single row into the table: "guide_achievement"
  """
  insert_guide_achievement_one(
    """the row to be inserted"""
    object: guide_achievement_insert_input!

    """upsert condition"""
    on_conflict: guide_achievement_on_conflict
  ): guide_achievement

  """
  insert data into the table: "guide_input"
  """
  insert_guide_input(
    """the rows to be inserted"""
    objects: [guide_input_insert_input!]!

    """upsert condition"""
    on_conflict: guide_input_on_conflict
  ): guide_input_mutation_response

  """
  insert a single row into the table: "guide_input"
  """
  insert_guide_input_one(
    """the row to be inserted"""
    object: guide_input_insert_input!

    """upsert condition"""
    on_conflict: guide_input_on_conflict
  ): guide_input

  """
  insert data into the table: "investigator_data"
  """
  insert_investigator_data(
    """the rows to be inserted"""
    objects: [investigator_data_insert_input!]!

    """upsert condition"""
    on_conflict: investigator_data_on_conflict
  ): investigator_data_mutation_response

  """
  insert a single row into the table: "investigator_data"
  """
  insert_investigator_data_one(
    """the row to be inserted"""
    object: investigator_data_insert_input!

    """upsert condition"""
    on_conflict: investigator_data_on_conflict
  ): investigator_data

  """
  insert data into the table: "latest_decks"
  """
  insert_latest_decks(
    """the rows to be inserted"""
    objects: [latest_decks_insert_input!]!
  ): latest_decks_mutation_response

  """
  insert a single row into the table: "latest_decks"
  """
  insert_latest_decks_one(
    """the row to be inserted"""
    object: latest_decks_insert_input!
  ): latest_decks

  """
  insert data into the table: "local_decks"
  """
  insert_local_decks(
    """the rows to be inserted"""
    objects: [local_decks_insert_input!]!
  ): local_decks_mutation_response

  """
  insert a single row into the table: "local_decks"
  """
  insert_local_decks_one(
    """the row to be inserted"""
    object: local_decks_insert_input!
  ): local_decks

  """
  insert data into the table: "pack"
  """
  insert_pack(
    """the rows to be inserted"""
    objects: [pack_insert_input!]!

    """upsert condition"""
    on_conflict: pack_on_conflict
  ): pack_mutation_response

  """
  insert data into the table: "pack_name"
  """
  insert_pack_name(
    """the rows to be inserted"""
    objects: [pack_name_insert_input!]!

    """upsert condition"""
    on_conflict: pack_name_on_conflict
  ): pack_name_mutation_response

  """
  insert a single row into the table: "pack_name"
  """
  insert_pack_name_one(
    """the row to be inserted"""
    object: pack_name_insert_input!

    """upsert condition"""
    on_conflict: pack_name_on_conflict
  ): pack_name

  """
  insert a single row into the table: "pack"
  """
  insert_pack_one(
    """the row to be inserted"""
    object: pack_insert_input!

    """upsert condition"""
    on_conflict: pack_on_conflict
  ): pack

  """
  insert data into the table: "rangers.area"
  """
  insert_rangers_area(
    """the rows to be inserted"""
    objects: [rangers_area_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_area_on_conflict
  ): rangers_area_mutation_response

  """
  insert a single row into the table: "rangers.area"
  """
  insert_rangers_area_one(
    """the row to be inserted"""
    object: rangers_area_insert_input!

    """upsert condition"""
    on_conflict: rangers_area_on_conflict
  ): rangers_area

  """
  insert data into the table: "rangers.area_text"
  """
  insert_rangers_area_text(
    """the rows to be inserted"""
    objects: [rangers_area_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_area_text_on_conflict
  ): rangers_area_text_mutation_response

  """
  insert a single row into the table: "rangers.area_text"
  """
  insert_rangers_area_text_one(
    """the row to be inserted"""
    object: rangers_area_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_area_text_on_conflict
  ): rangers_area_text

  """
  insert data into the table: "rangers.aspect"
  """
  insert_rangers_aspect(
    """the rows to be inserted"""
    objects: [rangers_aspect_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_aspect_on_conflict
  ): rangers_aspect_mutation_response

  """
  insert a single row into the table: "rangers.aspect"
  """
  insert_rangers_aspect_one(
    """the row to be inserted"""
    object: rangers_aspect_insert_input!

    """upsert condition"""
    on_conflict: rangers_aspect_on_conflict
  ): rangers_aspect

  """
  insert data into the table: "rangers.aspect_text"
  """
  insert_rangers_aspect_text(
    """the rows to be inserted"""
    objects: [rangers_aspect_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_aspect_text_on_conflict
  ): rangers_aspect_text_mutation_response

  """
  insert a single row into the table: "rangers.aspect_text"
  """
  insert_rangers_aspect_text_one(
    """the row to be inserted"""
    object: rangers_aspect_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_aspect_text_on_conflict
  ): rangers_aspect_text

  """
  insert data into the table: "rangers.campaign"
  """
  insert_rangers_campaign(
    """the rows to be inserted"""
    objects: [rangers_campaign_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_campaign_on_conflict
  ): rangers_campaign_mutation_response

  """
  insert data into the table: "rangers.campaign_access"
  """
  insert_rangers_campaign_access(
    """the rows to be inserted"""
    objects: [rangers_campaign_access_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_campaign_access_on_conflict
  ): rangers_campaign_access_mutation_response

  """
  insert a single row into the table: "rangers.campaign_access"
  """
  insert_rangers_campaign_access_one(
    """the row to be inserted"""
    object: rangers_campaign_access_insert_input!

    """upsert condition"""
    on_conflict: rangers_campaign_access_on_conflict
  ): rangers_campaign_access

  """
  insert a single row into the table: "rangers.campaign"
  """
  insert_rangers_campaign_one(
    """the row to be inserted"""
    object: rangers_campaign_insert_input!

    """upsert condition"""
    on_conflict: rangers_campaign_on_conflict
  ): rangers_campaign

  """
  insert data into the table: "rangers.card"
  """
  insert_rangers_card(
    """the rows to be inserted"""
    objects: [rangers_card_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_card_on_conflict
  ): rangers_card_mutation_response

  """
  insert a single row into the table: "rangers.card"
  """
  insert_rangers_card_one(
    """the row to be inserted"""
    object: rangers_card_insert_input!

    """upsert condition"""
    on_conflict: rangers_card_on_conflict
  ): rangers_card

  """
  insert data into the table: "rangers.card_text"
  """
  insert_rangers_card_text(
    """the rows to be inserted"""
    objects: [rangers_card_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_card_text_on_conflict
  ): rangers_card_text_mutation_response

  """
  insert a single row into the table: "rangers.card_text"
  """
  insert_rangers_card_text_one(
    """the row to be inserted"""
    object: rangers_card_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_card_text_on_conflict
  ): rangers_card_text

  """
  insert data into the table: "rangers.comment"
  """
  insert_rangers_comment(
    """the rows to be inserted"""
    objects: [rangers_comment_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_comment_on_conflict
  ): rangers_comment_mutation_response

  """
  insert a single row into the table: "rangers.comment"
  """
  insert_rangers_comment_one(
    """the row to be inserted"""
    object: rangers_comment_insert_input!

    """upsert condition"""
    on_conflict: rangers_comment_on_conflict
  ): rangers_comment

  """
  insert data into the table: "rangers.deck"
  """
  insert_rangers_deck(
    """the rows to be inserted"""
    objects: [rangers_deck_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_deck_on_conflict
  ): rangers_deck_mutation_response

  """
  insert data into the table: "rangers.deck_copy"
  """
  insert_rangers_deck_copy(
    """the rows to be inserted"""
    objects: [rangers_deck_copy_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_deck_copy_on_conflict
  ): rangers_deck_copy_mutation_response

  """
  insert a single row into the table: "rangers.deck_copy"
  """
  insert_rangers_deck_copy_one(
    """the row to be inserted"""
    object: rangers_deck_copy_insert_input!

    """upsert condition"""
    on_conflict: rangers_deck_copy_on_conflict
  ): rangers_deck_copy

  """
  insert data into the table: "rangers.deck_like"
  """
  insert_rangers_deck_like(
    """the rows to be inserted"""
    objects: [rangers_deck_like_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_deck_like_on_conflict
  ): rangers_deck_like_mutation_response

  """
  insert data into the table: "rangers.deck_like_count"
  """
  insert_rangers_deck_like_count(
    """the rows to be inserted"""
    objects: [rangers_deck_like_count_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_deck_like_count_on_conflict
  ): rangers_deck_like_count_mutation_response

  """
  insert a single row into the table: "rangers.deck_like_count"
  """
  insert_rangers_deck_like_count_one(
    """the row to be inserted"""
    object: rangers_deck_like_count_insert_input!

    """upsert condition"""
    on_conflict: rangers_deck_like_count_on_conflict
  ): rangers_deck_like_count

  """
  insert a single row into the table: "rangers.deck_like"
  """
  insert_rangers_deck_like_one(
    """the row to be inserted"""
    object: rangers_deck_like_insert_input!

    """upsert condition"""
    on_conflict: rangers_deck_like_on_conflict
  ): rangers_deck_like

  """
  insert a single row into the table: "rangers.deck"
  """
  insert_rangers_deck_one(
    """the row to be inserted"""
    object: rangers_deck_insert_input!

    """upsert condition"""
    on_conflict: rangers_deck_on_conflict
  ): rangers_deck

  """
  insert data into the table: "rangers.faq_entry"
  """
  insert_rangers_faq_entry(
    """the rows to be inserted"""
    objects: [rangers_faq_entry_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_faq_entry_on_conflict
  ): rangers_faq_entry_mutation_response

  """
  insert a single row into the table: "rangers.faq_entry"
  """
  insert_rangers_faq_entry_one(
    """the row to be inserted"""
    object: rangers_faq_entry_insert_input!

    """upsert condition"""
    on_conflict: rangers_faq_entry_on_conflict
  ): rangers_faq_entry

  """
  insert data into the table: "rangers.friend_status"
  """
  insert_rangers_friend_status(
    """the rows to be inserted"""
    objects: [rangers_friend_status_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_friend_status_on_conflict
  ): rangers_friend_status_mutation_response

  """
  insert a single row into the table: "rangers.friend_status"
  """
  insert_rangers_friend_status_one(
    """the row to be inserted"""
    object: rangers_friend_status_insert_input!

    """upsert condition"""
    on_conflict: rangers_friend_status_on_conflict
  ): rangers_friend_status

  """
  insert data into the table: "rangers.friend_status_type"
  """
  insert_rangers_friend_status_type(
    """the rows to be inserted"""
    objects: [rangers_friend_status_type_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_friend_status_type_on_conflict
  ): rangers_friend_status_type_mutation_response

  """
  insert a single row into the table: "rangers.friend_status_type"
  """
  insert_rangers_friend_status_type_one(
    """the row to be inserted"""
    object: rangers_friend_status_type_insert_input!

    """upsert condition"""
    on_conflict: rangers_friend_status_type_on_conflict
  ): rangers_friend_status_type

  """
  insert data into the table: "rangers.latest_deck"
  """
  insert_rangers_latest_deck(
    """the rows to be inserted"""
    objects: [rangers_latest_deck_insert_input!]!
  ): rangers_latest_deck_mutation_response

  """
  insert a single row into the table: "rangers.latest_deck"
  """
  insert_rangers_latest_deck_one(
    """the row to be inserted"""
    object: rangers_latest_deck_insert_input!
  ): rangers_latest_deck

  """
  insert data into the table: "rangers.locale"
  """
  insert_rangers_locale(
    """the rows to be inserted"""
    objects: [rangers_locale_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_locale_on_conflict
  ): rangers_locale_mutation_response

  """
  insert a single row into the table: "rangers.locale"
  """
  insert_rangers_locale_one(
    """the row to be inserted"""
    object: rangers_locale_insert_input!

    """upsert condition"""
    on_conflict: rangers_locale_on_conflict
  ): rangers_locale

  """
  insert data into the table: "rangers.pack"
  """
  insert_rangers_pack(
    """the rows to be inserted"""
    objects: [rangers_pack_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_pack_on_conflict
  ): rangers_pack_mutation_response

  """
  insert a single row into the table: "rangers.pack"
  """
  insert_rangers_pack_one(
    """the row to be inserted"""
    object: rangers_pack_insert_input!

    """upsert condition"""
    on_conflict: rangers_pack_on_conflict
  ): rangers_pack

  """
  insert data into the table: "rangers.pack_text"
  """
  insert_rangers_pack_text(
    """the rows to be inserted"""
    objects: [rangers_pack_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_pack_text_on_conflict
  ): rangers_pack_text_mutation_response

  """
  insert a single row into the table: "rangers.pack_text"
  """
  insert_rangers_pack_text_one(
    """the row to be inserted"""
    object: rangers_pack_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_pack_text_on_conflict
  ): rangers_pack_text

  """
  insert data into the table: "rangers.search_deck"
  """
  insert_rangers_search_deck(
    """the rows to be inserted"""
    objects: [rangers_search_deck_insert_input!]!
  ): rangers_search_deck_mutation_response

  """
  insert a single row into the table: "rangers.search_deck"
  """
  insert_rangers_search_deck_one(
    """the row to be inserted"""
    object: rangers_search_deck_insert_input!
  ): rangers_search_deck

  """
  insert data into the table: "rangers.set"
  """
  insert_rangers_set(
    """the rows to be inserted"""
    objects: [rangers_set_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_set_on_conflict
  ): rangers_set_mutation_response

  """
  insert a single row into the table: "rangers.set"
  """
  insert_rangers_set_one(
    """the row to be inserted"""
    object: rangers_set_insert_input!

    """upsert condition"""
    on_conflict: rangers_set_on_conflict
  ): rangers_set

  """
  insert data into the table: "rangers.set_text"
  """
  insert_rangers_set_text(
    """the rows to be inserted"""
    objects: [rangers_set_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_set_text_on_conflict
  ): rangers_set_text_mutation_response

  """
  insert a single row into the table: "rangers.set_text"
  """
  insert_rangers_set_text_one(
    """the row to be inserted"""
    object: rangers_set_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_set_text_on_conflict
  ): rangers_set_text

  """
  insert data into the table: "rangers.set_type"
  """
  insert_rangers_set_type(
    """the rows to be inserted"""
    objects: [rangers_set_type_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_set_type_on_conflict
  ): rangers_set_type_mutation_response

  """
  insert a single row into the table: "rangers.set_type"
  """
  insert_rangers_set_type_one(
    """the row to be inserted"""
    object: rangers_set_type_insert_input!

    """upsert condition"""
    on_conflict: rangers_set_type_on_conflict
  ): rangers_set_type

  """
  insert data into the table: "rangers.set_type_text"
  """
  insert_rangers_set_type_text(
    """the rows to be inserted"""
    objects: [rangers_set_type_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_set_type_text_on_conflict
  ): rangers_set_type_text_mutation_response

  """
  insert a single row into the table: "rangers.set_type_text"
  """
  insert_rangers_set_type_text_one(
    """the row to be inserted"""
    object: rangers_set_type_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_set_type_text_on_conflict
  ): rangers_set_type_text

  """
  insert data into the table: "rangers.subset"
  """
  insert_rangers_subset(
    """the rows to be inserted"""
    objects: [rangers_subset_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_subset_on_conflict
  ): rangers_subset_mutation_response

  """
  insert a single row into the table: "rangers.subset"
  """
  insert_rangers_subset_one(
    """the row to be inserted"""
    object: rangers_subset_insert_input!

    """upsert condition"""
    on_conflict: rangers_subset_on_conflict
  ): rangers_subset

  """
  insert data into the table: "rangers.subset_text"
  """
  insert_rangers_subset_text(
    """the rows to be inserted"""
    objects: [rangers_subset_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_subset_text_on_conflict
  ): rangers_subset_text_mutation_response

  """
  insert a single row into the table: "rangers.subset_text"
  """
  insert_rangers_subset_text_one(
    """the row to be inserted"""
    object: rangers_subset_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_subset_text_on_conflict
  ): rangers_subset_text

  """
  insert data into the table: "rangers.taboo_set"
  """
  insert_rangers_taboo_set(
    """the rows to be inserted"""
    objects: [rangers_taboo_set_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_taboo_set_on_conflict
  ): rangers_taboo_set_mutation_response

  """
  insert a single row into the table: "rangers.taboo_set"
  """
  insert_rangers_taboo_set_one(
    """the row to be inserted"""
    object: rangers_taboo_set_insert_input!

    """upsert condition"""
    on_conflict: rangers_taboo_set_on_conflict
  ): rangers_taboo_set

  """
  insert data into the table: "rangers.taboo_set_text"
  """
  insert_rangers_taboo_set_text(
    """the rows to be inserted"""
    objects: [rangers_taboo_set_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_taboo_set_text_on_conflict
  ): rangers_taboo_set_text_mutation_response

  """
  insert a single row into the table: "rangers.taboo_set_text"
  """
  insert_rangers_taboo_set_text_one(
    """the row to be inserted"""
    object: rangers_taboo_set_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_taboo_set_text_on_conflict
  ): rangers_taboo_set_text

  """
  insert data into the table: "rangers.token"
  """
  insert_rangers_token(
    """the rows to be inserted"""
    objects: [rangers_token_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_token_on_conflict
  ): rangers_token_mutation_response

  """
  insert a single row into the table: "rangers.token"
  """
  insert_rangers_token_one(
    """the row to be inserted"""
    object: rangers_token_insert_input!

    """upsert condition"""
    on_conflict: rangers_token_on_conflict
  ): rangers_token

  """
  insert data into the table: "rangers.token_text"
  """
  insert_rangers_token_text(
    """the rows to be inserted"""
    objects: [rangers_token_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_token_text_on_conflict
  ): rangers_token_text_mutation_response

  """
  insert a single row into the table: "rangers.token_text"
  """
  insert_rangers_token_text_one(
    """the row to be inserted"""
    object: rangers_token_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_token_text_on_conflict
  ): rangers_token_text

  """
  insert data into the table: "rangers.type"
  """
  insert_rangers_type(
    """the rows to be inserted"""
    objects: [rangers_type_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_type_on_conflict
  ): rangers_type_mutation_response

  """
  insert a single row into the table: "rangers.type"
  """
  insert_rangers_type_one(
    """the row to be inserted"""
    object: rangers_type_insert_input!

    """upsert condition"""
    on_conflict: rangers_type_on_conflict
  ): rangers_type

  """
  insert data into the table: "rangers.type_text"
  """
  insert_rangers_type_text(
    """the rows to be inserted"""
    objects: [rangers_type_text_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_type_text_on_conflict
  ): rangers_type_text_mutation_response

  """
  insert a single row into the table: "rangers.type_text"
  """
  insert_rangers_type_text_one(
    """the row to be inserted"""
    object: rangers_type_text_insert_input!

    """upsert condition"""
    on_conflict: rangers_type_text_on_conflict
  ): rangers_type_text

  """
  insert data into the table: "rangers.user_friends"
  """
  insert_rangers_user_friends(
    """the rows to be inserted"""
    objects: [rangers_user_friends_insert_input!]!
  ): rangers_user_friends_mutation_response

  """
  insert a single row into the table: "rangers.user_friends"
  """
  insert_rangers_user_friends_one(
    """the row to be inserted"""
    object: rangers_user_friends_insert_input!
  ): rangers_user_friends

  """
  insert data into the table: "rangers.user_received_friend_requests"
  """
  insert_rangers_user_received_friend_requests(
    """the rows to be inserted"""
    objects: [rangers_user_received_friend_requests_insert_input!]!
  ): rangers_user_received_friend_requests_mutation_response

  """
  insert a single row into the table: "rangers.user_received_friend_requests"
  """
  insert_rangers_user_received_friend_requests_one(
    """the row to be inserted"""
    object: rangers_user_received_friend_requests_insert_input!
  ): rangers_user_received_friend_requests

  """
  insert data into the table: "rangers.user_role"
  """
  insert_rangers_user_role(
    """the rows to be inserted"""
    objects: [rangers_user_role_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_user_role_on_conflict
  ): rangers_user_role_mutation_response

  """
  insert a single row into the table: "rangers.user_role"
  """
  insert_rangers_user_role_one(
    """the row to be inserted"""
    object: rangers_user_role_insert_input!

    """upsert condition"""
    on_conflict: rangers_user_role_on_conflict
  ): rangers_user_role

  """
  insert data into the table: "rangers.user_sent_friend_requests"
  """
  insert_rangers_user_sent_friend_requests(
    """the rows to be inserted"""
    objects: [rangers_user_sent_friend_requests_insert_input!]!
  ): rangers_user_sent_friend_requests_mutation_response

  """
  insert a single row into the table: "rangers.user_sent_friend_requests"
  """
  insert_rangers_user_sent_friend_requests_one(
    """the row to be inserted"""
    object: rangers_user_sent_friend_requests_insert_input!
  ): rangers_user_sent_friend_requests

  """
  insert data into the table: "rangers.user_settings"
  """
  insert_rangers_user_settings(
    """the rows to be inserted"""
    objects: [rangers_user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_user_settings_on_conflict
  ): rangers_user_settings_mutation_response

  """
  insert a single row into the table: "rangers.user_settings"
  """
  insert_rangers_user_settings_one(
    """the row to be inserted"""
    object: rangers_user_settings_insert_input!

    """upsert condition"""
    on_conflict: rangers_user_settings_on_conflict
  ): rangers_user_settings

  """
  insert data into the table: "rangers.users"
  """
  insert_rangers_users(
    """the rows to be inserted"""
    objects: [rangers_users_insert_input!]!

    """upsert condition"""
    on_conflict: rangers_users_on_conflict
  ): rangers_users_mutation_response

  """
  insert a single row into the table: "rangers.users"
  """
  insert_rangers_users_one(
    """the row to be inserted"""
    object: rangers_users_insert_input!

    """upsert condition"""
    on_conflict: rangers_users_on_conflict
  ): rangers_users

  """
  insert data into the table: "taboo_set"
  """
  insert_taboo_set(
    """the rows to be inserted"""
    objects: [taboo_set_insert_input!]!

    """upsert condition"""
    on_conflict: taboo_set_on_conflict
  ): taboo_set_mutation_response

  """
  insert a single row into the table: "taboo_set"
  """
  insert_taboo_set_one(
    """the row to be inserted"""
    object: taboo_set_insert_input!

    """upsert condition"""
    on_conflict: taboo_set_on_conflict
  ): taboo_set

  """
  insert data into the table: "user_campaigns"
  """
  insert_user_campaigns(
    """the rows to be inserted"""
    objects: [user_campaigns_insert_input!]!
  ): user_campaigns_mutation_response

  """
  insert a single row into the table: "user_campaigns"
  """
  insert_user_campaigns_one(
    """the row to be inserted"""
    object: user_campaigns_insert_input!
  ): user_campaigns

  """
  insert data into the table: "user_flag"
  """
  insert_user_flag(
    """the rows to be inserted"""
    objects: [user_flag_insert_input!]!

    """upsert condition"""
    on_conflict: user_flag_on_conflict
  ): user_flag_mutation_response

  """
  insert a single row into the table: "user_flag"
  """
  insert_user_flag_one(
    """the row to be inserted"""
    object: user_flag_insert_input!

    """upsert condition"""
    on_conflict: user_flag_on_conflict
  ): user_flag

  """
  insert data into the table: "user_flag_type"
  """
  insert_user_flag_type(
    """the rows to be inserted"""
    objects: [user_flag_type_insert_input!]!

    """upsert condition"""
    on_conflict: user_flag_type_on_conflict
  ): user_flag_type_mutation_response

  """
  insert a single row into the table: "user_flag_type"
  """
  insert_user_flag_type_one(
    """the row to be inserted"""
    object: user_flag_type_insert_input!

    """upsert condition"""
    on_conflict: user_flag_type_on_conflict
  ): user_flag_type

  """
  insert data into the table: "user_friends"
  """
  insert_user_friends(
    """the rows to be inserted"""
    objects: [user_friends_insert_input!]!
  ): user_friends_mutation_response

  """
  insert a single row into the table: "user_friends"
  """
  insert_user_friends_one(
    """the row to be inserted"""
    object: user_friends_insert_input!
  ): user_friends

  """
  insert data into the table: "user_received_friend_requests"
  """
  insert_user_received_friend_requests(
    """the rows to be inserted"""
    objects: [user_received_friend_requests_insert_input!]!
  ): user_received_friend_requests_mutation_response

  """
  insert a single row into the table: "user_received_friend_requests"
  """
  insert_user_received_friend_requests_one(
    """the row to be inserted"""
    object: user_received_friend_requests_insert_input!
  ): user_received_friend_requests

  """
  insert data into the table: "user_sent_friend_requests"
  """
  insert_user_sent_friend_requests(
    """the rows to be inserted"""
    objects: [user_sent_friend_requests_insert_input!]!
  ): user_sent_friend_requests_mutation_response

  """
  insert a single row into the table: "user_sent_friend_requests"
  """
  insert_user_sent_friend_requests_one(
    """the row to be inserted"""
    object: user_sent_friend_requests_insert_input!
  ): user_sent_friend_requests

  """
  insert data into the table: "user_settings"
  """
  insert_user_settings(
    """the rows to be inserted"""
    objects: [user_settings_insert_input!]!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings_mutation_response

  """
  insert a single row into the table: "user_settings"
  """
  insert_user_settings_one(
    """the row to be inserted"""
    object: user_settings_insert_input!

    """upsert condition"""
    on_conflict: user_settings_on_conflict
  ): user_settings

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users
  loginToArkhamDb(args: LoginInput!): LoginOutput
  logoutFromArkhamDb: LogoutOutput
  migrateLoginToArkhamDb(args: MigrateLoginInput!): MigrateLoginOutput

  """
  execute VOLATILE function "rangers.publish_deck" which returns "rangers.deck"
  """
  rangers_publish_deck(
    """
    input parameters for function "rangers_publish_deck"
    """
    args: rangers_publish_deck_args!

    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): rangers_deck

  """
  execute VOLATILE function "rangers.remove_campaign_deck" which returns "rangers.campaign"
  """
  rangers_remove_campaign_deck(
    """
    input parameters for function "rangers_remove_campaign_deck"
    """
    args: rangers_remove_campaign_deck_args!

    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): [rangers_campaign!]!

  """
  execute VOLATILE function "rangers.set_campaign_deck" which returns "rangers.campaign"
  """
  rangers_set_campaign_deck(
    """
    input parameters for function "rangers_set_campaign_deck"
    """
    args: rangers_set_campaign_deck_args!

    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): [rangers_campaign!]!

  """
  execute VOLATILE function "rangers.set_handle" which returns "rangers.users"
  """
  rangers_set_handle(
    """
    input parameters for function "rangers_set_handle"
    """
    args: rangers_set_handle_args!

    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): [rangers_users!]!

  """
  execute VOLATILE function "rangers.update_friend_request" which returns "rangers.users"
  """
  rangers_update_friend_request(
    """
    input parameters for function "rangers_update_friend_request"
    """
    args: rangers_update_friend_request_args!

    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): [rangers_users!]!

  """
  execute VOLATILE function "rangers.upgrade_deck" which returns "rangers.deck"
  """
  rangers_upgrade_deck(
    """
    input parameters for function "rangers_upgrade_deck"
    """
    args: rangers_upgrade_deck_args!

    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): rangers_deck
  refreshArkhamDbDecks(args: RefreshDecksInput!): RefreshDecksOutput
  updateFriendRequest(args: FriendRequestInput!): FriendRequestOutput
  updateHandle(args: UpdateHandleInput!): UpdateHandleOutput

  """
  update data of the table: "all_card"
  """
  update_all_card(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: all_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: all_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: all_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: all_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: all_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_set_input

    """filter the rows which have to be updated"""
    where: all_card_bool_exp!
  ): all_card_mutation_response

  """
  update single row of the table: "all_card"
  """
  update_all_card_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: all_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: all_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: all_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: all_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: all_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_set_input
    pk_columns: all_card_pk_columns_input!
  ): all_card

  """
  update multiples rows of table: "all_card"
  """
  update_all_card_many(
    """updates to execute, in order"""
    updates: [all_card_updates!]!
  ): [all_card_mutation_response]

  """
  update data of the table: "all_card_text"
  """
  update_all_card_text(
    """sets the columns of the filtered rows to the given values"""
    _set: all_card_text_set_input

    """filter the rows which have to be updated"""
    where: all_card_text_bool_exp!
  ): all_card_text_mutation_response

  """
  update single row of the table: "all_card_text"
  """
  update_all_card_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: all_card_text_set_input
    pk_columns: all_card_text_pk_columns_input!
  ): all_card_text

  """
  update multiples rows of table: "all_card_text"
  """
  update_all_card_text_many(
    """updates to execute, in order"""
    updates: [all_card_text_updates!]!
  ): [all_card_text_mutation_response]

  """
  update data of the table: "all_card_updated"
  """
  update_all_card_updated(
    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_updated_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_updated_set_input

    """filter the rows which have to be updated"""
    where: all_card_updated_bool_exp!
  ): all_card_updated_mutation_response

  """
  update single row of the table: "all_card_updated"
  """
  update_all_card_updated_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_updated_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_updated_set_input
    pk_columns: all_card_updated_pk_columns_input!
  ): all_card_updated

  """
  update data of the table: "all_card_updated_by_version"
  """
  update_all_card_updated_by_version(
    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_updated_by_version_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_updated_by_version_set_input

    """filter the rows which have to be updated"""
    where: all_card_updated_by_version_bool_exp!
  ): all_card_updated_by_version_mutation_response

  """
  update single row of the table: "all_card_updated_by_version"
  """
  update_all_card_updated_by_version_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: all_card_updated_by_version_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: all_card_updated_by_version_set_input
    pk_columns: all_card_updated_by_version_pk_columns_input!
  ): all_card_updated_by_version

  """
  update multiples rows of table: "all_card_updated_by_version"
  """
  update_all_card_updated_by_version_many(
    """updates to execute, in order"""
    updates: [all_card_updated_by_version_updates!]!
  ): [all_card_updated_by_version_mutation_response]

  """
  update multiples rows of table: "all_card_updated"
  """
  update_all_card_updated_many(
    """updates to execute, in order"""
    updates: [all_card_updated_updates!]!
  ): [all_card_updated_mutation_response]

  """
  update data of the table: "arkhamdb_auth"
  """
  update_arkhamdb_auth(
    """increments the numeric columns with given value of the filtered values"""
    _inc: arkhamdb_auth_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: arkhamdb_auth_set_input

    """filter the rows which have to be updated"""
    where: arkhamdb_auth_bool_exp!
  ): arkhamdb_auth_mutation_response

  """
  update single row of the table: "arkhamdb_auth"
  """
  update_arkhamdb_auth_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: arkhamdb_auth_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: arkhamdb_auth_set_input
    pk_columns: arkhamdb_auth_pk_columns_input!
  ): arkhamdb_auth

  """
  update multiples rows of table: "arkhamdb_auth"
  """
  update_arkhamdb_auth_many(
    """updates to execute, in order"""
    updates: [arkhamdb_auth_updates!]!
  ): [arkhamdb_auth_mutation_response]

  """
  update data of the table: "arkhamdb_deck"
  """
  update_arkhamdb_deck(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: arkhamdb_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: arkhamdb_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: arkhamdb_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: arkhamdb_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: arkhamdb_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: arkhamdb_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: arkhamdb_deck_set_input

    """filter the rows which have to be updated"""
    where: arkhamdb_deck_bool_exp!
  ): arkhamdb_deck_mutation_response

  """
  update single row of the table: "arkhamdb_deck"
  """
  update_arkhamdb_deck_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: arkhamdb_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: arkhamdb_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: arkhamdb_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: arkhamdb_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: arkhamdb_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: arkhamdb_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: arkhamdb_deck_set_input
    pk_columns: arkhamdb_deck_pk_columns_input!
  ): arkhamdb_deck

  """
  update multiples rows of table: "arkhamdb_deck"
  """
  update_arkhamdb_deck_many(
    """updates to execute, in order"""
    updates: [arkhamdb_deck_updates!]!
  ): [arkhamdb_deck_mutation_response]

  """
  update data of the table: "base_decks"
  """
  update_base_decks(
    """increments the numeric columns with given value of the filtered values"""
    _inc: base_decks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: base_decks_set_input

    """filter the rows which have to be updated"""
    where: base_decks_bool_exp!
  ): base_decks_mutation_response

  """
  update multiples rows of table: "base_decks"
  """
  update_base_decks_many(
    """updates to execute, in order"""
    updates: [base_decks_updates!]!
  ): [base_decks_mutation_response]

  """
  update data of the table: "campaign"
  """
  update_campaign(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_set_input

    """filter the rows which have to be updated"""
    where: campaign_bool_exp!
  ): campaign_mutation_response

  """
  update data of the table: "campaign_access"
  """
  update_campaign_access(
    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_access_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_access_set_input

    """filter the rows which have to be updated"""
    where: campaign_access_bool_exp!
  ): campaign_access_mutation_response

  """
  update single row of the table: "campaign_access"
  """
  update_campaign_access_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_access_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_access_set_input
    pk_columns: campaign_access_pk_columns_input!
  ): campaign_access

  """
  update multiples rows of table: "campaign_access"
  """
  update_campaign_access_many(
    """updates to execute, in order"""
    updates: [campaign_access_updates!]!
  ): [campaign_access_mutation_response]

  """
  update single row of the table: "campaign"
  """
  update_campaign_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_set_input
    pk_columns: campaign_pk_columns_input!
  ): campaign

  """
  update data of the table: "campaign_deck"
  """
  update_campaign_deck(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: campaign_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: campaign_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: campaign_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: campaign_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: campaign_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_deck_set_input

    """filter the rows which have to be updated"""
    where: campaign_deck_bool_exp!
  ): campaign_deck_mutation_response

  """
  update single row of the table: "campaign_deck"
  """
  update_campaign_deck_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: campaign_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: campaign_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: campaign_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: campaign_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: campaign_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_deck_set_input
    pk_columns: campaign_deck_pk_columns_input!
  ): campaign_deck

  """
  update multiples rows of table: "campaign_deck"
  """
  update_campaign_deck_many(
    """updates to execute, in order"""
    updates: [campaign_deck_updates!]!
  ): [campaign_deck_mutation_response]

  """
  update data of the table: "campaign_difficulty"
  """
  update_campaign_difficulty(
    """sets the columns of the filtered rows to the given values"""
    _set: campaign_difficulty_set_input

    """filter the rows which have to be updated"""
    where: campaign_difficulty_bool_exp!
  ): campaign_difficulty_mutation_response

  """
  update single row of the table: "campaign_difficulty"
  """
  update_campaign_difficulty_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: campaign_difficulty_set_input
    pk_columns: campaign_difficulty_pk_columns_input!
  ): campaign_difficulty

  """
  update multiples rows of table: "campaign_difficulty"
  """
  update_campaign_difficulty_many(
    """updates to execute, in order"""
    updates: [campaign_difficulty_updates!]!
  ): [campaign_difficulty_mutation_response]

  """
  update data of the table: "campaign_guide"
  """
  update_campaign_guide(
    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_guide_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_guide_set_input

    """filter the rows which have to be updated"""
    where: campaign_guide_bool_exp!
  ): campaign_guide_mutation_response

  """
  update multiples rows of table: "campaign_guide"
  """
  update_campaign_guide_many(
    """updates to execute, in order"""
    updates: [campaign_guide_updates!]!
  ): [campaign_guide_mutation_response]

  """
  update data of the table: "campaign_investigator"
  """
  update_campaign_investigator(
    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_investigator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_investigator_set_input

    """filter the rows which have to be updated"""
    where: campaign_investigator_bool_exp!
  ): campaign_investigator_mutation_response

  """
  update single row of the table: "campaign_investigator"
  """
  update_campaign_investigator_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: campaign_investigator_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: campaign_investigator_set_input
    pk_columns: campaign_investigator_pk_columns_input!
  ): campaign_investigator

  """
  update multiples rows of table: "campaign_investigator"
  """
  update_campaign_investigator_many(
    """updates to execute, in order"""
    updates: [campaign_investigator_updates!]!
  ): [campaign_investigator_mutation_response]

  """
  update multiples rows of table: "campaign"
  """
  update_campaign_many(
    """updates to execute, in order"""
    updates: [campaign_updates!]!
  ): [campaign_mutation_response]

  """
  update data of the table: "card"
  """
  update_card(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_set_input

    """filter the rows which have to be updated"""
    where: card_bool_exp!
  ): card_mutation_response

  """
  update single row of the table: "card"
  """
  update_card_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_set_input
    pk_columns: card_pk_columns_input!
  ): card

  """
  update data of the table: "card_cycle"
  """
  update_card_cycle(
    """increments the numeric columns with given value of the filtered values"""
    _inc: card_cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_cycle_set_input

    """filter the rows which have to be updated"""
    where: card_cycle_bool_exp!
  ): card_cycle_mutation_response

  """
  update single row of the table: "card_cycle"
  """
  update_card_cycle_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: card_cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_cycle_set_input
    pk_columns: card_cycle_pk_columns_input!
  ): card_cycle

  """
  update multiples rows of table: "card_cycle"
  """
  update_card_cycle_many(
    """updates to execute, in order"""
    updates: [card_cycle_updates!]!
  ): [card_cycle_mutation_response]

  """
  update data of the table: "card_encounter_set"
  """
  update_card_encounter_set(
    """sets the columns of the filtered rows to the given values"""
    _set: card_encounter_set_set_input

    """filter the rows which have to be updated"""
    where: card_encounter_set_bool_exp!
  ): card_encounter_set_mutation_response

  """
  update single row of the table: "card_encounter_set"
  """
  update_card_encounter_set_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: card_encounter_set_set_input
    pk_columns: card_encounter_set_pk_columns_input!
  ): card_encounter_set

  """
  update multiples rows of table: "card_encounter_set"
  """
  update_card_encounter_set_many(
    """updates to execute, in order"""
    updates: [card_encounter_set_updates!]!
  ): [card_encounter_set_mutation_response]

  """
  update multiples rows of table: "card"
  """
  update_card_many(
    """updates to execute, in order"""
    updates: [card_updates!]!
  ): [card_mutation_response]

  """
  update data of the table: "card_pack"
  """
  update_card_pack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: card_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_pack_set_input

    """filter the rows which have to be updated"""
    where: card_pack_bool_exp!
  ): card_pack_mutation_response

  """
  update single row of the table: "card_pack"
  """
  update_card_pack_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: card_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: card_pack_set_input
    pk_columns: card_pack_pk_columns_input!
  ): card_pack

  """
  update multiples rows of table: "card_pack"
  """
  update_card_pack_many(
    """updates to execute, in order"""
    updates: [card_pack_updates!]!
  ): [card_pack_mutation_response]

  """
  update data of the table: "card_subtype_name"
  """
  update_card_subtype_name(
    """sets the columns of the filtered rows to the given values"""
    _set: card_subtype_name_set_input

    """filter the rows which have to be updated"""
    where: card_subtype_name_bool_exp!
  ): card_subtype_name_mutation_response

  """
  update single row of the table: "card_subtype_name"
  """
  update_card_subtype_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: card_subtype_name_set_input
    pk_columns: card_subtype_name_pk_columns_input!
  ): card_subtype_name

  """
  update multiples rows of table: "card_subtype_name"
  """
  update_card_subtype_name_many(
    """updates to execute, in order"""
    updates: [card_subtype_name_updates!]!
  ): [card_subtype_name_mutation_response]

  """
  update data of the table: "card_text"
  """
  update_card_text(
    """sets the columns of the filtered rows to the given values"""
    _set: card_text_set_input

    """filter the rows which have to be updated"""
    where: card_text_bool_exp!
  ): card_text_mutation_response

  """
  update single row of the table: "card_text"
  """
  update_card_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: card_text_set_input
    pk_columns: card_text_pk_columns_input!
  ): card_text

  """
  update multiples rows of table: "card_text"
  """
  update_card_text_many(
    """updates to execute, in order"""
    updates: [card_text_updates!]!
  ): [card_text_mutation_response]

  """
  update data of the table: "card_type_code"
  """
  update_card_type_code(
    """sets the columns of the filtered rows to the given values"""
    _set: card_type_code_set_input

    """filter the rows which have to be updated"""
    where: card_type_code_bool_exp!
  ): card_type_code_mutation_response

  """
  update single row of the table: "card_type_code"
  """
  update_card_type_code_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: card_type_code_set_input
    pk_columns: card_type_code_pk_columns_input!
  ): card_type_code

  """
  update multiples rows of table: "card_type_code"
  """
  update_card_type_code_many(
    """updates to execute, in order"""
    updates: [card_type_code_updates!]!
  ): [card_type_code_mutation_response]

  """
  update data of the table: "card_type_name"
  """
  update_card_type_name(
    """sets the columns of the filtered rows to the given values"""
    _set: card_type_name_set_input

    """filter the rows which have to be updated"""
    where: card_type_name_bool_exp!
  ): card_type_name_mutation_response

  """
  update single row of the table: "card_type_name"
  """
  update_card_type_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: card_type_name_set_input
    pk_columns: card_type_name_pk_columns_input!
  ): card_type_name

  """
  update multiples rows of table: "card_type_name"
  """
  update_card_type_name_many(
    """updates to execute, in order"""
    updates: [card_type_name_updates!]!
  ): [card_type_name_mutation_response]

  """
  update data of the table: "chaos_bag_result"
  """
  update_chaos_bag_result(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chaos_bag_result_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chaos_bag_result_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: chaos_bag_result_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chaos_bag_result_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chaos_bag_result_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chaos_bag_result_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chaos_bag_result_set_input

    """filter the rows which have to be updated"""
    where: chaos_bag_result_bool_exp!
  ): chaos_bag_result_mutation_response

  """
  update single row of the table: "chaos_bag_result"
  """
  update_chaos_bag_result_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: chaos_bag_result_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: chaos_bag_result_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: chaos_bag_result_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: chaos_bag_result_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: chaos_bag_result_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: chaos_bag_result_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: chaos_bag_result_set_input
    pk_columns: chaos_bag_result_pk_columns_input!
  ): chaos_bag_result

  """
  update multiples rows of table: "chaos_bag_result"
  """
  update_chaos_bag_result_many(
    """updates to execute, in order"""
    updates: [chaos_bag_result_updates!]!
  ): [chaos_bag_result_mutation_response]

  """
  update data of the table: "chaos_bag_tarot_mode"
  """
  update_chaos_bag_tarot_mode(
    """sets the columns of the filtered rows to the given values"""
    _set: chaos_bag_tarot_mode_set_input

    """filter the rows which have to be updated"""
    where: chaos_bag_tarot_mode_bool_exp!
  ): chaos_bag_tarot_mode_mutation_response

  """
  update single row of the table: "chaos_bag_tarot_mode"
  """
  update_chaos_bag_tarot_mode_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: chaos_bag_tarot_mode_set_input
    pk_columns: chaos_bag_tarot_mode_pk_columns_input!
  ): chaos_bag_tarot_mode

  """
  update multiples rows of table: "chaos_bag_tarot_mode"
  """
  update_chaos_bag_tarot_mode_many(
    """updates to execute, in order"""
    updates: [chaos_bag_tarot_mode_updates!]!
  ): [chaos_bag_tarot_mode_mutation_response]

  """
  update data of the table: "conquest.card"
  """
  update_conquest_card(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conquest_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conquest_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conquest_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conquest_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conquest_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_card_set_input

    """filter the rows which have to be updated"""
    where: conquest_card_bool_exp!
  ): conquest_card_mutation_response

  """
  update single row of the table: "conquest.card"
  """
  update_conquest_card_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conquest_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conquest_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conquest_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conquest_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conquest_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_card_set_input
    pk_columns: conquest_card_pk_columns_input!
  ): conquest_card

  """
  update multiples rows of table: "conquest.card"
  """
  update_conquest_card_many(
    """updates to execute, in order"""
    updates: [conquest_card_updates!]!
  ): [conquest_card_mutation_response]

  """
  update data of the table: "conquest.card_text"
  """
  update_conquest_card_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_card_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_card_text_bool_exp!
  ): conquest_card_text_mutation_response

  """
  update single row of the table: "conquest.card_text"
  """
  update_conquest_card_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_card_text_set_input
    pk_columns: conquest_card_text_pk_columns_input!
  ): conquest_card_text

  """
  update multiples rows of table: "conquest.card_text"
  """
  update_conquest_card_text_many(
    """updates to execute, in order"""
    updates: [conquest_card_text_updates!]!
  ): [conquest_card_text_mutation_response]

  """
  update data of the table: "conquest.comment"
  """
  update_conquest_comment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_comment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_comment_set_input

    """filter the rows which have to be updated"""
    where: conquest_comment_bool_exp!
  ): conquest_comment_mutation_response

  """
  update single row of the table: "conquest.comment"
  """
  update_conquest_comment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_comment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_comment_set_input
    pk_columns: conquest_comment_pk_columns_input!
  ): conquest_comment

  """
  update multiples rows of table: "conquest.comment"
  """
  update_conquest_comment_many(
    """updates to execute, in order"""
    updates: [conquest_comment_updates!]!
  ): [conquest_comment_mutation_response]

  """
  update data of the table: "conquest.cycle"
  """
  update_conquest_cycle(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_cycle_set_input

    """filter the rows which have to be updated"""
    where: conquest_cycle_bool_exp!
  ): conquest_cycle_mutation_response

  """
  update single row of the table: "conquest.cycle"
  """
  update_conquest_cycle_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_cycle_set_input
    pk_columns: conquest_cycle_pk_columns_input!
  ): conquest_cycle

  """
  update multiples rows of table: "conquest.cycle"
  """
  update_conquest_cycle_many(
    """updates to execute, in order"""
    updates: [conquest_cycle_updates!]!
  ): [conquest_cycle_mutation_response]

  """
  update data of the table: "conquest.cycle_text"
  """
  update_conquest_cycle_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_cycle_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_cycle_text_bool_exp!
  ): conquest_cycle_text_mutation_response

  """
  update single row of the table: "conquest.cycle_text"
  """
  update_conquest_cycle_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_cycle_text_set_input
    pk_columns: conquest_cycle_text_pk_columns_input!
  ): conquest_cycle_text

  """
  update multiples rows of table: "conquest.cycle_text"
  """
  update_conquest_cycle_text_many(
    """updates to execute, in order"""
    updates: [conquest_cycle_text_updates!]!
  ): [conquest_cycle_text_mutation_response]

  """
  update data of the table: "conquest.deck"
  """
  update_conquest_deck(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conquest_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conquest_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conquest_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conquest_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conquest_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_set_input

    """filter the rows which have to be updated"""
    where: conquest_deck_bool_exp!
  ): conquest_deck_mutation_response

  """
  update single row of the table: "conquest.deck"
  """
  update_conquest_deck_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: conquest_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: conquest_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: conquest_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: conquest_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: conquest_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_set_input
    pk_columns: conquest_deck_pk_columns_input!
  ): conquest_deck

  """
  update data of the table: "conquest.deck_copy"
  """
  update_conquest_deck_copy(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_copy_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_copy_set_input

    """filter the rows which have to be updated"""
    where: conquest_deck_copy_bool_exp!
  ): conquest_deck_copy_mutation_response

  """
  update single row of the table: "conquest.deck_copy"
  """
  update_conquest_deck_copy_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_copy_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_copy_set_input
    pk_columns: conquest_deck_copy_pk_columns_input!
  ): conquest_deck_copy

  """
  update multiples rows of table: "conquest.deck_copy"
  """
  update_conquest_deck_copy_many(
    """updates to execute, in order"""
    updates: [conquest_deck_copy_updates!]!
  ): [conquest_deck_copy_mutation_response]

  """
  update data of the table: "conquest.deck_like"
  """
  update_conquest_deck_like(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_like_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_like_set_input

    """filter the rows which have to be updated"""
    where: conquest_deck_like_bool_exp!
  ): conquest_deck_like_mutation_response

  """
  update single row of the table: "conquest.deck_like"
  """
  update_conquest_deck_like_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_deck_like_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_deck_like_set_input
    pk_columns: conquest_deck_like_pk_columns_input!
  ): conquest_deck_like

  """
  update multiples rows of table: "conquest.deck_like"
  """
  update_conquest_deck_like_many(
    """updates to execute, in order"""
    updates: [conquest_deck_like_updates!]!
  ): [conquest_deck_like_mutation_response]

  """
  update multiples rows of table: "conquest.deck"
  """
  update_conquest_deck_many(
    """updates to execute, in order"""
    updates: [conquest_deck_updates!]!
  ): [conquest_deck_mutation_response]

  """
  update data of the table: "conquest.faction"
  """
  update_conquest_faction(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_faction_set_input

    """filter the rows which have to be updated"""
    where: conquest_faction_bool_exp!
  ): conquest_faction_mutation_response

  """
  update single row of the table: "conquest.faction"
  """
  update_conquest_faction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_faction_set_input
    pk_columns: conquest_faction_pk_columns_input!
  ): conquest_faction

  """
  update multiples rows of table: "conquest.faction"
  """
  update_conquest_faction_many(
    """updates to execute, in order"""
    updates: [conquest_faction_updates!]!
  ): [conquest_faction_mutation_response]

  """
  update data of the table: "conquest.faction_text"
  """
  update_conquest_faction_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_faction_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_faction_text_bool_exp!
  ): conquest_faction_text_mutation_response

  """
  update single row of the table: "conquest.faction_text"
  """
  update_conquest_faction_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_faction_text_set_input
    pk_columns: conquest_faction_text_pk_columns_input!
  ): conquest_faction_text

  """
  update multiples rows of table: "conquest.faction_text"
  """
  update_conquest_faction_text_many(
    """updates to execute, in order"""
    updates: [conquest_faction_text_updates!]!
  ): [conquest_faction_text_mutation_response]

  """
  update data of the table: "conquest.loyalty"
  """
  update_conquest_loyalty(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_loyalty_set_input

    """filter the rows which have to be updated"""
    where: conquest_loyalty_bool_exp!
  ): conquest_loyalty_mutation_response

  """
  update single row of the table: "conquest.loyalty"
  """
  update_conquest_loyalty_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_loyalty_set_input
    pk_columns: conquest_loyalty_pk_columns_input!
  ): conquest_loyalty

  """
  update multiples rows of table: "conquest.loyalty"
  """
  update_conquest_loyalty_many(
    """updates to execute, in order"""
    updates: [conquest_loyalty_updates!]!
  ): [conquest_loyalty_mutation_response]

  """
  update data of the table: "conquest.loyalty_text"
  """
  update_conquest_loyalty_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_loyalty_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_loyalty_text_bool_exp!
  ): conquest_loyalty_text_mutation_response

  """
  update single row of the table: "conquest.loyalty_text"
  """
  update_conquest_loyalty_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_loyalty_text_set_input
    pk_columns: conquest_loyalty_text_pk_columns_input!
  ): conquest_loyalty_text

  """
  update multiples rows of table: "conquest.loyalty_text"
  """
  update_conquest_loyalty_text_many(
    """updates to execute, in order"""
    updates: [conquest_loyalty_text_updates!]!
  ): [conquest_loyalty_text_mutation_response]

  """
  update data of the table: "conquest.pack"
  """
  update_conquest_pack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_pack_set_input

    """filter the rows which have to be updated"""
    where: conquest_pack_bool_exp!
  ): conquest_pack_mutation_response

  """
  update single row of the table: "conquest.pack"
  """
  update_conquest_pack_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conquest_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conquest_pack_set_input
    pk_columns: conquest_pack_pk_columns_input!
  ): conquest_pack

  """
  update multiples rows of table: "conquest.pack"
  """
  update_conquest_pack_many(
    """updates to execute, in order"""
    updates: [conquest_pack_updates!]!
  ): [conquest_pack_mutation_response]

  """
  update data of the table: "conquest.pack_text"
  """
  update_conquest_pack_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_pack_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_pack_text_bool_exp!
  ): conquest_pack_text_mutation_response

  """
  update single row of the table: "conquest.pack_text"
  """
  update_conquest_pack_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_pack_text_set_input
    pk_columns: conquest_pack_text_pk_columns_input!
  ): conquest_pack_text

  """
  update multiples rows of table: "conquest.pack_text"
  """
  update_conquest_pack_text_many(
    """updates to execute, in order"""
    updates: [conquest_pack_text_updates!]!
  ): [conquest_pack_text_mutation_response]

  """
  update data of the table: "conquest.type"
  """
  update_conquest_type(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_type_set_input

    """filter the rows which have to be updated"""
    where: conquest_type_bool_exp!
  ): conquest_type_mutation_response

  """
  update single row of the table: "conquest.type"
  """
  update_conquest_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_type_set_input
    pk_columns: conquest_type_pk_columns_input!
  ): conquest_type

  """
  update multiples rows of table: "conquest.type"
  """
  update_conquest_type_many(
    """updates to execute, in order"""
    updates: [conquest_type_updates!]!
  ): [conquest_type_mutation_response]

  """
  update data of the table: "conquest.type_text"
  """
  update_conquest_type_text(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_type_text_set_input

    """filter the rows which have to be updated"""
    where: conquest_type_text_bool_exp!
  ): conquest_type_text_mutation_response

  """
  update single row of the table: "conquest.type_text"
  """
  update_conquest_type_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_type_text_set_input
    pk_columns: conquest_type_text_pk_columns_input!
  ): conquest_type_text

  """
  update multiples rows of table: "conquest.type_text"
  """
  update_conquest_type_text_many(
    """updates to execute, in order"""
    updates: [conquest_type_text_updates!]!
  ): [conquest_type_text_mutation_response]

  """
  update data of the table: "conquest.user_role"
  """
  update_conquest_user_role(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_user_role_set_input

    """filter the rows which have to be updated"""
    where: conquest_user_role_bool_exp!
  ): conquest_user_role_mutation_response

  """
  update single row of the table: "conquest.user_role"
  """
  update_conquest_user_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_user_role_set_input
    pk_columns: conquest_user_role_pk_columns_input!
  ): conquest_user_role

  """
  update multiples rows of table: "conquest.user_role"
  """
  update_conquest_user_role_many(
    """updates to execute, in order"""
    updates: [conquest_user_role_updates!]!
  ): [conquest_user_role_mutation_response]

  """
  update data of the table: "conquest.user_settings"
  """
  update_conquest_user_settings(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_user_settings_set_input

    """filter the rows which have to be updated"""
    where: conquest_user_settings_bool_exp!
  ): conquest_user_settings_mutation_response

  """
  update single row of the table: "conquest.user_settings"
  """
  update_conquest_user_settings_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_user_settings_set_input
    pk_columns: conquest_user_settings_pk_columns_input!
  ): conquest_user_settings

  """
  update multiples rows of table: "conquest.user_settings"
  """
  update_conquest_user_settings_many(
    """updates to execute, in order"""
    updates: [conquest_user_settings_updates!]!
  ): [conquest_user_settings_mutation_response]

  """
  update data of the table: "conquest.users"
  """
  update_conquest_users(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_users_set_input

    """filter the rows which have to be updated"""
    where: conquest_users_bool_exp!
  ): conquest_users_mutation_response

  """
  update single row of the table: "conquest.users"
  """
  update_conquest_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: conquest_users_set_input
    pk_columns: conquest_users_pk_columns_input!
  ): conquest_users

  """
  update multiples rows of table: "conquest.users"
  """
  update_conquest_users_many(
    """updates to execute, in order"""
    updates: [conquest_users_updates!]!
  ): [conquest_users_mutation_response]

  """
  update data of the table: "cycle"
  """
  update_cycle(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cycle_set_input

    """filter the rows which have to be updated"""
    where: cycle_bool_exp!
  ): cycle_mutation_response

  """
  update single row of the table: "cycle"
  """
  update_cycle_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cycle_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cycle_set_input
    pk_columns: cycle_pk_columns_input!
  ): cycle

  """
  update multiples rows of table: "cycle"
  """
  update_cycle_many(
    """updates to execute, in order"""
    updates: [cycle_updates!]!
  ): [cycle_mutation_response]

  """
  update data of the table: "cycle_name"
  """
  update_cycle_name(
    """sets the columns of the filtered rows to the given values"""
    _set: cycle_name_set_input

    """filter the rows which have to be updated"""
    where: cycle_name_bool_exp!
  ): cycle_name_mutation_response

  """
  update single row of the table: "cycle_name"
  """
  update_cycle_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: cycle_name_set_input
    pk_columns: cycle_name_pk_columns_input!
  ): cycle_name

  """
  update multiples rows of table: "cycle_name"
  """
  update_cycle_name_many(
    """updates to execute, in order"""
    updates: [cycle_name_updates!]!
  ): [cycle_name_mutation_response]

  """
  update data of the table: "faction_name"
  """
  update_faction_name(
    """sets the columns of the filtered rows to the given values"""
    _set: faction_name_set_input

    """filter the rows which have to be updated"""
    where: faction_name_bool_exp!
  ): faction_name_mutation_response

  """
  update single row of the table: "faction_name"
  """
  update_faction_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: faction_name_set_input
    pk_columns: faction_name_pk_columns_input!
  ): faction_name

  """
  update multiples rows of table: "faction_name"
  """
  update_faction_name_many(
    """updates to execute, in order"""
    updates: [faction_name_updates!]!
  ): [faction_name_mutation_response]

  """
  update data of the table: "faq"
  """
  update_faq(
    """sets the columns of the filtered rows to the given values"""
    _set: faq_set_input

    """filter the rows which have to be updated"""
    where: faq_bool_exp!
  ): faq_mutation_response

  """
  update single row of the table: "faq"
  """
  update_faq_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: faq_set_input
    pk_columns: faq_pk_columns_input!
  ): faq

  """
  update multiples rows of table: "faq"
  """
  update_faq_many(
    """updates to execute, in order"""
    updates: [faq_updates!]!
  ): [faq_mutation_response]

  """
  update data of the table: "faq_text"
  """
  update_faq_text(
    """sets the columns of the filtered rows to the given values"""
    _set: faq_text_set_input

    """filter the rows which have to be updated"""
    where: faq_text_bool_exp!
  ): faq_text_mutation_response

  """
  update single row of the table: "faq_text"
  """
  update_faq_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: faq_text_set_input
    pk_columns: faq_text_pk_columns_input!
  ): faq_text

  """
  update multiples rows of table: "faq_text"
  """
  update_faq_text_many(
    """updates to execute, in order"""
    updates: [faq_text_updates!]!
  ): [faq_text_mutation_response]

  """
  update data of the table: "friend_status"
  """
  update_friend_status(
    """sets the columns of the filtered rows to the given values"""
    _set: friend_status_set_input

    """filter the rows which have to be updated"""
    where: friend_status_bool_exp!
  ): friend_status_mutation_response

  """
  update single row of the table: "friend_status"
  """
  update_friend_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: friend_status_set_input
    pk_columns: friend_status_pk_columns_input!
  ): friend_status

  """
  update multiples rows of table: "friend_status"
  """
  update_friend_status_many(
    """updates to execute, in order"""
    updates: [friend_status_updates!]!
  ): [friend_status_mutation_response]

  """
  update data of the table: "friend_status_type"
  """
  update_friend_status_type(
    """sets the columns of the filtered rows to the given values"""
    _set: friend_status_type_set_input

    """filter the rows which have to be updated"""
    where: friend_status_type_bool_exp!
  ): friend_status_type_mutation_response

  """
  update single row of the table: "friend_status_type"
  """
  update_friend_status_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: friend_status_type_set_input
    pk_columns: friend_status_type_pk_columns_input!
  ): friend_status_type

  """
  update multiples rows of table: "friend_status_type"
  """
  update_friend_status_type_many(
    """updates to execute, in order"""
    updates: [friend_status_type_updates!]!
  ): [friend_status_type_mutation_response]

  """
  update data of the table: "full_card"
  """
  update_full_card(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: full_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: full_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: full_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: full_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: full_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: full_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: full_card_set_input

    """filter the rows which have to be updated"""
    where: full_card_bool_exp!
  ): full_card_mutation_response

  """
  update single row of the table: "full_card"
  """
  update_full_card_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: full_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: full_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: full_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: full_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: full_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: full_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: full_card_set_input
    pk_columns: full_card_pk_columns_input!
  ): full_card

  """
  update multiples rows of table: "full_card"
  """
  update_full_card_many(
    """updates to execute, in order"""
    updates: [full_card_updates!]!
  ): [full_card_mutation_response]

  """
  update data of the table: "full_card_text"
  """
  update_full_card_text(
    """sets the columns of the filtered rows to the given values"""
    _set: full_card_text_set_input

    """filter the rows which have to be updated"""
    where: full_card_text_bool_exp!
  ): full_card_text_mutation_response

  """
  update single row of the table: "full_card_text"
  """
  update_full_card_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: full_card_text_set_input
    pk_columns: full_card_text_pk_columns_input!
  ): full_card_text

  """
  update multiples rows of table: "full_card_text"
  """
  update_full_card_text_many(
    """updates to execute, in order"""
    updates: [full_card_text_updates!]!
  ): [full_card_text_mutation_response]

  """
  update data of the table: "gender"
  """
  update_gender(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input

    """filter the rows which have to be updated"""
    where: gender_bool_exp!
  ): gender_mutation_response

  """
  update single row of the table: "gender"
  """
  update_gender_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_set_input
    pk_columns: gender_pk_columns_input!
  ): gender

  """
  update multiples rows of table: "gender"
  """
  update_gender_many(
    """updates to execute, in order"""
    updates: [gender_updates!]!
  ): [gender_mutation_response]

  """
  update data of the table: "guide_achievement"
  """
  update_guide_achievement(
    """increments the numeric columns with given value of the filtered values"""
    _inc: guide_achievement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: guide_achievement_set_input

    """filter the rows which have to be updated"""
    where: guide_achievement_bool_exp!
  ): guide_achievement_mutation_response

  """
  update single row of the table: "guide_achievement"
  """
  update_guide_achievement_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: guide_achievement_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: guide_achievement_set_input
    pk_columns: guide_achievement_pk_columns_input!
  ): guide_achievement

  """
  update multiples rows of table: "guide_achievement"
  """
  update_guide_achievement_many(
    """updates to execute, in order"""
    updates: [guide_achievement_updates!]!
  ): [guide_achievement_mutation_response]

  """
  update data of the table: "guide_input"
  """
  update_guide_input(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: guide_input_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: guide_input_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: guide_input_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: guide_input_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: guide_input_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: guide_input_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: guide_input_set_input

    """filter the rows which have to be updated"""
    where: guide_input_bool_exp!
  ): guide_input_mutation_response

  """
  update single row of the table: "guide_input"
  """
  update_guide_input_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: guide_input_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: guide_input_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: guide_input_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: guide_input_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: guide_input_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: guide_input_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: guide_input_set_input
    pk_columns: guide_input_pk_columns_input!
  ): guide_input

  """
  update multiples rows of table: "guide_input"
  """
  update_guide_input_many(
    """updates to execute, in order"""
    updates: [guide_input_updates!]!
  ): [guide_input_mutation_response]

  """
  update data of the table: "investigator_data"
  """
  update_investigator_data(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: investigator_data_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: investigator_data_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: investigator_data_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: investigator_data_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: investigator_data_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: investigator_data_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: investigator_data_set_input

    """filter the rows which have to be updated"""
    where: investigator_data_bool_exp!
  ): investigator_data_mutation_response

  """
  update single row of the table: "investigator_data"
  """
  update_investigator_data_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: investigator_data_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: investigator_data_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: investigator_data_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: investigator_data_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: investigator_data_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: investigator_data_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: investigator_data_set_input
    pk_columns: investigator_data_pk_columns_input!
  ): investigator_data

  """
  update multiples rows of table: "investigator_data"
  """
  update_investigator_data_many(
    """updates to execute, in order"""
    updates: [investigator_data_updates!]!
  ): [investigator_data_mutation_response]

  """
  update data of the table: "latest_decks"
  """
  update_latest_decks(
    """increments the numeric columns with given value of the filtered values"""
    _inc: latest_decks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: latest_decks_set_input

    """filter the rows which have to be updated"""
    where: latest_decks_bool_exp!
  ): latest_decks_mutation_response

  """
  update multiples rows of table: "latest_decks"
  """
  update_latest_decks_many(
    """updates to execute, in order"""
    updates: [latest_decks_updates!]!
  ): [latest_decks_mutation_response]

  """
  update data of the table: "local_decks"
  """
  update_local_decks(
    """increments the numeric columns with given value of the filtered values"""
    _inc: local_decks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: local_decks_set_input

    """filter the rows which have to be updated"""
    where: local_decks_bool_exp!
  ): local_decks_mutation_response

  """
  update multiples rows of table: "local_decks"
  """
  update_local_decks_many(
    """updates to execute, in order"""
    updates: [local_decks_updates!]!
  ): [local_decks_mutation_response]

  """
  update data of the table: "pack"
  """
  update_pack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pack_set_input

    """filter the rows which have to be updated"""
    where: pack_bool_exp!
  ): pack_mutation_response

  """
  update single row of the table: "pack"
  """
  update_pack_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pack_set_input
    pk_columns: pack_pk_columns_input!
  ): pack

  """
  update multiples rows of table: "pack"
  """
  update_pack_many(
    """updates to execute, in order"""
    updates: [pack_updates!]!
  ): [pack_mutation_response]

  """
  update data of the table: "pack_name"
  """
  update_pack_name(
    """sets the columns of the filtered rows to the given values"""
    _set: pack_name_set_input

    """filter the rows which have to be updated"""
    where: pack_name_bool_exp!
  ): pack_name_mutation_response

  """
  update single row of the table: "pack_name"
  """
  update_pack_name_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: pack_name_set_input
    pk_columns: pack_name_pk_columns_input!
  ): pack_name

  """
  update multiples rows of table: "pack_name"
  """
  update_pack_name_many(
    """updates to execute, in order"""
    updates: [pack_name_updates!]!
  ): [pack_name_mutation_response]

  """
  update data of the table: "rangers.area"
  """
  update_rangers_area(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_area_set_input

    """filter the rows which have to be updated"""
    where: rangers_area_bool_exp!
  ): rangers_area_mutation_response

  """
  update single row of the table: "rangers.area"
  """
  update_rangers_area_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_area_set_input
    pk_columns: rangers_area_pk_columns_input!
  ): rangers_area

  """
  update multiples rows of table: "rangers.area"
  """
  update_rangers_area_many(
    """updates to execute, in order"""
    updates: [rangers_area_updates!]!
  ): [rangers_area_mutation_response]

  """
  update data of the table: "rangers.area_text"
  """
  update_rangers_area_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_area_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_area_text_bool_exp!
  ): rangers_area_text_mutation_response

  """
  update single row of the table: "rangers.area_text"
  """
  update_rangers_area_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_area_text_set_input
    pk_columns: rangers_area_text_pk_columns_input!
  ): rangers_area_text

  """
  update multiples rows of table: "rangers.area_text"
  """
  update_rangers_area_text_many(
    """updates to execute, in order"""
    updates: [rangers_area_text_updates!]!
  ): [rangers_area_text_mutation_response]

  """
  update data of the table: "rangers.aspect"
  """
  update_rangers_aspect(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_aspect_set_input

    """filter the rows which have to be updated"""
    where: rangers_aspect_bool_exp!
  ): rangers_aspect_mutation_response

  """
  update single row of the table: "rangers.aspect"
  """
  update_rangers_aspect_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_aspect_set_input
    pk_columns: rangers_aspect_pk_columns_input!
  ): rangers_aspect

  """
  update multiples rows of table: "rangers.aspect"
  """
  update_rangers_aspect_many(
    """updates to execute, in order"""
    updates: [rangers_aspect_updates!]!
  ): [rangers_aspect_mutation_response]

  """
  update data of the table: "rangers.aspect_text"
  """
  update_rangers_aspect_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_aspect_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_aspect_text_bool_exp!
  ): rangers_aspect_text_mutation_response

  """
  update single row of the table: "rangers.aspect_text"
  """
  update_rangers_aspect_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_aspect_text_set_input
    pk_columns: rangers_aspect_text_pk_columns_input!
  ): rangers_aspect_text

  """
  update multiples rows of table: "rangers.aspect_text"
  """
  update_rangers_aspect_text_many(
    """updates to execute, in order"""
    updates: [rangers_aspect_text_updates!]!
  ): [rangers_aspect_text_mutation_response]

  """
  update data of the table: "rangers.campaign"
  """
  update_rangers_campaign(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_campaign_set_input

    """filter the rows which have to be updated"""
    where: rangers_campaign_bool_exp!
  ): rangers_campaign_mutation_response

  """
  update data of the table: "rangers.campaign_access"
  """
  update_rangers_campaign_access(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_campaign_access_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_campaign_access_set_input

    """filter the rows which have to be updated"""
    where: rangers_campaign_access_bool_exp!
  ): rangers_campaign_access_mutation_response

  """
  update single row of the table: "rangers.campaign_access"
  """
  update_rangers_campaign_access_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_campaign_access_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_campaign_access_set_input
    pk_columns: rangers_campaign_access_pk_columns_input!
  ): rangers_campaign_access

  """
  update multiples rows of table: "rangers.campaign_access"
  """
  update_rangers_campaign_access_many(
    """updates to execute, in order"""
    updates: [rangers_campaign_access_updates!]!
  ): [rangers_campaign_access_mutation_response]

  """
  update single row of the table: "rangers.campaign"
  """
  update_rangers_campaign_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_campaign_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_campaign_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_campaign_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_campaign_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_campaign_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_campaign_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_campaign_set_input
    pk_columns: rangers_campaign_pk_columns_input!
  ): rangers_campaign

  """
  update multiples rows of table: "rangers.campaign"
  """
  update_rangers_campaign_many(
    """updates to execute, in order"""
    updates: [rangers_campaign_updates!]!
  ): [rangers_campaign_mutation_response]

  """
  update data of the table: "rangers.card"
  """
  update_rangers_card(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_card_set_input

    """filter the rows which have to be updated"""
    where: rangers_card_bool_exp!
  ): rangers_card_mutation_response

  """
  update single row of the table: "rangers.card"
  """
  update_rangers_card_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_card_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_card_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_card_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_card_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_card_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_card_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_card_set_input
    pk_columns: rangers_card_pk_columns_input!
  ): rangers_card

  """
  update multiples rows of table: "rangers.card"
  """
  update_rangers_card_many(
    """updates to execute, in order"""
    updates: [rangers_card_updates!]!
  ): [rangers_card_mutation_response]

  """
  update data of the table: "rangers.card_text"
  """
  update_rangers_card_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_card_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_card_text_bool_exp!
  ): rangers_card_text_mutation_response

  """
  update single row of the table: "rangers.card_text"
  """
  update_rangers_card_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_card_text_set_input
    pk_columns: rangers_card_text_pk_columns_input!
  ): rangers_card_text

  """
  update multiples rows of table: "rangers.card_text"
  """
  update_rangers_card_text_many(
    """updates to execute, in order"""
    updates: [rangers_card_text_updates!]!
  ): [rangers_card_text_mutation_response]

  """
  update data of the table: "rangers.comment"
  """
  update_rangers_comment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_comment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_comment_set_input

    """filter the rows which have to be updated"""
    where: rangers_comment_bool_exp!
  ): rangers_comment_mutation_response

  """
  update single row of the table: "rangers.comment"
  """
  update_rangers_comment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_comment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_comment_set_input
    pk_columns: rangers_comment_pk_columns_input!
  ): rangers_comment

  """
  update multiples rows of table: "rangers.comment"
  """
  update_rangers_comment_many(
    """updates to execute, in order"""
    updates: [rangers_comment_updates!]!
  ): [rangers_comment_mutation_response]

  """
  update data of the table: "rangers.deck"
  """
  update_rangers_deck(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_set_input

    """filter the rows which have to be updated"""
    where: rangers_deck_bool_exp!
  ): rangers_deck_mutation_response

  """
  update single row of the table: "rangers.deck"
  """
  update_rangers_deck_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_set_input
    pk_columns: rangers_deck_pk_columns_input!
  ): rangers_deck

  """
  update data of the table: "rangers.deck_copy"
  """
  update_rangers_deck_copy(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_copy_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_copy_set_input

    """filter the rows which have to be updated"""
    where: rangers_deck_copy_bool_exp!
  ): rangers_deck_copy_mutation_response

  """
  update single row of the table: "rangers.deck_copy"
  """
  update_rangers_deck_copy_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_copy_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_copy_set_input
    pk_columns: rangers_deck_copy_pk_columns_input!
  ): rangers_deck_copy

  """
  update multiples rows of table: "rangers.deck_copy"
  """
  update_rangers_deck_copy_many(
    """updates to execute, in order"""
    updates: [rangers_deck_copy_updates!]!
  ): [rangers_deck_copy_mutation_response]

  """
  update data of the table: "rangers.deck_like"
  """
  update_rangers_deck_like(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_like_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_like_set_input

    """filter the rows which have to be updated"""
    where: rangers_deck_like_bool_exp!
  ): rangers_deck_like_mutation_response

  """
  update single row of the table: "rangers.deck_like"
  """
  update_rangers_deck_like_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_like_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_like_set_input
    pk_columns: rangers_deck_like_pk_columns_input!
  ): rangers_deck_like

  """
  update data of the table: "rangers.deck_like_count"
  """
  update_rangers_deck_like_count(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_like_count_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_like_count_set_input

    """filter the rows which have to be updated"""
    where: rangers_deck_like_count_bool_exp!
  ): rangers_deck_like_count_mutation_response

  """
  update single row of the table: "rangers.deck_like_count"
  """
  update_rangers_deck_like_count_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_deck_like_count_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_deck_like_count_set_input
    pk_columns: rangers_deck_like_count_pk_columns_input!
  ): rangers_deck_like_count

  """
  update multiples rows of table: "rangers.deck_like_count"
  """
  update_rangers_deck_like_count_many(
    """updates to execute, in order"""
    updates: [rangers_deck_like_count_updates!]!
  ): [rangers_deck_like_count_mutation_response]

  """
  update multiples rows of table: "rangers.deck_like"
  """
  update_rangers_deck_like_many(
    """updates to execute, in order"""
    updates: [rangers_deck_like_updates!]!
  ): [rangers_deck_like_mutation_response]

  """
  update multiples rows of table: "rangers.deck"
  """
  update_rangers_deck_many(
    """updates to execute, in order"""
    updates: [rangers_deck_updates!]!
  ): [rangers_deck_mutation_response]

  """
  update data of the table: "rangers.faq_entry"
  """
  update_rangers_faq_entry(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_faq_entry_set_input

    """filter the rows which have to be updated"""
    where: rangers_faq_entry_bool_exp!
  ): rangers_faq_entry_mutation_response

  """
  update single row of the table: "rangers.faq_entry"
  """
  update_rangers_faq_entry_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_faq_entry_set_input
    pk_columns: rangers_faq_entry_pk_columns_input!
  ): rangers_faq_entry

  """
  update multiples rows of table: "rangers.faq_entry"
  """
  update_rangers_faq_entry_many(
    """updates to execute, in order"""
    updates: [rangers_faq_entry_updates!]!
  ): [rangers_faq_entry_mutation_response]

  """
  update data of the table: "rangers.friend_status"
  """
  update_rangers_friend_status(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_friend_status_set_input

    """filter the rows which have to be updated"""
    where: rangers_friend_status_bool_exp!
  ): rangers_friend_status_mutation_response

  """
  update single row of the table: "rangers.friend_status"
  """
  update_rangers_friend_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_friend_status_set_input
    pk_columns: rangers_friend_status_pk_columns_input!
  ): rangers_friend_status

  """
  update multiples rows of table: "rangers.friend_status"
  """
  update_rangers_friend_status_many(
    """updates to execute, in order"""
    updates: [rangers_friend_status_updates!]!
  ): [rangers_friend_status_mutation_response]

  """
  update data of the table: "rangers.friend_status_type"
  """
  update_rangers_friend_status_type(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_friend_status_type_set_input

    """filter the rows which have to be updated"""
    where: rangers_friend_status_type_bool_exp!
  ): rangers_friend_status_type_mutation_response

  """
  update single row of the table: "rangers.friend_status_type"
  """
  update_rangers_friend_status_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_friend_status_type_set_input
    pk_columns: rangers_friend_status_type_pk_columns_input!
  ): rangers_friend_status_type

  """
  update multiples rows of table: "rangers.friend_status_type"
  """
  update_rangers_friend_status_type_many(
    """updates to execute, in order"""
    updates: [rangers_friend_status_type_updates!]!
  ): [rangers_friend_status_type_mutation_response]

  """
  update data of the table: "rangers.latest_deck"
  """
  update_rangers_latest_deck(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_latest_deck_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_latest_deck_set_input

    """filter the rows which have to be updated"""
    where: rangers_latest_deck_bool_exp!
  ): rangers_latest_deck_mutation_response

  """
  update multiples rows of table: "rangers.latest_deck"
  """
  update_rangers_latest_deck_many(
    """updates to execute, in order"""
    updates: [rangers_latest_deck_updates!]!
  ): [rangers_latest_deck_mutation_response]

  """
  update data of the table: "rangers.locale"
  """
  update_rangers_locale(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_locale_set_input

    """filter the rows which have to be updated"""
    where: rangers_locale_bool_exp!
  ): rangers_locale_mutation_response

  """
  update single row of the table: "rangers.locale"
  """
  update_rangers_locale_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_locale_set_input
    pk_columns: rangers_locale_pk_columns_input!
  ): rangers_locale

  """
  update multiples rows of table: "rangers.locale"
  """
  update_rangers_locale_many(
    """updates to execute, in order"""
    updates: [rangers_locale_updates!]!
  ): [rangers_locale_mutation_response]

  """
  update data of the table: "rangers.pack"
  """
  update_rangers_pack(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_pack_set_input

    """filter the rows which have to be updated"""
    where: rangers_pack_bool_exp!
  ): rangers_pack_mutation_response

  """
  update single row of the table: "rangers.pack"
  """
  update_rangers_pack_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_pack_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_pack_set_input
    pk_columns: rangers_pack_pk_columns_input!
  ): rangers_pack

  """
  update multiples rows of table: "rangers.pack"
  """
  update_rangers_pack_many(
    """updates to execute, in order"""
    updates: [rangers_pack_updates!]!
  ): [rangers_pack_mutation_response]

  """
  update data of the table: "rangers.pack_text"
  """
  update_rangers_pack_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_pack_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_pack_text_bool_exp!
  ): rangers_pack_text_mutation_response

  """
  update single row of the table: "rangers.pack_text"
  """
  update_rangers_pack_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_pack_text_set_input
    pk_columns: rangers_pack_text_pk_columns_input!
  ): rangers_pack_text

  """
  update multiples rows of table: "rangers.pack_text"
  """
  update_rangers_pack_text_many(
    """updates to execute, in order"""
    updates: [rangers_pack_text_updates!]!
  ): [rangers_pack_text_mutation_response]

  """
  update data of the table: "rangers.search_deck"
  """
  update_rangers_search_deck(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_search_deck_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_search_deck_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_search_deck_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_search_deck_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_search_deck_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_search_deck_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_search_deck_set_input

    """filter the rows which have to be updated"""
    where: rangers_search_deck_bool_exp!
  ): rangers_search_deck_mutation_response

  """
  update multiples rows of table: "rangers.search_deck"
  """
  update_rangers_search_deck_many(
    """updates to execute, in order"""
    updates: [rangers_search_deck_updates!]!
  ): [rangers_search_deck_mutation_response]

  """
  update data of the table: "rangers.set"
  """
  update_rangers_set(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_set_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_set_input

    """filter the rows which have to be updated"""
    where: rangers_set_bool_exp!
  ): rangers_set_mutation_response

  """
  update single row of the table: "rangers.set"
  """
  update_rangers_set_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_set_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_set_input
    pk_columns: rangers_set_pk_columns_input!
  ): rangers_set

  """
  update multiples rows of table: "rangers.set"
  """
  update_rangers_set_many(
    """updates to execute, in order"""
    updates: [rangers_set_updates!]!
  ): [rangers_set_mutation_response]

  """
  update data of the table: "rangers.set_text"
  """
  update_rangers_set_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_set_text_bool_exp!
  ): rangers_set_text_mutation_response

  """
  update single row of the table: "rangers.set_text"
  """
  update_rangers_set_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_text_set_input
    pk_columns: rangers_set_text_pk_columns_input!
  ): rangers_set_text

  """
  update multiples rows of table: "rangers.set_text"
  """
  update_rangers_set_text_many(
    """updates to execute, in order"""
    updates: [rangers_set_text_updates!]!
  ): [rangers_set_text_mutation_response]

  """
  update data of the table: "rangers.set_type"
  """
  update_rangers_set_type(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_type_set_input

    """filter the rows which have to be updated"""
    where: rangers_set_type_bool_exp!
  ): rangers_set_type_mutation_response

  """
  update single row of the table: "rangers.set_type"
  """
  update_rangers_set_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_type_set_input
    pk_columns: rangers_set_type_pk_columns_input!
  ): rangers_set_type

  """
  update multiples rows of table: "rangers.set_type"
  """
  update_rangers_set_type_many(
    """updates to execute, in order"""
    updates: [rangers_set_type_updates!]!
  ): [rangers_set_type_mutation_response]

  """
  update data of the table: "rangers.set_type_text"
  """
  update_rangers_set_type_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_type_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_set_type_text_bool_exp!
  ): rangers_set_type_text_mutation_response

  """
  update single row of the table: "rangers.set_type_text"
  """
  update_rangers_set_type_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_set_type_text_set_input
    pk_columns: rangers_set_type_text_pk_columns_input!
  ): rangers_set_type_text

  """
  update multiples rows of table: "rangers.set_type_text"
  """
  update_rangers_set_type_text_many(
    """updates to execute, in order"""
    updates: [rangers_set_type_text_updates!]!
  ): [rangers_set_type_text_mutation_response]

  """
  update data of the table: "rangers.subset"
  """
  update_rangers_subset(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_subset_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_subset_set_input

    """filter the rows which have to be updated"""
    where: rangers_subset_bool_exp!
  ): rangers_subset_mutation_response

  """
  update single row of the table: "rangers.subset"
  """
  update_rangers_subset_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rangers_subset_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_subset_set_input
    pk_columns: rangers_subset_pk_columns_input!
  ): rangers_subset

  """
  update multiples rows of table: "rangers.subset"
  """
  update_rangers_subset_many(
    """updates to execute, in order"""
    updates: [rangers_subset_updates!]!
  ): [rangers_subset_mutation_response]

  """
  update data of the table: "rangers.subset_text"
  """
  update_rangers_subset_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_subset_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_subset_text_bool_exp!
  ): rangers_subset_text_mutation_response

  """
  update single row of the table: "rangers.subset_text"
  """
  update_rangers_subset_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_subset_text_set_input
    pk_columns: rangers_subset_text_pk_columns_input!
  ): rangers_subset_text

  """
  update multiples rows of table: "rangers.subset_text"
  """
  update_rangers_subset_text_many(
    """updates to execute, in order"""
    updates: [rangers_subset_text_updates!]!
  ): [rangers_subset_text_mutation_response]

  """
  update data of the table: "rangers.taboo_set"
  """
  update_rangers_taboo_set(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_taboo_set_set_input

    """filter the rows which have to be updated"""
    where: rangers_taboo_set_bool_exp!
  ): rangers_taboo_set_mutation_response

  """
  update single row of the table: "rangers.taboo_set"
  """
  update_rangers_taboo_set_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_taboo_set_set_input
    pk_columns: rangers_taboo_set_pk_columns_input!
  ): rangers_taboo_set

  """
  update multiples rows of table: "rangers.taboo_set"
  """
  update_rangers_taboo_set_many(
    """updates to execute, in order"""
    updates: [rangers_taboo_set_updates!]!
  ): [rangers_taboo_set_mutation_response]

  """
  update data of the table: "rangers.taboo_set_text"
  """
  update_rangers_taboo_set_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_taboo_set_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_taboo_set_text_bool_exp!
  ): rangers_taboo_set_text_mutation_response

  """
  update single row of the table: "rangers.taboo_set_text"
  """
  update_rangers_taboo_set_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_taboo_set_text_set_input
    pk_columns: rangers_taboo_set_text_pk_columns_input!
  ): rangers_taboo_set_text

  """
  update multiples rows of table: "rangers.taboo_set_text"
  """
  update_rangers_taboo_set_text_many(
    """updates to execute, in order"""
    updates: [rangers_taboo_set_text_updates!]!
  ): [rangers_taboo_set_text_mutation_response]

  """
  update data of the table: "rangers.token"
  """
  update_rangers_token(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_token_set_input

    """filter the rows which have to be updated"""
    where: rangers_token_bool_exp!
  ): rangers_token_mutation_response

  """
  update single row of the table: "rangers.token"
  """
  update_rangers_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_token_set_input
    pk_columns: rangers_token_pk_columns_input!
  ): rangers_token

  """
  update multiples rows of table: "rangers.token"
  """
  update_rangers_token_many(
    """updates to execute, in order"""
    updates: [rangers_token_updates!]!
  ): [rangers_token_mutation_response]

  """
  update data of the table: "rangers.token_text"
  """
  update_rangers_token_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_token_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_token_text_bool_exp!
  ): rangers_token_text_mutation_response

  """
  update single row of the table: "rangers.token_text"
  """
  update_rangers_token_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_token_text_set_input
    pk_columns: rangers_token_text_pk_columns_input!
  ): rangers_token_text

  """
  update multiples rows of table: "rangers.token_text"
  """
  update_rangers_token_text_many(
    """updates to execute, in order"""
    updates: [rangers_token_text_updates!]!
  ): [rangers_token_text_mutation_response]

  """
  update data of the table: "rangers.type"
  """
  update_rangers_type(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_type_set_input

    """filter the rows which have to be updated"""
    where: rangers_type_bool_exp!
  ): rangers_type_mutation_response

  """
  update single row of the table: "rangers.type"
  """
  update_rangers_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_type_set_input
    pk_columns: rangers_type_pk_columns_input!
  ): rangers_type

  """
  update multiples rows of table: "rangers.type"
  """
  update_rangers_type_many(
    """updates to execute, in order"""
    updates: [rangers_type_updates!]!
  ): [rangers_type_mutation_response]

  """
  update data of the table: "rangers.type_text"
  """
  update_rangers_type_text(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_type_text_set_input

    """filter the rows which have to be updated"""
    where: rangers_type_text_bool_exp!
  ): rangers_type_text_mutation_response

  """
  update single row of the table: "rangers.type_text"
  """
  update_rangers_type_text_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_type_text_set_input
    pk_columns: rangers_type_text_pk_columns_input!
  ): rangers_type_text

  """
  update multiples rows of table: "rangers.type_text"
  """
  update_rangers_type_text_many(
    """updates to execute, in order"""
    updates: [rangers_type_text_updates!]!
  ): [rangers_type_text_mutation_response]

  """
  update data of the table: "rangers.user_friends"
  """
  update_rangers_user_friends(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_friends_set_input

    """filter the rows which have to be updated"""
    where: rangers_user_friends_bool_exp!
  ): rangers_user_friends_mutation_response

  """
  update multiples rows of table: "rangers.user_friends"
  """
  update_rangers_user_friends_many(
    """updates to execute, in order"""
    updates: [rangers_user_friends_updates!]!
  ): [rangers_user_friends_mutation_response]

  """
  update data of the table: "rangers.user_received_friend_requests"
  """
  update_rangers_user_received_friend_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_received_friend_requests_set_input

    """filter the rows which have to be updated"""
    where: rangers_user_received_friend_requests_bool_exp!
  ): rangers_user_received_friend_requests_mutation_response

  """
  update multiples rows of table: "rangers.user_received_friend_requests"
  """
  update_rangers_user_received_friend_requests_many(
    """updates to execute, in order"""
    updates: [rangers_user_received_friend_requests_updates!]!
  ): [rangers_user_received_friend_requests_mutation_response]

  """
  update data of the table: "rangers.user_role"
  """
  update_rangers_user_role(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_role_set_input

    """filter the rows which have to be updated"""
    where: rangers_user_role_bool_exp!
  ): rangers_user_role_mutation_response

  """
  update single row of the table: "rangers.user_role"
  """
  update_rangers_user_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_role_set_input
    pk_columns: rangers_user_role_pk_columns_input!
  ): rangers_user_role

  """
  update multiples rows of table: "rangers.user_role"
  """
  update_rangers_user_role_many(
    """updates to execute, in order"""
    updates: [rangers_user_role_updates!]!
  ): [rangers_user_role_mutation_response]

  """
  update data of the table: "rangers.user_sent_friend_requests"
  """
  update_rangers_user_sent_friend_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_sent_friend_requests_set_input

    """filter the rows which have to be updated"""
    where: rangers_user_sent_friend_requests_bool_exp!
  ): rangers_user_sent_friend_requests_mutation_response

  """
  update multiples rows of table: "rangers.user_sent_friend_requests"
  """
  update_rangers_user_sent_friend_requests_many(
    """updates to execute, in order"""
    updates: [rangers_user_sent_friend_requests_updates!]!
  ): [rangers_user_sent_friend_requests_mutation_response]

  """
  update data of the table: "rangers.user_settings"
  """
  update_rangers_user_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_settings_set_input

    """filter the rows which have to be updated"""
    where: rangers_user_settings_bool_exp!
  ): rangers_user_settings_mutation_response

  """
  update single row of the table: "rangers.user_settings"
  """
  update_rangers_user_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rangers_user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: rangers_user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: rangers_user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: rangers_user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rangers_user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: rangers_user_settings_set_input
    pk_columns: rangers_user_settings_pk_columns_input!
  ): rangers_user_settings

  """
  update multiples rows of table: "rangers.user_settings"
  """
  update_rangers_user_settings_many(
    """updates to execute, in order"""
    updates: [rangers_user_settings_updates!]!
  ): [rangers_user_settings_mutation_response]

  """
  update data of the table: "rangers.users"
  """
  update_rangers_users(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_users_set_input

    """filter the rows which have to be updated"""
    where: rangers_users_bool_exp!
  ): rangers_users_mutation_response

  """
  update single row of the table: "rangers.users"
  """
  update_rangers_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: rangers_users_set_input
    pk_columns: rangers_users_pk_columns_input!
  ): rangers_users

  """
  update multiples rows of table: "rangers.users"
  """
  update_rangers_users_many(
    """updates to execute, in order"""
    updates: [rangers_users_updates!]!
  ): [rangers_users_mutation_response]

  """
  update data of the table: "taboo_set"
  """
  update_taboo_set(
    """increments the numeric columns with given value of the filtered values"""
    _inc: taboo_set_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: taboo_set_set_input

    """filter the rows which have to be updated"""
    where: taboo_set_bool_exp!
  ): taboo_set_mutation_response

  """
  update single row of the table: "taboo_set"
  """
  update_taboo_set_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: taboo_set_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: taboo_set_set_input
    pk_columns: taboo_set_pk_columns_input!
  ): taboo_set

  """
  update multiples rows of table: "taboo_set"
  """
  update_taboo_set_many(
    """updates to execute, in order"""
    updates: [taboo_set_updates!]!
  ): [taboo_set_mutation_response]

  """
  update data of the table: "user_campaigns"
  """
  update_user_campaigns(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_campaigns_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_campaigns_set_input

    """filter the rows which have to be updated"""
    where: user_campaigns_bool_exp!
  ): user_campaigns_mutation_response

  """
  update multiples rows of table: "user_campaigns"
  """
  update_user_campaigns_many(
    """updates to execute, in order"""
    updates: [user_campaigns_updates!]!
  ): [user_campaigns_mutation_response]

  """
  update data of the table: "user_flag"
  """
  update_user_flag(
    """sets the columns of the filtered rows to the given values"""
    _set: user_flag_set_input

    """filter the rows which have to be updated"""
    where: user_flag_bool_exp!
  ): user_flag_mutation_response

  """
  update single row of the table: "user_flag"
  """
  update_user_flag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_flag_set_input
    pk_columns: user_flag_pk_columns_input!
  ): user_flag

  """
  update multiples rows of table: "user_flag"
  """
  update_user_flag_many(
    """updates to execute, in order"""
    updates: [user_flag_updates!]!
  ): [user_flag_mutation_response]

  """
  update data of the table: "user_flag_type"
  """
  update_user_flag_type(
    """sets the columns of the filtered rows to the given values"""
    _set: user_flag_type_set_input

    """filter the rows which have to be updated"""
    where: user_flag_type_bool_exp!
  ): user_flag_type_mutation_response

  """
  update single row of the table: "user_flag_type"
  """
  update_user_flag_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_flag_type_set_input
    pk_columns: user_flag_type_pk_columns_input!
  ): user_flag_type

  """
  update multiples rows of table: "user_flag_type"
  """
  update_user_flag_type_many(
    """updates to execute, in order"""
    updates: [user_flag_type_updates!]!
  ): [user_flag_type_mutation_response]

  """
  update data of the table: "user_friends"
  """
  update_user_friends(
    """sets the columns of the filtered rows to the given values"""
    _set: user_friends_set_input

    """filter the rows which have to be updated"""
    where: user_friends_bool_exp!
  ): user_friends_mutation_response

  """
  update multiples rows of table: "user_friends"
  """
  update_user_friends_many(
    """updates to execute, in order"""
    updates: [user_friends_updates!]!
  ): [user_friends_mutation_response]

  """
  update data of the table: "user_received_friend_requests"
  """
  update_user_received_friend_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: user_received_friend_requests_set_input

    """filter the rows which have to be updated"""
    where: user_received_friend_requests_bool_exp!
  ): user_received_friend_requests_mutation_response

  """
  update multiples rows of table: "user_received_friend_requests"
  """
  update_user_received_friend_requests_many(
    """updates to execute, in order"""
    updates: [user_received_friend_requests_updates!]!
  ): [user_received_friend_requests_mutation_response]

  """
  update data of the table: "user_sent_friend_requests"
  """
  update_user_sent_friend_requests(
    """sets the columns of the filtered rows to the given values"""
    _set: user_sent_friend_requests_set_input

    """filter the rows which have to be updated"""
    where: user_sent_friend_requests_bool_exp!
  ): user_sent_friend_requests_mutation_response

  """
  update multiples rows of table: "user_sent_friend_requests"
  """
  update_user_sent_friend_requests_many(
    """updates to execute, in order"""
    updates: [user_sent_friend_requests_updates!]!
  ): [user_sent_friend_requests_mutation_response]

  """
  update data of the table: "user_settings"
  """
  update_user_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input

    """filter the rows which have to be updated"""
    where: user_settings_bool_exp!
  ): user_settings_mutation_response

  """
  update single row of the table: "user_settings"
  """
  update_user_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_settings_set_input
    pk_columns: user_settings_pk_columns_input!
  ): user_settings

  """
  update multiples rows of table: "user_settings"
  """
  update_user_settings_many(
    """updates to execute, in order"""
    updates: [user_settings_updates!]!
  ): [user_settings_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]
  upgradeArkhamDbDeck(args: UpgradeDeckInput!): UpgradeDeckOutput
  uploadLocalCampaignDeck(args: UploadLocalCampaignDeckInput!): UploadLocalCampaignDeckOutput
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "pack"
"""
type pack {
  """An array relationship"""
  cards(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """An aggregate relationship"""
  cards_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): all_card_aggregate!
  code: String!

  """An object relationship"""
  cycle: cycle!
  cycle_code: String!
  official: Boolean!
  position: Int!
  real_name: String!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): [pack_name!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): pack_name_aggregate!
}

"""
aggregated selection of "pack"
"""
type pack_aggregate {
  aggregate: pack_aggregate_fields
  nodes: [pack!]!
}

input pack_aggregate_bool_exp {
  bool_and: pack_aggregate_bool_exp_bool_and
  bool_or: pack_aggregate_bool_exp_bool_or
  count: pack_aggregate_bool_exp_count
}

input pack_aggregate_bool_exp_bool_and {
  arguments: pack_select_column_pack_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: pack_bool_exp
  predicate: Boolean_comparison_exp!
}

input pack_aggregate_bool_exp_bool_or {
  arguments: pack_select_column_pack_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: pack_bool_exp
  predicate: Boolean_comparison_exp!
}

input pack_aggregate_bool_exp_count {
  arguments: [pack_select_column!]
  distinct: Boolean
  filter: pack_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "pack"
"""
type pack_aggregate_fields {
  avg: pack_avg_fields
  count(columns: [pack_select_column!], distinct: Boolean): Int!
  max: pack_max_fields
  min: pack_min_fields
  stddev: pack_stddev_fields
  stddev_pop: pack_stddev_pop_fields
  stddev_samp: pack_stddev_samp_fields
  sum: pack_sum_fields
  var_pop: pack_var_pop_fields
  var_samp: pack_var_samp_fields
  variance: pack_variance_fields
}

"""
order by aggregate values of table "pack"
"""
input pack_aggregate_order_by {
  avg: pack_avg_order_by
  count: order_by
  max: pack_max_order_by
  min: pack_min_order_by
  stddev: pack_stddev_order_by
  stddev_pop: pack_stddev_pop_order_by
  stddev_samp: pack_stddev_samp_order_by
  sum: pack_sum_order_by
  var_pop: pack_var_pop_order_by
  var_samp: pack_var_samp_order_by
  variance: pack_variance_order_by
}

"""
input type for inserting array relation for remote table "pack"
"""
input pack_arr_rel_insert_input {
  data: [pack_insert_input!]!

  """upsert condition"""
  on_conflict: pack_on_conflict
}

"""aggregate avg on columns"""
type pack_avg_fields {
  position: Float
}

"""
order by avg() on columns of table "pack"
"""
input pack_avg_order_by {
  position: order_by
}

"""
Boolean expression to filter rows from the table "pack". All fields are combined with a logical 'AND'.
"""
input pack_bool_exp {
  _and: [pack_bool_exp!]
  _not: pack_bool_exp
  _or: [pack_bool_exp!]
  cards: all_card_bool_exp
  cards_aggregate: all_card_aggregate_bool_exp
  code: String_comparison_exp
  cycle: cycle_bool_exp
  cycle_code: String_comparison_exp
  official: Boolean_comparison_exp
  position: Int_comparison_exp
  real_name: String_comparison_exp
  translations: pack_name_bool_exp
  translations_aggregate: pack_name_aggregate_bool_exp
}

"""
unique or primary key constraints on table "pack"
"""
enum pack_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  pack_pkey
}

"""
input type for incrementing numeric columns in table "pack"
"""
input pack_inc_input {
  position: Int
}

"""
input type for inserting data into table "pack"
"""
input pack_insert_input {
  cards: all_card_arr_rel_insert_input
  code: String
  cycle: cycle_obj_rel_insert_input
  cycle_code: String
  official: Boolean
  position: Int
  real_name: String
  translations: pack_name_arr_rel_insert_input
}

"""aggregate max on columns"""
type pack_max_fields {
  code: String
  cycle_code: String
  position: Int
  real_name: String
}

"""
order by max() on columns of table "pack"
"""
input pack_max_order_by {
  code: order_by
  cycle_code: order_by
  position: order_by
  real_name: order_by
}

"""aggregate min on columns"""
type pack_min_fields {
  code: String
  cycle_code: String
  position: Int
  real_name: String
}

"""
order by min() on columns of table "pack"
"""
input pack_min_order_by {
  code: order_by
  cycle_code: order_by
  position: order_by
  real_name: order_by
}

"""
response of any mutation on the table "pack"
"""
type pack_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pack!]!
}

"""
columns and relationships of "pack_name"
"""
type pack_name {
  code: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "pack_name"
"""
type pack_name_aggregate {
  aggregate: pack_name_aggregate_fields
  nodes: [pack_name!]!
}

input pack_name_aggregate_bool_exp {
  count: pack_name_aggregate_bool_exp_count
}

input pack_name_aggregate_bool_exp_count {
  arguments: [pack_name_select_column!]
  distinct: Boolean
  filter: pack_name_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "pack_name"
"""
type pack_name_aggregate_fields {
  count(columns: [pack_name_select_column!], distinct: Boolean): Int!
  max: pack_name_max_fields
  min: pack_name_min_fields
}

"""
order by aggregate values of table "pack_name"
"""
input pack_name_aggregate_order_by {
  count: order_by
  max: pack_name_max_order_by
  min: pack_name_min_order_by
}

"""
input type for inserting array relation for remote table "pack_name"
"""
input pack_name_arr_rel_insert_input {
  data: [pack_name_insert_input!]!

  """upsert condition"""
  on_conflict: pack_name_on_conflict
}

"""
Boolean expression to filter rows from the table "pack_name". All fields are combined with a logical 'AND'.
"""
input pack_name_bool_exp {
  _and: [pack_name_bool_exp!]
  _not: pack_name_bool_exp
  _or: [pack_name_bool_exp!]
  code: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "pack_name"
"""
enum pack_name_constraint {
  """
  unique or primary key constraint on columns "locale", "code"
  """
  pack_name_pkey
}

"""
input type for inserting data into table "pack_name"
"""
input pack_name_insert_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type pack_name_max_fields {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "pack_name"
"""
input pack_name_max_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type pack_name_min_fields {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "pack_name"
"""
input pack_name_min_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "pack_name"
"""
type pack_name_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pack_name!]!
}

"""
on_conflict condition type for table "pack_name"
"""
input pack_name_on_conflict {
  constraint: pack_name_constraint!
  update_columns: [pack_name_update_column!]! = []
  where: pack_name_bool_exp
}

"""Ordering options when selecting data from "pack_name"."""
input pack_name_order_by {
  code: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: pack_name"""
input pack_name_pk_columns_input {
  code: String!
  locale: String!
}

"""
select columns of table "pack_name"
"""
enum pack_name_select_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "pack_name"
"""
input pack_name_set_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "pack_name"
"""
input pack_name_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pack_name_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pack_name_stream_cursor_value_input {
  code: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "pack_name"
"""
enum pack_name_update_column {
  """column name"""
  code

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input pack_name_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: pack_name_set_input

  """filter the rows which have to be updated"""
  where: pack_name_bool_exp!
}

"""
input type for inserting object relation for remote table "pack"
"""
input pack_obj_rel_insert_input {
  data: pack_insert_input!

  """upsert condition"""
  on_conflict: pack_on_conflict
}

"""
on_conflict condition type for table "pack"
"""
input pack_on_conflict {
  constraint: pack_constraint!
  update_columns: [pack_update_column!]! = []
  where: pack_bool_exp
}

"""Ordering options when selecting data from "pack"."""
input pack_order_by {
  cards_aggregate: all_card_aggregate_order_by
  code: order_by
  cycle: cycle_order_by
  cycle_code: order_by
  official: order_by
  position: order_by
  real_name: order_by
  translations_aggregate: pack_name_aggregate_order_by
}

"""primary key columns input for table: pack"""
input pack_pk_columns_input {
  code: String!
}

"""
select columns of table "pack"
"""
enum pack_select_column {
  """column name"""
  code

  """column name"""
  cycle_code

  """column name"""
  official

  """column name"""
  position

  """column name"""
  real_name
}

"""
select "pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "pack"
"""
enum pack_select_column_pack_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  official
}

"""
select "pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "pack"
"""
enum pack_select_column_pack_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  official
}

"""
input type for updating data in table "pack"
"""
input pack_set_input {
  code: String
  cycle_code: String
  official: Boolean
  position: Int
  real_name: String
}

"""aggregate stddev on columns"""
type pack_stddev_fields {
  position: Float
}

"""
order by stddev() on columns of table "pack"
"""
input pack_stddev_order_by {
  position: order_by
}

"""aggregate stddev_pop on columns"""
type pack_stddev_pop_fields {
  position: Float
}

"""
order by stddev_pop() on columns of table "pack"
"""
input pack_stddev_pop_order_by {
  position: order_by
}

"""aggregate stddev_samp on columns"""
type pack_stddev_samp_fields {
  position: Float
}

"""
order by stddev_samp() on columns of table "pack"
"""
input pack_stddev_samp_order_by {
  position: order_by
}

"""
Streaming cursor of the table "pack"
"""
input pack_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pack_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pack_stream_cursor_value_input {
  code: String
  cycle_code: String
  official: Boolean
  position: Int
  real_name: String
}

"""aggregate sum on columns"""
type pack_sum_fields {
  position: Int
}

"""
order by sum() on columns of table "pack"
"""
input pack_sum_order_by {
  position: order_by
}

"""
update columns of table "pack"
"""
enum pack_update_column {
  """column name"""
  code

  """column name"""
  cycle_code

  """column name"""
  official

  """column name"""
  position

  """column name"""
  real_name
}

input pack_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: pack_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: pack_set_input

  """filter the rows which have to be updated"""
  where: pack_bool_exp!
}

"""aggregate var_pop on columns"""
type pack_var_pop_fields {
  position: Float
}

"""
order by var_pop() on columns of table "pack"
"""
input pack_var_pop_order_by {
  position: order_by
}

"""aggregate var_samp on columns"""
type pack_var_samp_fields {
  position: Float
}

"""
order by var_samp() on columns of table "pack"
"""
input pack_var_samp_order_by {
  position: order_by
}

"""aggregate variance on columns"""
type pack_variance_fields {
  position: Float
}

"""
order by variance() on columns of table "pack"
"""
input pack_variance_order_by {
  position: order_by
}

type query_root {
  """
  fetch data from the table: "all_card"
  """
  all_card(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """
  fetch aggregated fields from the table: "all_card"
  """
  all_card_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): all_card_aggregate!

  """fetch data from the table: "all_card" using primary key columns"""
  all_card_by_pk(id: String!): all_card

  """
  fetch data from the table: "all_card_text"
  """
  all_card_text(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): [all_card_text!]!

  """
  fetch aggregated fields from the table: "all_card_text"
  """
  all_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): all_card_text_aggregate!

  """fetch data from the table: "all_card_text" using primary key columns"""
  all_card_text_by_pk(id: String!, locale: String!): all_card_text

  """
  fetch data from the table: "all_card_updated"
  """
  all_card_updated(
    """distinct select on columns"""
    distinct_on: [all_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_order_by!]

    """filter the rows returned"""
    where: all_card_updated_bool_exp
  ): [all_card_updated!]!

  """
  fetch aggregated fields from the table: "all_card_updated"
  """
  all_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_order_by!]

    """filter the rows returned"""
    where: all_card_updated_bool_exp
  ): all_card_updated_aggregate!

  """
  fetch data from the table: "all_card_updated" using primary key columns
  """
  all_card_updated_by_pk(locale: String!): all_card_updated

  """
  fetch data from the table: "all_card_updated_by_version"
  """
  all_card_updated_by_version(
    """distinct select on columns"""
    distinct_on: [all_card_updated_by_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_by_version_order_by!]

    """filter the rows returned"""
    where: all_card_updated_by_version_bool_exp
  ): [all_card_updated_by_version!]!

  """
  fetch aggregated fields from the table: "all_card_updated_by_version"
  """
  all_card_updated_by_version_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_updated_by_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_by_version_order_by!]

    """filter the rows returned"""
    where: all_card_updated_by_version_bool_exp
  ): all_card_updated_by_version_aggregate!

  """
  fetch data from the table: "all_card_updated_by_version" using primary key columns
  """
  all_card_updated_by_version_by_pk(locale: String!, version: Int!): all_card_updated_by_version

  """
  fetch data from the table: "arkhamdb_auth"
  """
  arkhamdb_auth(
    """distinct select on columns"""
    distinct_on: [arkhamdb_auth_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_auth_order_by!]

    """filter the rows returned"""
    where: arkhamdb_auth_bool_exp
  ): [arkhamdb_auth!]!

  """
  fetch aggregated fields from the table: "arkhamdb_auth"
  """
  arkhamdb_auth_aggregate(
    """distinct select on columns"""
    distinct_on: [arkhamdb_auth_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_auth_order_by!]

    """filter the rows returned"""
    where: arkhamdb_auth_bool_exp
  ): arkhamdb_auth_aggregate!

  """fetch data from the table: "arkhamdb_auth" using primary key columns"""
  arkhamdb_auth_by_pk(user_id: String!): arkhamdb_auth

  """
  fetch data from the table: "arkhamdb_deck"
  """
  arkhamdb_deck(
    """distinct select on columns"""
    distinct_on: [arkhamdb_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_deck_order_by!]

    """filter the rows returned"""
    where: arkhamdb_deck_bool_exp
  ): [arkhamdb_deck!]!

  """
  fetch aggregated fields from the table: "arkhamdb_deck"
  """
  arkhamdb_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [arkhamdb_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_deck_order_by!]

    """filter the rows returned"""
    where: arkhamdb_deck_bool_exp
  ): arkhamdb_deck_aggregate!

  """fetch data from the table: "arkhamdb_deck" using primary key columns"""
  arkhamdb_deck_by_pk(id: Int!): arkhamdb_deck

  """An array relationship"""
  base_decks(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): [base_decks!]!

  """An aggregate relationship"""
  base_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): base_decks_aggregate!

  """
  fetch data from the table: "campaign"
  """
  campaign(
    """distinct select on columns"""
    distinct_on: [campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_order_by!]

    """filter the rows returned"""
    where: campaign_bool_exp
  ): [campaign!]!

  """
  fetch data from the table: "campaign_access"
  """
  campaign_access(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): [campaign_access!]!

  """
  fetch aggregated fields from the table: "campaign_access"
  """
  campaign_access_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): campaign_access_aggregate!

  """fetch data from the table: "campaign_access" using primary key columns"""
  campaign_access_by_pk(id: Int!): campaign_access

  """
  fetch aggregated fields from the table: "campaign"
  """
  campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_order_by!]

    """filter the rows returned"""
    where: campaign_bool_exp
  ): campaign_aggregate!

  """fetch data from the table: "campaign" using primary key columns"""
  campaign_by_pk(id: Int!): campaign

  """
  fetch data from the table: "campaign_deck"
  """
  campaign_deck(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """
  fetch aggregated fields from the table: "campaign_deck"
  """
  campaign_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): campaign_deck_aggregate!

  """fetch data from the table: "campaign_deck" using primary key columns"""
  campaign_deck_by_pk(id: Int!): campaign_deck

  """
  fetch data from the table: "campaign_difficulty"
  """
  campaign_difficulty(
    """distinct select on columns"""
    distinct_on: [campaign_difficulty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_difficulty_order_by!]

    """filter the rows returned"""
    where: campaign_difficulty_bool_exp
  ): [campaign_difficulty!]!

  """
  fetch aggregated fields from the table: "campaign_difficulty"
  """
  campaign_difficulty_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_difficulty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_difficulty_order_by!]

    """filter the rows returned"""
    where: campaign_difficulty_bool_exp
  ): campaign_difficulty_aggregate!

  """
  fetch data from the table: "campaign_difficulty" using primary key columns
  """
  campaign_difficulty_by_pk(value: String!): campaign_difficulty

  """
  fetch data from the table: "campaign_guide"
  """
  campaign_guide(
    """distinct select on columns"""
    distinct_on: [campaign_guide_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_guide_order_by!]

    """filter the rows returned"""
    where: campaign_guide_bool_exp
  ): [campaign_guide!]!

  """
  fetch aggregated fields from the table: "campaign_guide"
  """
  campaign_guide_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_guide_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_guide_order_by!]

    """filter the rows returned"""
    where: campaign_guide_bool_exp
  ): campaign_guide_aggregate!

  """
  fetch data from the table: "campaign_investigator"
  """
  campaign_investigator(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): [campaign_investigator!]!

  """
  fetch aggregated fields from the table: "campaign_investigator"
  """
  campaign_investigator_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): campaign_investigator_aggregate!

  """
  fetch data from the table: "campaign_investigator" using primary key columns
  """
  campaign_investigator_by_pk(campaign_id: Int!, investigator: String!): campaign_investigator

  """
  fetch data from the table: "campaigns_by_cycle"
  """
  campaigns_by_cycle(
    """distinct select on columns"""
    distinct_on: [campaigns_by_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaigns_by_cycle_order_by!]

    """filter the rows returned"""
    where: campaigns_by_cycle_bool_exp
  ): [campaigns_by_cycle!]!

  """
  fetch aggregated fields from the table: "campaigns_by_cycle"
  """
  campaigns_by_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [campaigns_by_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaigns_by_cycle_order_by!]

    """filter the rows returned"""
    where: campaigns_by_cycle_bool_exp
  ): campaigns_by_cycle_aggregate!

  """
  fetch data from the table: "card"
  """
  card(
    """distinct select on columns"""
    distinct_on: [card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_order_by!]

    """filter the rows returned"""
    where: card_bool_exp
  ): [card!]!

  """
  fetch aggregated fields from the table: "card"
  """
  card_aggregate(
    """distinct select on columns"""
    distinct_on: [card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_order_by!]

    """filter the rows returned"""
    where: card_bool_exp
  ): card_aggregate!

  """fetch data from the table: "card" using primary key columns"""
  card_by_pk(code: String!): card

  """
  fetch data from the table: "card_cycle"
  """
  card_cycle(
    """distinct select on columns"""
    distinct_on: [card_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_cycle_order_by!]

    """filter the rows returned"""
    where: card_cycle_bool_exp
  ): [card_cycle!]!

  """
  fetch aggregated fields from the table: "card_cycle"
  """
  card_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [card_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_cycle_order_by!]

    """filter the rows returned"""
    where: card_cycle_bool_exp
  ): card_cycle_aggregate!

  """fetch data from the table: "card_cycle" using primary key columns"""
  card_cycle_by_pk(code: String!, locale: String!): card_cycle

  """
  fetch data from the table: "card_encounter_set"
  """
  card_encounter_set(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): [card_encounter_set!]!

  """
  fetch aggregated fields from the table: "card_encounter_set"
  """
  card_encounter_set_aggregate(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): card_encounter_set_aggregate!

  """
  fetch data from the table: "card_encounter_set" using primary key columns
  """
  card_encounter_set_by_pk(code: String!, locale: String!): card_encounter_set

  """
  fetch data from the table: "card_pack"
  """
  card_pack(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """
  fetch aggregated fields from the table: "card_pack"
  """
  card_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!

  """fetch data from the table: "card_pack" using primary key columns"""
  card_pack_by_pk(code: String!, locale: String!): card_pack

  """
  fetch data from the table: "card_subtype_name"
  """
  card_subtype_name(
    """distinct select on columns"""
    distinct_on: [card_subtype_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_subtype_name_order_by!]

    """filter the rows returned"""
    where: card_subtype_name_bool_exp
  ): [card_subtype_name!]!

  """
  fetch aggregated fields from the table: "card_subtype_name"
  """
  card_subtype_name_aggregate(
    """distinct select on columns"""
    distinct_on: [card_subtype_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_subtype_name_order_by!]

    """filter the rows returned"""
    where: card_subtype_name_bool_exp
  ): card_subtype_name_aggregate!

  """
  fetch data from the table: "card_subtype_name" using primary key columns
  """
  card_subtype_name_by_pk(code: String!, locale: String!): card_subtype_name

  """
  fetch data from the table: "card_text"
  """
  card_text(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): [card_text!]!

  """
  fetch aggregated fields from the table: "card_text"
  """
  card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): card_text_aggregate!

  """fetch data from the table: "card_text" using primary key columns"""
  card_text_by_pk(code: String!, locale: String!): card_text

  """
  fetch data from the table: "card_type_code"
  """
  card_type_code(
    """distinct select on columns"""
    distinct_on: [card_type_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_code_order_by!]

    """filter the rows returned"""
    where: card_type_code_bool_exp
  ): [card_type_code!]!

  """
  fetch aggregated fields from the table: "card_type_code"
  """
  card_type_code_aggregate(
    """distinct select on columns"""
    distinct_on: [card_type_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_code_order_by!]

    """filter the rows returned"""
    where: card_type_code_bool_exp
  ): card_type_code_aggregate!

  """fetch data from the table: "card_type_code" using primary key columns"""
  card_type_code_by_pk(code: String!): card_type_code

  """
  fetch data from the table: "card_type_name"
  """
  card_type_name(
    """distinct select on columns"""
    distinct_on: [card_type_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_name_order_by!]

    """filter the rows returned"""
    where: card_type_name_bool_exp
  ): [card_type_name!]!

  """
  fetch aggregated fields from the table: "card_type_name"
  """
  card_type_name_aggregate(
    """distinct select on columns"""
    distinct_on: [card_type_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_name_order_by!]

    """filter the rows returned"""
    where: card_type_name_bool_exp
  ): card_type_name_aggregate!

  """fetch data from the table: "card_type_name" using primary key columns"""
  card_type_name_by_pk(code: card_type_code_enum!, locale: String!): card_type_name

  """An array relationship"""
  chaos_bag_result(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): [chaos_bag_result!]!

  """An aggregate relationship"""
  chaos_bag_result_aggregate(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): chaos_bag_result_aggregate!

  """
  fetch data from the table: "chaos_bag_result" using primary key columns
  """
  chaos_bag_result_by_pk(id: Int!): chaos_bag_result

  """
  fetch data from the table: "chaos_bag_tarot_mode"
  """
  chaos_bag_tarot_mode(
    """distinct select on columns"""
    distinct_on: [chaos_bag_tarot_mode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_tarot_mode_order_by!]

    """filter the rows returned"""
    where: chaos_bag_tarot_mode_bool_exp
  ): [chaos_bag_tarot_mode!]!

  """
  fetch aggregated fields from the table: "chaos_bag_tarot_mode"
  """
  chaos_bag_tarot_mode_aggregate(
    """distinct select on columns"""
    distinct_on: [chaos_bag_tarot_mode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_tarot_mode_order_by!]

    """filter the rows returned"""
    where: chaos_bag_tarot_mode_bool_exp
  ): chaos_bag_tarot_mode_aggregate!

  """
  fetch data from the table: "chaos_bag_tarot_mode" using primary key columns
  """
  chaos_bag_tarot_mode_by_pk(value: String!): chaos_bag_tarot_mode

  """
  fetch data from the table: "conquest.card"
  """
  conquest_card(
    """distinct select on columns"""
    distinct_on: [conquest_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_order_by!]

    """filter the rows returned"""
    where: conquest_card_bool_exp
  ): [conquest_card!]!

  """
  fetch aggregated fields from the table: "conquest.card"
  """
  conquest_card_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_order_by!]

    """filter the rows returned"""
    where: conquest_card_bool_exp
  ): conquest_card_aggregate!

  """fetch data from the table: "conquest.card" using primary key columns"""
  conquest_card_by_pk(id: String!): conquest_card

  """
  fetch data from the table: "conquest.card_localized"
  """
  conquest_card_localized(
    """distinct select on columns"""
    distinct_on: [conquest_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_localized_order_by!]

    """filter the rows returned"""
    where: conquest_card_localized_bool_exp
  ): [conquest_card_localized!]!

  """
  fetch aggregated fields from the table: "conquest.card_localized"
  """
  conquest_card_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_localized_order_by!]

    """filter the rows returned"""
    where: conquest_card_localized_bool_exp
  ): conquest_card_localized_aggregate!

  """
  fetch data from the table: "conquest.card_text"
  """
  conquest_card_text(
    """distinct select on columns"""
    distinct_on: [conquest_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_text_order_by!]

    """filter the rows returned"""
    where: conquest_card_text_bool_exp
  ): [conquest_card_text!]!

  """
  fetch aggregated fields from the table: "conquest.card_text"
  """
  conquest_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_text_order_by!]

    """filter the rows returned"""
    where: conquest_card_text_bool_exp
  ): conquest_card_text_aggregate!

  """
  fetch data from the table: "conquest.card_text" using primary key columns
  """
  conquest_card_text_by_pk(id: String!, locale: String!): conquest_card_text

  """
  fetch data from the table: "conquest.card_updated"
  """
  conquest_card_updated(
    """distinct select on columns"""
    distinct_on: [conquest_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_updated_order_by!]

    """filter the rows returned"""
    where: conquest_card_updated_bool_exp
  ): [conquest_card_updated!]!

  """
  fetch aggregated fields from the table: "conquest.card_updated"
  """
  conquest_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_updated_order_by!]

    """filter the rows returned"""
    where: conquest_card_updated_bool_exp
  ): conquest_card_updated_aggregate!

  """
  fetch data from the table: "conquest.comment"
  """
  conquest_comment(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): [conquest_comment!]!

  """
  fetch aggregated fields from the table: "conquest.comment"
  """
  conquest_comment_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): conquest_comment_aggregate!

  """
  fetch data from the table: "conquest.comment" using primary key columns
  """
  conquest_comment_by_pk(id: uuid!): conquest_comment

  """
  fetch data from the table: "conquest.cycle"
  """
  conquest_cycle(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_bool_exp
  ): [conquest_cycle!]!

  """
  fetch aggregated fields from the table: "conquest.cycle"
  """
  conquest_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_bool_exp
  ): conquest_cycle_aggregate!

  """fetch data from the table: "conquest.cycle" using primary key columns"""
  conquest_cycle_by_pk(id: String!): conquest_cycle

  """
  fetch data from the table: "conquest.cycle_text"
  """
  conquest_cycle_text(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_text_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_text_bool_exp
  ): [conquest_cycle_text!]!

  """
  fetch aggregated fields from the table: "conquest.cycle_text"
  """
  conquest_cycle_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_text_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_text_bool_exp
  ): conquest_cycle_text_aggregate!

  """
  fetch data from the table: "conquest.cycle_text" using primary key columns
  """
  conquest_cycle_text_by_pk(id: String!, locale: String!): conquest_cycle_text

  """
  fetch data from the table: "conquest.deck"
  """
  conquest_deck(
    """distinct select on columns"""
    distinct_on: [conquest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_order_by!]

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): [conquest_deck!]!

  """
  fetch aggregated fields from the table: "conquest.deck"
  """
  conquest_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_order_by!]

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): conquest_deck_aggregate!

  """fetch data from the table: "conquest.deck" using primary key columns"""
  conquest_deck_by_pk(id: Int!): conquest_deck

  """
  fetch data from the table: "conquest.deck_copy"
  """
  conquest_deck_copy(
    """distinct select on columns"""
    distinct_on: [conquest_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_copy_order_by!]

    """filter the rows returned"""
    where: conquest_deck_copy_bool_exp
  ): [conquest_deck_copy!]!

  """
  fetch aggregated fields from the table: "conquest.deck_copy"
  """
  conquest_deck_copy_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_copy_order_by!]

    """filter the rows returned"""
    where: conquest_deck_copy_bool_exp
  ): conquest_deck_copy_aggregate!

  """
  fetch data from the table: "conquest.deck_copy" using primary key columns
  """
  conquest_deck_copy_by_pk(copy_deck_id: Int!): conquest_deck_copy

  """
  fetch data from the table: "conquest.deck_like"
  """
  conquest_deck_like(
    """distinct select on columns"""
    distinct_on: [conquest_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_like_order_by!]

    """filter the rows returned"""
    where: conquest_deck_like_bool_exp
  ): [conquest_deck_like!]!

  """
  fetch aggregated fields from the table: "conquest.deck_like"
  """
  conquest_deck_like_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_like_order_by!]

    """filter the rows returned"""
    where: conquest_deck_like_bool_exp
  ): conquest_deck_like_aggregate!

  """
  fetch data from the table: "conquest.deck_like" using primary key columns
  """
  conquest_deck_like_by_pk(deck_id: Int!, user_id: String!): conquest_deck_like

  """
  fetch data from the table: "conquest.faction"
  """
  conquest_faction(
    """distinct select on columns"""
    distinct_on: [conquest_faction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_order_by!]

    """filter the rows returned"""
    where: conquest_faction_bool_exp
  ): [conquest_faction!]!

  """
  fetch aggregated fields from the table: "conquest.faction"
  """
  conquest_faction_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_faction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_order_by!]

    """filter the rows returned"""
    where: conquest_faction_bool_exp
  ): conquest_faction_aggregate!

  """
  fetch data from the table: "conquest.faction" using primary key columns
  """
  conquest_faction_by_pk(id: String!): conquest_faction

  """
  fetch data from the table: "conquest.faction_text"
  """
  conquest_faction_text(
    """distinct select on columns"""
    distinct_on: [conquest_faction_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_text_order_by!]

    """filter the rows returned"""
    where: conquest_faction_text_bool_exp
  ): [conquest_faction_text!]!

  """
  fetch aggregated fields from the table: "conquest.faction_text"
  """
  conquest_faction_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_faction_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_text_order_by!]

    """filter the rows returned"""
    where: conquest_faction_text_bool_exp
  ): conquest_faction_text_aggregate!

  """
  fetch data from the table: "conquest.faction_text" using primary key columns
  """
  conquest_faction_text_by_pk(id: String!, locale: String!): conquest_faction_text

  """
  fetch data from the table: "conquest.loyalty"
  """
  conquest_loyalty(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_bool_exp
  ): [conquest_loyalty!]!

  """
  fetch aggregated fields from the table: "conquest.loyalty"
  """
  conquest_loyalty_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_bool_exp
  ): conquest_loyalty_aggregate!

  """
  fetch data from the table: "conquest.loyalty" using primary key columns
  """
  conquest_loyalty_by_pk(id: String!): conquest_loyalty

  """
  fetch data from the table: "conquest.loyalty_text"
  """
  conquest_loyalty_text(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_text_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_text_bool_exp
  ): [conquest_loyalty_text!]!

  """
  fetch aggregated fields from the table: "conquest.loyalty_text"
  """
  conquest_loyalty_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_text_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_text_bool_exp
  ): conquest_loyalty_text_aggregate!

  """
  fetch data from the table: "conquest.loyalty_text" using primary key columns
  """
  conquest_loyalty_text_by_pk(id: String!, locale: String!): conquest_loyalty_text

  """
  fetch data from the table: "conquest.pack"
  """
  conquest_pack(
    """distinct select on columns"""
    distinct_on: [conquest_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_order_by!]

    """filter the rows returned"""
    where: conquest_pack_bool_exp
  ): [conquest_pack!]!

  """
  fetch aggregated fields from the table: "conquest.pack"
  """
  conquest_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_order_by!]

    """filter the rows returned"""
    where: conquest_pack_bool_exp
  ): conquest_pack_aggregate!

  """fetch data from the table: "conquest.pack" using primary key columns"""
  conquest_pack_by_pk(id: String!): conquest_pack

  """
  fetch data from the table: "conquest.pack_text"
  """
  conquest_pack_text(
    """distinct select on columns"""
    distinct_on: [conquest_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_text_order_by!]

    """filter the rows returned"""
    where: conquest_pack_text_bool_exp
  ): [conquest_pack_text!]!

  """
  fetch aggregated fields from the table: "conquest.pack_text"
  """
  conquest_pack_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_text_order_by!]

    """filter the rows returned"""
    where: conquest_pack_text_bool_exp
  ): conquest_pack_text_aggregate!

  """
  fetch data from the table: "conquest.pack_text" using primary key columns
  """
  conquest_pack_text_by_pk(id: String!, locale: String!): conquest_pack_text

  """
  fetch data from the table: "conquest.type"
  """
  conquest_type(
    """distinct select on columns"""
    distinct_on: [conquest_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_order_by!]

    """filter the rows returned"""
    where: conquest_type_bool_exp
  ): [conquest_type!]!

  """
  fetch aggregated fields from the table: "conquest.type"
  """
  conquest_type_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_order_by!]

    """filter the rows returned"""
    where: conquest_type_bool_exp
  ): conquest_type_aggregate!

  """fetch data from the table: "conquest.type" using primary key columns"""
  conquest_type_by_pk(id: String!): conquest_type

  """
  fetch data from the table: "conquest.type_text"
  """
  conquest_type_text(
    """distinct select on columns"""
    distinct_on: [conquest_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_text_order_by!]

    """filter the rows returned"""
    where: conquest_type_text_bool_exp
  ): [conquest_type_text!]!

  """
  fetch aggregated fields from the table: "conquest.type_text"
  """
  conquest_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_text_order_by!]

    """filter the rows returned"""
    where: conquest_type_text_bool_exp
  ): conquest_type_text_aggregate!

  """
  fetch data from the table: "conquest.type_text" using primary key columns
  """
  conquest_type_text_by_pk(id: String!, locale: String!): conquest_type_text

  """
  fetch data from the table: "conquest.user_role"
  """
  conquest_user_role(
    """distinct select on columns"""
    distinct_on: [conquest_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_role_order_by!]

    """filter the rows returned"""
    where: conquest_user_role_bool_exp
  ): [conquest_user_role!]!

  """
  fetch aggregated fields from the table: "conquest.user_role"
  """
  conquest_user_role_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_role_order_by!]

    """filter the rows returned"""
    where: conquest_user_role_bool_exp
  ): conquest_user_role_aggregate!

  """
  fetch data from the table: "conquest.user_role" using primary key columns
  """
  conquest_user_role_by_pk(id: String!): conquest_user_role

  """
  fetch data from the table: "conquest.user_settings"
  """
  conquest_user_settings(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): [conquest_user_settings!]!

  """
  fetch aggregated fields from the table: "conquest.user_settings"
  """
  conquest_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): conquest_user_settings_aggregate!

  """
  fetch data from the table: "conquest.user_settings" using primary key columns
  """
  conquest_user_settings_by_pk(user_id: String!): conquest_user_settings

  """
  fetch data from the table: "conquest.users"
  """
  conquest_users(
    """distinct select on columns"""
    distinct_on: [conquest_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_users_order_by!]

    """filter the rows returned"""
    where: conquest_users_bool_exp
  ): [conquest_users!]!

  """
  fetch aggregated fields from the table: "conquest.users"
  """
  conquest_users_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_users_order_by!]

    """filter the rows returned"""
    where: conquest_users_bool_exp
  ): conquest_users_aggregate!

  """fetch data from the table: "conquest.users" using primary key columns"""
  conquest_users_by_pk(id: String!): conquest_users

  """
  fetch data from the table: "cycle"
  """
  cycle(
    """distinct select on columns"""
    distinct_on: [cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_order_by!]

    """filter the rows returned"""
    where: cycle_bool_exp
  ): [cycle!]!

  """
  fetch aggregated fields from the table: "cycle"
  """
  cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_order_by!]

    """filter the rows returned"""
    where: cycle_bool_exp
  ): cycle_aggregate!

  """fetch data from the table: "cycle" using primary key columns"""
  cycle_by_pk(code: String!): cycle

  """
  fetch data from the table: "cycle_name"
  """
  cycle_name(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): [cycle_name!]!

  """
  fetch aggregated fields from the table: "cycle_name"
  """
  cycle_name_aggregate(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): cycle_name_aggregate!

  """fetch data from the table: "cycle_name" using primary key columns"""
  cycle_name_by_pk(code: String!, locale: String!): cycle_name

  """
  fetch data from the table: "faction_name"
  """
  faction_name(
    """distinct select on columns"""
    distinct_on: [faction_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faction_name_order_by!]

    """filter the rows returned"""
    where: faction_name_bool_exp
  ): [faction_name!]!

  """
  fetch aggregated fields from the table: "faction_name"
  """
  faction_name_aggregate(
    """distinct select on columns"""
    distinct_on: [faction_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faction_name_order_by!]

    """filter the rows returned"""
    where: faction_name_bool_exp
  ): faction_name_aggregate!

  """fetch data from the table: "faction_name" using primary key columns"""
  faction_name_by_pk(code: String!, locale: String!): faction_name

  """
  fetch data from the table: "faq"
  """
  faq(
    """distinct select on columns"""
    distinct_on: [faq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_order_by!]

    """filter the rows returned"""
    where: faq_bool_exp
  ): [faq!]!

  """
  fetch aggregated fields from the table: "faq"
  """
  faq_aggregate(
    """distinct select on columns"""
    distinct_on: [faq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_order_by!]

    """filter the rows returned"""
    where: faq_bool_exp
  ): faq_aggregate!

  """fetch data from the table: "faq" using primary key columns"""
  faq_by_pk(code: String!): faq

  """
  fetch data from the table: "faq_text"
  """
  faq_text(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): [faq_text!]!

  """
  fetch aggregated fields from the table: "faq_text"
  """
  faq_text_aggregate(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): faq_text_aggregate!

  """fetch data from the table: "faq_text" using primary key columns"""
  faq_text_by_pk(code: String!, locale: String!): faq_text

  """
  fetch data from the table: "friend_status"
  """
  friend_status(
    """distinct select on columns"""
    distinct_on: [friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_order_by!]

    """filter the rows returned"""
    where: friend_status_bool_exp
  ): [friend_status!]!

  """
  fetch aggregated fields from the table: "friend_status"
  """
  friend_status_aggregate(
    """distinct select on columns"""
    distinct_on: [friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_order_by!]

    """filter the rows returned"""
    where: friend_status_bool_exp
  ): friend_status_aggregate!

  """fetch data from the table: "friend_status" using primary key columns"""
  friend_status_by_pk(user_id_a: String!, user_id_b: String!): friend_status

  """
  fetch data from the table: "friend_status_type"
  """
  friend_status_type(
    """distinct select on columns"""
    distinct_on: [friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_type_order_by!]

    """filter the rows returned"""
    where: friend_status_type_bool_exp
  ): [friend_status_type!]!

  """
  fetch aggregated fields from the table: "friend_status_type"
  """
  friend_status_type_aggregate(
    """distinct select on columns"""
    distinct_on: [friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_type_order_by!]

    """filter the rows returned"""
    where: friend_status_type_bool_exp
  ): friend_status_type_aggregate!

  """
  fetch data from the table: "friend_status_type" using primary key columns
  """
  friend_status_type_by_pk(value: String!): friend_status_type

  """
  fetch data from the table: "full_card"
  """
  full_card(
    """distinct select on columns"""
    distinct_on: [full_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_order_by!]

    """filter the rows returned"""
    where: full_card_bool_exp
  ): [full_card!]!

  """
  fetch aggregated fields from the table: "full_card"
  """
  full_card_aggregate(
    """distinct select on columns"""
    distinct_on: [full_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_order_by!]

    """filter the rows returned"""
    where: full_card_bool_exp
  ): full_card_aggregate!

  """fetch data from the table: "full_card" using primary key columns"""
  full_card_by_pk(code: String!): full_card

  """
  fetch data from the table: "full_card_text"
  """
  full_card_text(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): [full_card_text!]!

  """
  fetch aggregated fields from the table: "full_card_text"
  """
  full_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): full_card_text_aggregate!

  """fetch data from the table: "full_card_text" using primary key columns"""
  full_card_text_by_pk(code: String!, locale: String!): full_card_text

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(code: String!): gender

  """
  fetch data from the table: "guide_achievement"
  """
  guide_achievement(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): [guide_achievement!]!

  """
  fetch aggregated fields from the table: "guide_achievement"
  """
  guide_achievement_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): guide_achievement_aggregate!

  """
  fetch data from the table: "guide_achievement" using primary key columns
  """
  guide_achievement_by_pk(campaign_id: Int!, id: String!): guide_achievement

  """
  fetch data from the table: "guide_input"
  """
  guide_input(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): [guide_input!]!

  """
  fetch aggregated fields from the table: "guide_input"
  """
  guide_input_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): guide_input_aggregate!

  """fetch data from the table: "guide_input" using primary key columns"""
  guide_input_by_pk(campaign_id: Int!, id: String!): guide_input

  """An array relationship"""
  investigator_data(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): [investigator_data!]!

  """An aggregate relationship"""
  investigator_data_aggregate(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): investigator_data_aggregate!

  """
  fetch data from the table: "investigator_data" using primary key columns
  """
  investigator_data_by_pk(campaign_id: Int!, investigator: String!): investigator_data

  """An array relationship"""
  latest_decks(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): [latest_decks!]!

  """An aggregate relationship"""
  latest_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): latest_decks_aggregate!

  """An array relationship"""
  local_decks(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): [local_decks!]!

  """An aggregate relationship"""
  local_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): local_decks_aggregate!

  """
  fetch data from the table: "pack"
  """
  pack(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): [pack!]!

  """
  fetch aggregated fields from the table: "pack"
  """
  pack_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): pack_aggregate!

  """fetch data from the table: "pack" using primary key columns"""
  pack_by_pk(code: String!): pack

  """
  fetch data from the table: "pack_name"
  """
  pack_name(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): [pack_name!]!

  """
  fetch aggregated fields from the table: "pack_name"
  """
  pack_name_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): pack_name_aggregate!

  """fetch data from the table: "pack_name" using primary key columns"""
  pack_name_by_pk(code: String!, locale: String!): pack_name

  """
  fetch data from the table: "rangers.area"
  """
  rangers_area(
    """distinct select on columns"""
    distinct_on: [rangers_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_order_by!]

    """filter the rows returned"""
    where: rangers_area_bool_exp
  ): [rangers_area!]!

  """
  fetch aggregated fields from the table: "rangers.area"
  """
  rangers_area_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_order_by!]

    """filter the rows returned"""
    where: rangers_area_bool_exp
  ): rangers_area_aggregate!

  """fetch data from the table: "rangers.area" using primary key columns"""
  rangers_area_by_pk(id: String!): rangers_area

  """
  fetch data from the table: "rangers.area_text"
  """
  rangers_area_text(
    """distinct select on columns"""
    distinct_on: [rangers_area_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_text_order_by!]

    """filter the rows returned"""
    where: rangers_area_text_bool_exp
  ): [rangers_area_text!]!

  """
  fetch aggregated fields from the table: "rangers.area_text"
  """
  rangers_area_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_area_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_text_order_by!]

    """filter the rows returned"""
    where: rangers_area_text_bool_exp
  ): rangers_area_text_aggregate!

  """
  fetch data from the table: "rangers.area_text" using primary key columns
  """
  rangers_area_text_by_pk(id: String!, locale: String!): rangers_area_text

  """
  fetch data from the table: "rangers.aspect"
  """
  rangers_aspect(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_bool_exp
  ): [rangers_aspect!]!

  """
  fetch aggregated fields from the table: "rangers.aspect"
  """
  rangers_aspect_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_bool_exp
  ): rangers_aspect_aggregate!

  """fetch data from the table: "rangers.aspect" using primary key columns"""
  rangers_aspect_by_pk(id: String!): rangers_aspect

  """
  fetch data from the table: "rangers.aspect_localized"
  """
  rangers_aspect_localized(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_localized_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_localized_bool_exp
  ): [rangers_aspect_localized!]!

  """
  fetch aggregated fields from the table: "rangers.aspect_localized"
  """
  rangers_aspect_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_localized_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_localized_bool_exp
  ): rangers_aspect_localized_aggregate!

  """
  fetch data from the table: "rangers.aspect_text"
  """
  rangers_aspect_text(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_text_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_text_bool_exp
  ): [rangers_aspect_text!]!

  """
  fetch aggregated fields from the table: "rangers.aspect_text"
  """
  rangers_aspect_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_text_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_text_bool_exp
  ): rangers_aspect_text_aggregate!

  """
  fetch data from the table: "rangers.aspect_text" using primary key columns
  """
  rangers_aspect_text_by_pk(id: String!, locale: String!): rangers_aspect_text

  """
  fetch data from the table: "rangers.campaign"
  """
  rangers_campaign(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): [rangers_campaign!]!

  """
  fetch data from the table: "rangers.campaign_access"
  """
  rangers_campaign_access(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_access_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_access_bool_exp
  ): [rangers_campaign_access!]!

  """
  fetch aggregated fields from the table: "rangers.campaign_access"
  """
  rangers_campaign_access_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_access_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_access_bool_exp
  ): rangers_campaign_access_aggregate!

  """
  fetch data from the table: "rangers.campaign_access" using primary key columns
  """
  rangers_campaign_access_by_pk(campaign_id: Int!, user_id: String!): rangers_campaign_access

  """
  fetch aggregated fields from the table: "rangers.campaign"
  """
  rangers_campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): rangers_campaign_aggregate!

  """
  fetch data from the table: "rangers.campaign" using primary key columns
  """
  rangers_campaign_by_pk(id: Int!): rangers_campaign

  """
  fetch data from the table: "rangers.card"
  """
  rangers_card(
    """distinct select on columns"""
    distinct_on: [rangers_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_order_by!]

    """filter the rows returned"""
    where: rangers_card_bool_exp
  ): [rangers_card!]!

  """
  fetch aggregated fields from the table: "rangers.card"
  """
  rangers_card_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_order_by!]

    """filter the rows returned"""
    where: rangers_card_bool_exp
  ): rangers_card_aggregate!

  """fetch data from the table: "rangers.card" using primary key columns"""
  rangers_card_by_pk(id: String!): rangers_card

  """
  fetch data from the table: "rangers.card_localized"
  """
  rangers_card_localized(
    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): [rangers_card_localized!]!

  """
  fetch aggregated fields from the table: "rangers.card_localized"
  """
  rangers_card_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): rangers_card_localized_aggregate!

  """
  execute function "rangers.card_search" which returns "rangers.card_localized"
  """
  rangers_card_search(
    """
    input parameters for function "rangers_card_search"
    """
    args: rangers_card_search_args

    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): [rangers_card_localized!]!

  """
  execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized"
  """
  rangers_card_search_aggregate(
    """
    input parameters for function "rangers_card_search_aggregate"
    """
    args: rangers_card_search_args

    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): rangers_card_localized_aggregate!

  """
  fetch data from the table: "rangers.card_text"
  """
  rangers_card_text(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): [rangers_card_text!]!

  """
  fetch aggregated fields from the table: "rangers.card_text"
  """
  rangers_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): rangers_card_text_aggregate!

  """
  fetch data from the table: "rangers.card_text" using primary key columns
  """
  rangers_card_text_by_pk(id: String!, locale: String!): rangers_card_text

  """
  fetch data from the table: "rangers.card_updated"
  """
  rangers_card_updated(
    """distinct select on columns"""
    distinct_on: [rangers_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_updated_order_by!]

    """filter the rows returned"""
    where: rangers_card_updated_bool_exp
  ): [rangers_card_updated!]!

  """
  fetch aggregated fields from the table: "rangers.card_updated"
  """
  rangers_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_updated_order_by!]

    """filter the rows returned"""
    where: rangers_card_updated_bool_exp
  ): rangers_card_updated_aggregate!

  """
  fetch data from the table: "rangers.comment"
  """
  rangers_comment(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): [rangers_comment!]!

  """
  fetch aggregated fields from the table: "rangers.comment"
  """
  rangers_comment_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): rangers_comment_aggregate!

  """fetch data from the table: "rangers.comment" using primary key columns"""
  rangers_comment_by_pk(id: uuid!): rangers_comment

  """
  fetch data from the table: "rangers.deck"
  """
  rangers_deck(
    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): [rangers_deck!]!

  """
  fetch aggregated fields from the table: "rangers.deck"
  """
  rangers_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): rangers_deck_aggregate!

  """fetch data from the table: "rangers.deck" using primary key columns"""
  rangers_deck_by_pk(id: Int!): rangers_deck

  """
  fetch data from the table: "rangers.deck_copy"
  """
  rangers_deck_copy(
    """distinct select on columns"""
    distinct_on: [rangers_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_copy_order_by!]

    """filter the rows returned"""
    where: rangers_deck_copy_bool_exp
  ): [rangers_deck_copy!]!

  """
  fetch aggregated fields from the table: "rangers.deck_copy"
  """
  rangers_deck_copy_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_copy_order_by!]

    """filter the rows returned"""
    where: rangers_deck_copy_bool_exp
  ): rangers_deck_copy_aggregate!

  """
  fetch data from the table: "rangers.deck_copy" using primary key columns
  """
  rangers_deck_copy_by_pk(copy_deck_id: Int!): rangers_deck_copy

  """
  fetch data from the table: "rangers.deck_like"
  """
  rangers_deck_like(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_bool_exp
  ): [rangers_deck_like!]!

  """
  fetch aggregated fields from the table: "rangers.deck_like"
  """
  rangers_deck_like_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_bool_exp
  ): rangers_deck_like_aggregate!

  """
  fetch data from the table: "rangers.deck_like" using primary key columns
  """
  rangers_deck_like_by_pk(deck_id: Int!, user_id: String!): rangers_deck_like

  """
  fetch data from the table: "rangers.deck_like_count"
  """
  rangers_deck_like_count(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_count_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_count_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_count_bool_exp
  ): [rangers_deck_like_count!]!

  """
  fetch aggregated fields from the table: "rangers.deck_like_count"
  """
  rangers_deck_like_count_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_count_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_count_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_count_bool_exp
  ): rangers_deck_like_count_aggregate!

  """
  fetch data from the table: "rangers.deck_like_count" using primary key columns
  """
  rangers_deck_like_count_by_pk(deck_id: Int!): rangers_deck_like_count

  """
  fetch data from the table: "rangers.deck_rank"
  """
  rangers_deck_rank(
    """distinct select on columns"""
    distinct_on: [rangers_deck_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_rank_order_by!]

    """filter the rows returned"""
    where: rangers_deck_rank_bool_exp
  ): [rangers_deck_rank!]!

  """
  fetch aggregated fields from the table: "rangers.deck_rank"
  """
  rangers_deck_rank_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_rank_order_by!]

    """filter the rows returned"""
    where: rangers_deck_rank_bool_exp
  ): rangers_deck_rank_aggregate!

  """
  execute function "rangers.deck_search" which returns "rangers.search_deck"
  """
  rangers_deck_search(
    """
    input parameters for function "rangers_deck_search"
    """
    args: rangers_deck_search_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck"
  """
  rangers_deck_search_aggregate(
    """
    input parameters for function "rangers_deck_search_aggregate"
    """
    args: rangers_deck_search_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table: "rangers.faq_entry"
  """
  rangers_faq_entry(
    """distinct select on columns"""
    distinct_on: [rangers_faq_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_faq_entry_order_by!]

    """filter the rows returned"""
    where: rangers_faq_entry_bool_exp
  ): [rangers_faq_entry!]!

  """
  fetch aggregated fields from the table: "rangers.faq_entry"
  """
  rangers_faq_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_faq_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_faq_entry_order_by!]

    """filter the rows returned"""
    where: rangers_faq_entry_bool_exp
  ): rangers_faq_entry_aggregate!

  """
  fetch data from the table: "rangers.faq_entry" using primary key columns
  """
  rangers_faq_entry_by_pk(id: String!): rangers_faq_entry

  """
  fetch data from the table: "rangers.friend_status"
  """
  rangers_friend_status(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_bool_exp
  ): [rangers_friend_status!]!

  """
  fetch aggregated fields from the table: "rangers.friend_status"
  """
  rangers_friend_status_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_bool_exp
  ): rangers_friend_status_aggregate!

  """
  fetch data from the table: "rangers.friend_status" using primary key columns
  """
  rangers_friend_status_by_pk(user_id_a: String!, user_id_b: String!): rangers_friend_status

  """
  fetch data from the table: "rangers.friend_status_type"
  """
  rangers_friend_status_type(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_type_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_type_bool_exp
  ): [rangers_friend_status_type!]!

  """
  fetch aggregated fields from the table: "rangers.friend_status_type"
  """
  rangers_friend_status_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_type_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_type_bool_exp
  ): rangers_friend_status_type_aggregate!

  """
  fetch data from the table: "rangers.friend_status_type" using primary key columns
  """
  rangers_friend_status_type_by_pk(value: String!): rangers_friend_status_type

  """
  fetch data from the table: "rangers.latest_deck"
  """
  rangers_latest_deck(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): [rangers_latest_deck!]!

  """
  fetch aggregated fields from the table: "rangers.latest_deck"
  """
  rangers_latest_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): rangers_latest_deck_aggregate!

  """
  fetch data from the table: "rangers.locale"
  """
  rangers_locale(
    """distinct select on columns"""
    distinct_on: [rangers_locale_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_locale_order_by!]

    """filter the rows returned"""
    where: rangers_locale_bool_exp
  ): [rangers_locale!]!

  """
  fetch aggregated fields from the table: "rangers.locale"
  """
  rangers_locale_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_locale_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_locale_order_by!]

    """filter the rows returned"""
    where: rangers_locale_bool_exp
  ): rangers_locale_aggregate!

  """fetch data from the table: "rangers.locale" using primary key columns"""
  rangers_locale_by_pk(locale: String!): rangers_locale

  """
  fetch data from the table: "rangers.pack"
  """
  rangers_pack(
    """distinct select on columns"""
    distinct_on: [rangers_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_order_by!]

    """filter the rows returned"""
    where: rangers_pack_bool_exp
  ): [rangers_pack!]!

  """
  fetch aggregated fields from the table: "rangers.pack"
  """
  rangers_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_order_by!]

    """filter the rows returned"""
    where: rangers_pack_bool_exp
  ): rangers_pack_aggregate!

  """fetch data from the table: "rangers.pack" using primary key columns"""
  rangers_pack_by_pk(id: String!): rangers_pack

  """
  fetch data from the table: "rangers.pack_localized"
  """
  rangers_pack_localized(
    """distinct select on columns"""
    distinct_on: [rangers_pack_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_localized_order_by!]

    """filter the rows returned"""
    where: rangers_pack_localized_bool_exp
  ): [rangers_pack_localized!]!

  """
  fetch aggregated fields from the table: "rangers.pack_localized"
  """
  rangers_pack_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_localized_order_by!]

    """filter the rows returned"""
    where: rangers_pack_localized_bool_exp
  ): rangers_pack_localized_aggregate!

  """
  fetch data from the table: "rangers.pack_text"
  """
  rangers_pack_text(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): [rangers_pack_text!]!

  """
  fetch aggregated fields from the table: "rangers.pack_text"
  """
  rangers_pack_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): rangers_pack_text_aggregate!

  """
  fetch data from the table: "rangers.pack_text" using primary key columns
  """
  rangers_pack_text_by_pk(id: String!, locale: String!): rangers_pack_text

  """
  execute function "rangers.search_all_decks" which returns "rangers.search_deck"
  """
  rangers_search_all_decks(
    """
    input parameters for function "rangers_search_all_decks"
    """
    args: rangers_search_all_decks_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  execute function "rangers.search_all_decks" and query aggregates on result of table type "rangers.search_deck"
  """
  rangers_search_all_decks_aggregate(
    """
    input parameters for function "rangers_search_all_decks_aggregate"
    """
    args: rangers_search_all_decks_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table: "rangers.search_deck"
  """
  rangers_search_deck(
    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  fetch aggregated fields from the table: "rangers.search_deck"
  """
  rangers_search_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table: "rangers.set"
  """
  rangers_set(
    """distinct select on columns"""
    distinct_on: [rangers_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_order_by!]

    """filter the rows returned"""
    where: rangers_set_bool_exp
  ): [rangers_set!]!

  """
  fetch aggregated fields from the table: "rangers.set"
  """
  rangers_set_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_order_by!]

    """filter the rows returned"""
    where: rangers_set_bool_exp
  ): rangers_set_aggregate!

  """fetch data from the table: "rangers.set" using primary key columns"""
  rangers_set_by_pk(id: String!): rangers_set

  """
  fetch data from the table: "rangers.set_localized"
  """
  rangers_set_localized(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): [rangers_set_localized!]!

  """
  fetch aggregated fields from the table: "rangers.set_localized"
  """
  rangers_set_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): rangers_set_localized_aggregate!

  """
  fetch data from the table: "rangers.set_text"
  """
  rangers_set_text(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): [rangers_set_text!]!

  """
  fetch aggregated fields from the table: "rangers.set_text"
  """
  rangers_set_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): rangers_set_text_aggregate!

  """
  fetch data from the table: "rangers.set_text" using primary key columns
  """
  rangers_set_text_by_pk(id: String!, locale: String!): rangers_set_text

  """
  fetch data from the table: "rangers.set_type"
  """
  rangers_set_type(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_bool_exp
  ): [rangers_set_type!]!

  """
  fetch aggregated fields from the table: "rangers.set_type"
  """
  rangers_set_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_bool_exp
  ): rangers_set_type_aggregate!

  """
  fetch data from the table: "rangers.set_type" using primary key columns
  """
  rangers_set_type_by_pk(id: String!): rangers_set_type

  """
  fetch data from the table: "rangers.set_type_localized"
  """
  rangers_set_type_localized(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_localized_bool_exp
  ): [rangers_set_type_localized!]!

  """
  fetch aggregated fields from the table: "rangers.set_type_localized"
  """
  rangers_set_type_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_localized_bool_exp
  ): rangers_set_type_localized_aggregate!

  """
  fetch data from the table: "rangers.set_type_text"
  """
  rangers_set_type_text(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): [rangers_set_type_text!]!

  """
  fetch aggregated fields from the table: "rangers.set_type_text"
  """
  rangers_set_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): rangers_set_type_text_aggregate!

  """
  fetch data from the table: "rangers.set_type_text" using primary key columns
  """
  rangers_set_type_text_by_pk(id: String!, locale: String!): rangers_set_type_text

  """
  fetch data from the table: "rangers.subset"
  """
  rangers_subset(
    """distinct select on columns"""
    distinct_on: [rangers_subset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_order_by!]

    """filter the rows returned"""
    where: rangers_subset_bool_exp
  ): [rangers_subset!]!

  """
  fetch aggregated fields from the table: "rangers.subset"
  """
  rangers_subset_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_order_by!]

    """filter the rows returned"""
    where: rangers_subset_bool_exp
  ): rangers_subset_aggregate!

  """fetch data from the table: "rangers.subset" using primary key columns"""
  rangers_subset_by_pk(id: String!): rangers_subset

  """
  fetch data from the table: "rangers.subset_localized"
  """
  rangers_subset_localized(
    """distinct select on columns"""
    distinct_on: [rangers_subset_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_localized_order_by!]

    """filter the rows returned"""
    where: rangers_subset_localized_bool_exp
  ): [rangers_subset_localized!]!

  """
  fetch aggregated fields from the table: "rangers.subset_localized"
  """
  rangers_subset_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_localized_order_by!]

    """filter the rows returned"""
    where: rangers_subset_localized_bool_exp
  ): rangers_subset_localized_aggregate!

  """
  fetch data from the table: "rangers.subset_text"
  """
  rangers_subset_text(
    """distinct select on columns"""
    distinct_on: [rangers_subset_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_text_order_by!]

    """filter the rows returned"""
    where: rangers_subset_text_bool_exp
  ): [rangers_subset_text!]!

  """
  fetch aggregated fields from the table: "rangers.subset_text"
  """
  rangers_subset_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_text_order_by!]

    """filter the rows returned"""
    where: rangers_subset_text_bool_exp
  ): rangers_subset_text_aggregate!

  """
  fetch data from the table: "rangers.subset_text" using primary key columns
  """
  rangers_subset_text_by_pk(id: String!, locale: String!): rangers_subset_text

  """
  fetch data from the table: "rangers.taboo_set"
  """
  rangers_taboo_set(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_bool_exp
  ): [rangers_taboo_set!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set"
  """
  rangers_taboo_set_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_bool_exp
  ): rangers_taboo_set_aggregate!

  """
  fetch data from the table: "rangers.taboo_set" using primary key columns
  """
  rangers_taboo_set_by_pk(id: String!): rangers_taboo_set

  """
  fetch data from the table: "rangers.taboo_set_localized"
  """
  rangers_taboo_set_localized(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_localized_bool_exp
  ): [rangers_taboo_set_localized!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set_localized"
  """
  rangers_taboo_set_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_localized_bool_exp
  ): rangers_taboo_set_localized_aggregate!

  """
  fetch data from the table: "rangers.taboo_set_text"
  """
  rangers_taboo_set_text(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_text_bool_exp
  ): [rangers_taboo_set_text!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set_text"
  """
  rangers_taboo_set_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_text_bool_exp
  ): rangers_taboo_set_text_aggregate!

  """
  fetch data from the table: "rangers.taboo_set_text" using primary key columns
  """
  rangers_taboo_set_text_by_pk(id: String!, locale: String!): rangers_taboo_set_text

  """
  fetch data from the table: "rangers.token"
  """
  rangers_token(
    """distinct select on columns"""
    distinct_on: [rangers_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_order_by!]

    """filter the rows returned"""
    where: rangers_token_bool_exp
  ): [rangers_token!]!

  """
  fetch aggregated fields from the table: "rangers.token"
  """
  rangers_token_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_order_by!]

    """filter the rows returned"""
    where: rangers_token_bool_exp
  ): rangers_token_aggregate!

  """fetch data from the table: "rangers.token" using primary key columns"""
  rangers_token_by_pk(id: String!): rangers_token

  """
  fetch data from the table: "rangers.token_text"
  """
  rangers_token_text(
    """distinct select on columns"""
    distinct_on: [rangers_token_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_text_order_by!]

    """filter the rows returned"""
    where: rangers_token_text_bool_exp
  ): [rangers_token_text!]!

  """
  fetch aggregated fields from the table: "rangers.token_text"
  """
  rangers_token_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_token_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_text_order_by!]

    """filter the rows returned"""
    where: rangers_token_text_bool_exp
  ): rangers_token_text_aggregate!

  """
  fetch data from the table: "rangers.token_text" using primary key columns
  """
  rangers_token_text_by_pk(id: String!, locale: String!): rangers_token_text

  """
  fetch data from the table: "rangers.type"
  """
  rangers_type(
    """distinct select on columns"""
    distinct_on: [rangers_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_order_by!]

    """filter the rows returned"""
    where: rangers_type_bool_exp
  ): [rangers_type!]!

  """
  fetch aggregated fields from the table: "rangers.type"
  """
  rangers_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_order_by!]

    """filter the rows returned"""
    where: rangers_type_bool_exp
  ): rangers_type_aggregate!

  """fetch data from the table: "rangers.type" using primary key columns"""
  rangers_type_by_pk(id: String!): rangers_type

  """
  fetch data from the table: "rangers.type_localized"
  """
  rangers_type_localized(
    """distinct select on columns"""
    distinct_on: [rangers_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_type_localized_bool_exp
  ): [rangers_type_localized!]!

  """
  fetch aggregated fields from the table: "rangers.type_localized"
  """
  rangers_type_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_type_localized_bool_exp
  ): rangers_type_localized_aggregate!

  """
  fetch data from the table: "rangers.type_text"
  """
  rangers_type_text(
    """distinct select on columns"""
    distinct_on: [rangers_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_type_text_bool_exp
  ): [rangers_type_text!]!

  """
  fetch aggregated fields from the table: "rangers.type_text"
  """
  rangers_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_type_text_bool_exp
  ): rangers_type_text_aggregate!

  """
  fetch data from the table: "rangers.type_text" using primary key columns
  """
  rangers_type_text_by_pk(id: String!, locale: String!): rangers_type_text

  """
  fetch data from the table: "rangers.user_campaign"
  """
  rangers_user_campaign(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): [rangers_user_campaign!]!

  """
  fetch aggregated fields from the table: "rangers.user_campaign"
  """
  rangers_user_campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): rangers_user_campaign_aggregate!

  """
  fetch data from the table: "rangers.user_friends"
  """
  rangers_user_friends(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): [rangers_user_friends!]!

  """
  fetch aggregated fields from the table: "rangers.user_friends"
  """
  rangers_user_friends_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): rangers_user_friends_aggregate!

  """
  fetch data from the table: "rangers.user_received_friend_requests"
  """
  rangers_user_received_friend_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): [rangers_user_received_friend_requests!]!

  """
  fetch aggregated fields from the table: "rangers.user_received_friend_requests"
  """
  rangers_user_received_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): rangers_user_received_friend_requests_aggregate!

  """
  fetch data from the table: "rangers.user_role"
  """
  rangers_user_role(
    """distinct select on columns"""
    distinct_on: [rangers_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_role_order_by!]

    """filter the rows returned"""
    where: rangers_user_role_bool_exp
  ): [rangers_user_role!]!

  """
  fetch aggregated fields from the table: "rangers.user_role"
  """
  rangers_user_role_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_role_order_by!]

    """filter the rows returned"""
    where: rangers_user_role_bool_exp
  ): rangers_user_role_aggregate!

  """
  fetch data from the table: "rangers.user_role" using primary key columns
  """
  rangers_user_role_by_pk(id: String!): rangers_user_role

  """
  fetch data from the table: "rangers.user_sent_friend_requests"
  """
  rangers_user_sent_friend_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): [rangers_user_sent_friend_requests!]!

  """
  fetch aggregated fields from the table: "rangers.user_sent_friend_requests"
  """
  rangers_user_sent_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): rangers_user_sent_friend_requests_aggregate!

  """
  fetch data from the table: "rangers.user_settings"
  """
  rangers_user_settings(
    """distinct select on columns"""
    distinct_on: [rangers_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_settings_order_by!]

    """filter the rows returned"""
    where: rangers_user_settings_bool_exp
  ): [rangers_user_settings!]!

  """
  fetch aggregated fields from the table: "rangers.user_settings"
  """
  rangers_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_settings_order_by!]

    """filter the rows returned"""
    where: rangers_user_settings_bool_exp
  ): rangers_user_settings_aggregate!

  """
  fetch data from the table: "rangers.user_settings" using primary key columns
  """
  rangers_user_settings_by_pk(user_id: String!): rangers_user_settings

  """
  fetch data from the table: "rangers.users"
  """
  rangers_users(
    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): [rangers_users!]!

  """
  fetch aggregated fields from the table: "rangers.users"
  """
  rangers_users_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): rangers_users_aggregate!

  """fetch data from the table: "rangers.users" using primary key columns"""
  rangers_users_by_pk(id: String!): rangers_users

  """
  fetch data from the table: "taboo_set"
  """
  taboo_set(
    """distinct select on columns"""
    distinct_on: [taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [taboo_set_order_by!]

    """filter the rows returned"""
    where: taboo_set_bool_exp
  ): [taboo_set!]!

  """
  fetch aggregated fields from the table: "taboo_set"
  """
  taboo_set_aggregate(
    """distinct select on columns"""
    distinct_on: [taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [taboo_set_order_by!]

    """filter the rows returned"""
    where: taboo_set_bool_exp
  ): taboo_set_aggregate!

  """fetch data from the table: "taboo_set" using primary key columns"""
  taboo_set_by_pk(id: Int!): taboo_set

  """
  fetch data from the table: "user_campaigns"
  """
  user_campaigns(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): [user_campaigns!]!

  """
  fetch aggregated fields from the table: "user_campaigns"
  """
  user_campaigns_aggregate(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): user_campaigns_aggregate!

  """
  fetch data from the table: "user_flag"
  """
  user_flag(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): [user_flag!]!

  """
  fetch aggregated fields from the table: "user_flag"
  """
  user_flag_aggregate(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): user_flag_aggregate!

  """fetch data from the table: "user_flag" using primary key columns"""
  user_flag_by_pk(flag: user_flag_type_enum!, user_id: String!): user_flag

  """
  fetch data from the table: "user_flag_type"
  """
  user_flag_type(
    """distinct select on columns"""
    distinct_on: [user_flag_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_type_order_by!]

    """filter the rows returned"""
    where: user_flag_type_bool_exp
  ): [user_flag_type!]!

  """
  fetch aggregated fields from the table: "user_flag_type"
  """
  user_flag_type_aggregate(
    """distinct select on columns"""
    distinct_on: [user_flag_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_type_order_by!]

    """filter the rows returned"""
    where: user_flag_type_bool_exp
  ): user_flag_type_aggregate!

  """fetch data from the table: "user_flag_type" using primary key columns"""
  user_flag_type_by_pk(value: String!): user_flag_type

  """
  fetch data from the table: "user_friends"
  """
  user_friends(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): [user_friends!]!

  """
  fetch aggregated fields from the table: "user_friends"
  """
  user_friends_aggregate(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): user_friends_aggregate!

  """
  fetch data from the table: "user_received_friend_requests"
  """
  user_received_friend_requests(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): [user_received_friend_requests!]!

  """
  fetch aggregated fields from the table: "user_received_friend_requests"
  """
  user_received_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): user_received_friend_requests_aggregate!

  """
  fetch data from the table: "user_sent_friend_requests"
  """
  user_sent_friend_requests(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): [user_sent_friend_requests!]!

  """
  fetch aggregated fields from the table: "user_sent_friend_requests"
  """
  user_sent_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): user_sent_friend_requests_aggregate!

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(user_id: String!): user_settings

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
  usersSearch(args: UsersSearchInput!): UsersSearchOutput

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: String!): users
}

"""
columns and relationships of "rangers.area"
"""
type rangers_area {
  id: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.area"
"""
type rangers_area_aggregate {
  aggregate: rangers_area_aggregate_fields
  nodes: [rangers_area!]!
}

"""
aggregate fields of "rangers.area"
"""
type rangers_area_aggregate_fields {
  count(columns: [rangers_area_select_column!], distinct: Boolean): Int!
  max: rangers_area_max_fields
  min: rangers_area_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.area". All fields are combined with a logical 'AND'.
"""
input rangers_area_bool_exp {
  _and: [rangers_area_bool_exp!]
  _not: rangers_area_bool_exp
  _or: [rangers_area_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.area"
"""
enum rangers_area_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  area_pkey
}

"""
input type for inserting data into table "rangers.area"
"""
input rangers_area_insert_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_area_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_area_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.area"
"""
type rangers_area_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_area!]!
}

"""
on_conflict condition type for table "rangers.area"
"""
input rangers_area_on_conflict {
  constraint: rangers_area_constraint!
  update_columns: [rangers_area_update_column!]! = []
  where: rangers_area_bool_exp
}

"""Ordering options when selecting data from "rangers.area"."""
input rangers_area_order_by {
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.area"""
input rangers_area_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.area"
"""
enum rangers_area_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.area"
"""
input rangers_area_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_area"
"""
input rangers_area_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_area_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_area_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.area_text"
"""
type rangers_area_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.area_text"
"""
type rangers_area_text_aggregate {
  aggregate: rangers_area_text_aggregate_fields
  nodes: [rangers_area_text!]!
}

"""
aggregate fields of "rangers.area_text"
"""
type rangers_area_text_aggregate_fields {
  count(columns: [rangers_area_text_select_column!], distinct: Boolean): Int!
  max: rangers_area_text_max_fields
  min: rangers_area_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.area_text". All fields are combined with a logical 'AND'.
"""
input rangers_area_text_bool_exp {
  _and: [rangers_area_text_bool_exp!]
  _not: rangers_area_text_bool_exp
  _or: [rangers_area_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.area_text"
"""
enum rangers_area_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  area_text_pkey
}

"""
input type for inserting data into table "rangers.area_text"
"""
input rangers_area_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_area_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_area_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.area_text"
"""
type rangers_area_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_area_text!]!
}

"""
on_conflict condition type for table "rangers.area_text"
"""
input rangers_area_text_on_conflict {
  constraint: rangers_area_text_constraint!
  update_columns: [rangers_area_text_update_column!]! = []
  where: rangers_area_text_bool_exp
}

"""Ordering options when selecting data from "rangers.area_text"."""
input rangers_area_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.area_text"""
input rangers_area_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.area_text"
"""
enum rangers_area_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.area_text"
"""
input rangers_area_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_area_text"
"""
input rangers_area_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_area_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_area_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.area_text"
"""
enum rangers_area_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_area_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_area_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_area_text_bool_exp!
}

"""
update columns of table "rangers.area"
"""
enum rangers_area_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_area_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_area_set_input

  """filter the rows which have to be updated"""
  where: rangers_area_bool_exp!
}

"""
columns and relationships of "rangers.aspect"
"""
type rangers_aspect {
  id: String!
  name: String!
  short_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.aspect"
"""
type rangers_aspect_aggregate {
  aggregate: rangers_aspect_aggregate_fields
  nodes: [rangers_aspect!]!
}

"""
aggregate fields of "rangers.aspect"
"""
type rangers_aspect_aggregate_fields {
  count(columns: [rangers_aspect_select_column!], distinct: Boolean): Int!
  max: rangers_aspect_max_fields
  min: rangers_aspect_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.aspect". All fields are combined with a logical 'AND'.
"""
input rangers_aspect_bool_exp {
  _and: [rangers_aspect_bool_exp!]
  _not: rangers_aspect_bool_exp
  _or: [rangers_aspect_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.aspect"
"""
enum rangers_aspect_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  aspect_pkey
}

"""
input type for inserting data into table "rangers.aspect"
"""
input rangers_aspect_insert_input {
  id: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.aspect_localized"
"""
type rangers_aspect_localized {
  id: String
  locale: String
  name: String
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.aspect_localized"
"""
type rangers_aspect_localized_aggregate {
  aggregate: rangers_aspect_localized_aggregate_fields
  nodes: [rangers_aspect_localized!]!
}

"""
aggregate fields of "rangers.aspect_localized"
"""
type rangers_aspect_localized_aggregate_fields {
  count(columns: [rangers_aspect_localized_select_column!], distinct: Boolean): Int!
  max: rangers_aspect_localized_max_fields
  min: rangers_aspect_localized_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.aspect_localized". All fields are combined with a logical 'AND'.
"""
input rangers_aspect_localized_bool_exp {
  _and: [rangers_aspect_localized_bool_exp!]
  _not: rangers_aspect_localized_bool_exp
  _or: [rangers_aspect_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  real_name: String_comparison_exp
  real_short_name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_aspect_localized_max_fields {
  id: String
  locale: String
  name: String
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_aspect_localized_min_fields {
  id: String
  locale: String
  name: String
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.aspect_localized"."""
input rangers_aspect_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  real_short_name: order_by
  short_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.aspect_localized"
"""
enum rangers_aspect_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  real_name

  """column name"""
  real_short_name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "rangers_aspect_localized"
"""
input rangers_aspect_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_aspect_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_aspect_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_aspect_max_fields {
  id: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_aspect_min_fields {
  id: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.aspect"
"""
type rangers_aspect_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_aspect!]!
}

"""
on_conflict condition type for table "rangers.aspect"
"""
input rangers_aspect_on_conflict {
  constraint: rangers_aspect_constraint!
  update_columns: [rangers_aspect_update_column!]! = []
  where: rangers_aspect_bool_exp
}

"""Ordering options when selecting data from "rangers.aspect"."""
input rangers_aspect_order_by {
  id: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.aspect"""
input rangers_aspect_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.aspect"
"""
enum rangers_aspect_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.aspect"
"""
input rangers_aspect_set_input {
  id: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_aspect"
"""
input rangers_aspect_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_aspect_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_aspect_stream_cursor_value_input {
  id: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.aspect_text"
"""
type rangers_aspect_text {
  id: String!
  locale: String!
  name: String!
  short_name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.aspect_text"
"""
type rangers_aspect_text_aggregate {
  aggregate: rangers_aspect_text_aggregate_fields
  nodes: [rangers_aspect_text!]!
}

"""
aggregate fields of "rangers.aspect_text"
"""
type rangers_aspect_text_aggregate_fields {
  count(columns: [rangers_aspect_text_select_column!], distinct: Boolean): Int!
  max: rangers_aspect_text_max_fields
  min: rangers_aspect_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.aspect_text". All fields are combined with a logical 'AND'.
"""
input rangers_aspect_text_bool_exp {
  _and: [rangers_aspect_text_bool_exp!]
  _not: rangers_aspect_text_bool_exp
  _or: [rangers_aspect_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.aspect_text"
"""
enum rangers_aspect_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  aspect_text_pkey
}

"""
input type for inserting data into table "rangers.aspect_text"
"""
input rangers_aspect_text_insert_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_aspect_text_max_fields {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_aspect_text_min_fields {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.aspect_text"
"""
type rangers_aspect_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_aspect_text!]!
}

"""
on_conflict condition type for table "rangers.aspect_text"
"""
input rangers_aspect_text_on_conflict {
  constraint: rangers_aspect_text_constraint!
  update_columns: [rangers_aspect_text_update_column!]! = []
  where: rangers_aspect_text_bool_exp
}

"""Ordering options when selecting data from "rangers.aspect_text"."""
input rangers_aspect_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.aspect_text"""
input rangers_aspect_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.aspect_text"
"""
enum rangers_aspect_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.aspect_text"
"""
input rangers_aspect_text_set_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_aspect_text"
"""
input rangers_aspect_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_aspect_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_aspect_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.aspect_text"
"""
enum rangers_aspect_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

input rangers_aspect_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_aspect_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_aspect_text_bool_exp!
}

"""
update columns of table "rangers.aspect"
"""
enum rangers_aspect_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

input rangers_aspect_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_aspect_set_input

  """filter the rows which have to be updated"""
  where: rangers_aspect_bool_exp!
}

"""
columns and relationships of "rangers.campaign"
"""
type rangers_campaign {
  """An array relationship"""
  access(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): [rangers_user_campaign!]!

  """An aggregate relationship"""
  access_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): rangers_user_campaign_aggregate!
  calendar(
    """JSON select path"""
    path: String
  ): jsonb!
  created_at: timestamptz!

  """An object relationship"""
  creator: rangers_users!
  current_location: String
  current_path_terrain: String
  cycle_id: String!
  day: Int!
  events(
    """JSON select path"""
    path: String
  ): jsonb!
  extended_calendar: Boolean
  history(
    """JSON select path"""
    path: String
  ): jsonb!
  id: Int!

  """An array relationship"""
  latest_decks(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): [rangers_latest_deck!]!

  """An aggregate relationship"""
  latest_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): rangers_latest_deck_aggregate!
  missions(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!
  notes(
    """JSON select path"""
    path: String
  ): jsonb!
  removed(
    """JSON select path"""
    path: String
  ): jsonb!
  rewards(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamptz!
  user_id: String!
}

"""
columns and relationships of "rangers.campaign_access"
"""
type rangers_campaign_access {
  """An object relationship"""
  campaign: rangers_campaign!
  campaign_id: Int!

  """An object relationship"""
  user: rangers_users!
  user_id: String!
}

"""
aggregated selection of "rangers.campaign_access"
"""
type rangers_campaign_access_aggregate {
  aggregate: rangers_campaign_access_aggregate_fields
  nodes: [rangers_campaign_access!]!
}

"""
aggregate fields of "rangers.campaign_access"
"""
type rangers_campaign_access_aggregate_fields {
  avg: rangers_campaign_access_avg_fields
  count(columns: [rangers_campaign_access_select_column!], distinct: Boolean): Int!
  max: rangers_campaign_access_max_fields
  min: rangers_campaign_access_min_fields
  stddev: rangers_campaign_access_stddev_fields
  stddev_pop: rangers_campaign_access_stddev_pop_fields
  stddev_samp: rangers_campaign_access_stddev_samp_fields
  sum: rangers_campaign_access_sum_fields
  var_pop: rangers_campaign_access_var_pop_fields
  var_samp: rangers_campaign_access_var_samp_fields
  variance: rangers_campaign_access_variance_fields
}

"""aggregate avg on columns"""
type rangers_campaign_access_avg_fields {
  campaign_id: Float
}

"""
Boolean expression to filter rows from the table "rangers.campaign_access". All fields are combined with a logical 'AND'.
"""
input rangers_campaign_access_bool_exp {
  _and: [rangers_campaign_access_bool_exp!]
  _not: rangers_campaign_access_bool_exp
  _or: [rangers_campaign_access_bool_exp!]
  campaign: rangers_campaign_bool_exp
  campaign_id: Int_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.campaign_access"
"""
enum rangers_campaign_access_constraint {
  """
  unique or primary key constraint on columns "user_id", "campaign_id"
  """
  campaign_access_pkey
}

"""
input type for incrementing numeric columns in table "rangers.campaign_access"
"""
input rangers_campaign_access_inc_input {
  campaign_id: Int
}

"""
input type for inserting data into table "rangers.campaign_access"
"""
input rangers_campaign_access_insert_input {
  campaign: rangers_campaign_obj_rel_insert_input
  campaign_id: Int
  user: rangers_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type rangers_campaign_access_max_fields {
  campaign_id: Int
  user_id: String
}

"""aggregate min on columns"""
type rangers_campaign_access_min_fields {
  campaign_id: Int
  user_id: String
}

"""
response of any mutation on the table "rangers.campaign_access"
"""
type rangers_campaign_access_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_campaign_access!]!
}

"""
on_conflict condition type for table "rangers.campaign_access"
"""
input rangers_campaign_access_on_conflict {
  constraint: rangers_campaign_access_constraint!
  update_columns: [rangers_campaign_access_update_column!]! = []
  where: rangers_campaign_access_bool_exp
}

"""Ordering options when selecting data from "rangers.campaign_access"."""
input rangers_campaign_access_order_by {
  campaign: rangers_campaign_order_by
  campaign_id: order_by
  user: rangers_users_order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.campaign_access"""
input rangers_campaign_access_pk_columns_input {
  campaign_id: Int!
  user_id: String!
}

"""
select columns of table "rangers.campaign_access"
"""
enum rangers_campaign_access_select_column {
  """column name"""
  campaign_id

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.campaign_access"
"""
input rangers_campaign_access_set_input {
  campaign_id: Int
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_campaign_access_stddev_fields {
  campaign_id: Float
}

"""aggregate stddev_pop on columns"""
type rangers_campaign_access_stddev_pop_fields {
  campaign_id: Float
}

"""aggregate stddev_samp on columns"""
type rangers_campaign_access_stddev_samp_fields {
  campaign_id: Float
}

"""
Streaming cursor of the table "rangers_campaign_access"
"""
input rangers_campaign_access_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_campaign_access_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_campaign_access_stream_cursor_value_input {
  campaign_id: Int
  user_id: String
}

"""aggregate sum on columns"""
type rangers_campaign_access_sum_fields {
  campaign_id: Int
}

"""
update columns of table "rangers.campaign_access"
"""
enum rangers_campaign_access_update_column {
  """column name"""
  campaign_id

  """column name"""
  user_id
}

input rangers_campaign_access_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_campaign_access_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_campaign_access_set_input

  """filter the rows which have to be updated"""
  where: rangers_campaign_access_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_campaign_access_var_pop_fields {
  campaign_id: Float
}

"""aggregate var_samp on columns"""
type rangers_campaign_access_var_samp_fields {
  campaign_id: Float
}

"""aggregate variance on columns"""
type rangers_campaign_access_variance_fields {
  campaign_id: Float
}

"""
aggregated selection of "rangers.campaign"
"""
type rangers_campaign_aggregate {
  aggregate: rangers_campaign_aggregate_fields
  nodes: [rangers_campaign!]!
}

"""
aggregate fields of "rangers.campaign"
"""
type rangers_campaign_aggregate_fields {
  avg: rangers_campaign_avg_fields
  count(columns: [rangers_campaign_select_column!], distinct: Boolean): Int!
  max: rangers_campaign_max_fields
  min: rangers_campaign_min_fields
  stddev: rangers_campaign_stddev_fields
  stddev_pop: rangers_campaign_stddev_pop_fields
  stddev_samp: rangers_campaign_stddev_samp_fields
  sum: rangers_campaign_sum_fields
  var_pop: rangers_campaign_var_pop_fields
  var_samp: rangers_campaign_var_samp_fields
  variance: rangers_campaign_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rangers_campaign_append_input {
  calendar: jsonb
  events: jsonb
  history: jsonb
  missions: jsonb
  notes: jsonb
  removed: jsonb
  rewards: jsonb
}

"""aggregate avg on columns"""
type rangers_campaign_avg_fields {
  day: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "rangers.campaign". All fields are combined with a logical 'AND'.
"""
input rangers_campaign_bool_exp {
  _and: [rangers_campaign_bool_exp!]
  _not: rangers_campaign_bool_exp
  _or: [rangers_campaign_bool_exp!]
  access: rangers_user_campaign_bool_exp
  access_aggregate: rangers_user_campaign_aggregate_bool_exp
  calendar: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  creator: rangers_users_bool_exp
  current_location: String_comparison_exp
  current_path_terrain: String_comparison_exp
  cycle_id: String_comparison_exp
  day: Int_comparison_exp
  events: jsonb_comparison_exp
  extended_calendar: Boolean_comparison_exp
  history: jsonb_comparison_exp
  id: Int_comparison_exp
  latest_decks: rangers_latest_deck_bool_exp
  latest_decks_aggregate: rangers_latest_deck_aggregate_bool_exp
  missions: jsonb_comparison_exp
  name: String_comparison_exp
  notes: jsonb_comparison_exp
  removed: jsonb_comparison_exp
  rewards: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.campaign"
"""
enum rangers_campaign_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  campaign_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rangers_campaign_delete_at_path_input {
  calendar: [String!]
  events: [String!]
  history: [String!]
  missions: [String!]
  notes: [String!]
  removed: [String!]
  rewards: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rangers_campaign_delete_elem_input {
  calendar: Int
  events: Int
  history: Int
  missions: Int
  notes: Int
  removed: Int
  rewards: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rangers_campaign_delete_key_input {
  calendar: String
  events: String
  history: String
  missions: String
  notes: String
  removed: String
  rewards: String
}

"""
input type for incrementing numeric columns in table "rangers.campaign"
"""
input rangers_campaign_inc_input {
  day: Int
  id: Int
}

"""
input type for inserting data into table "rangers.campaign"
"""
input rangers_campaign_insert_input {
  access: rangers_user_campaign_arr_rel_insert_input
  calendar: jsonb
  created_at: timestamptz
  creator: rangers_users_obj_rel_insert_input
  current_location: String
  current_path_terrain: String
  cycle_id: String
  day: Int
  events: jsonb
  extended_calendar: Boolean
  history: jsonb
  id: Int
  latest_decks: rangers_latest_deck_arr_rel_insert_input
  missions: jsonb
  name: String
  notes: jsonb
  removed: jsonb
  rewards: jsonb
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type rangers_campaign_max_fields {
  created_at: timestamptz
  current_location: String
  current_path_terrain: String
  cycle_id: String
  day: Int
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type rangers_campaign_min_fields {
  created_at: timestamptz
  current_location: String
  current_path_terrain: String
  cycle_id: String
  day: Int
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "rangers.campaign"
"""
type rangers_campaign_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_campaign!]!
}

"""
input type for inserting object relation for remote table "rangers.campaign"
"""
input rangers_campaign_obj_rel_insert_input {
  data: rangers_campaign_insert_input!

  """upsert condition"""
  on_conflict: rangers_campaign_on_conflict
}

"""
on_conflict condition type for table "rangers.campaign"
"""
input rangers_campaign_on_conflict {
  constraint: rangers_campaign_constraint!
  update_columns: [rangers_campaign_update_column!]! = []
  where: rangers_campaign_bool_exp
}

"""Ordering options when selecting data from "rangers.campaign"."""
input rangers_campaign_order_by {
  access_aggregate: rangers_user_campaign_aggregate_order_by
  calendar: order_by
  created_at: order_by
  creator: rangers_users_order_by
  current_location: order_by
  current_path_terrain: order_by
  cycle_id: order_by
  day: order_by
  events: order_by
  extended_calendar: order_by
  history: order_by
  id: order_by
  latest_decks_aggregate: rangers_latest_deck_aggregate_order_by
  missions: order_by
  name: order_by
  notes: order_by
  removed: order_by
  rewards: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.campaign"""
input rangers_campaign_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rangers_campaign_prepend_input {
  calendar: jsonb
  events: jsonb
  history: jsonb
  missions: jsonb
  notes: jsonb
  removed: jsonb
  rewards: jsonb
}

"""
select columns of table "rangers.campaign"
"""
enum rangers_campaign_select_column {
  """column name"""
  calendar

  """column name"""
  created_at

  """column name"""
  current_location

  """column name"""
  current_path_terrain

  """column name"""
  cycle_id

  """column name"""
  day

  """column name"""
  events

  """column name"""
  extended_calendar

  """column name"""
  history

  """column name"""
  id

  """column name"""
  missions

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  removed

  """column name"""
  rewards

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.campaign"
"""
input rangers_campaign_set_input {
  calendar: jsonb
  created_at: timestamptz
  current_location: String
  current_path_terrain: String
  cycle_id: String
  day: Int
  events: jsonb
  extended_calendar: Boolean
  history: jsonb
  id: Int
  missions: jsonb
  name: String
  notes: jsonb
  removed: jsonb
  rewards: jsonb
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_campaign_stddev_fields {
  day: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type rangers_campaign_stddev_pop_fields {
  day: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type rangers_campaign_stddev_samp_fields {
  day: Float
  id: Float
}

"""
Streaming cursor of the table "rangers_campaign"
"""
input rangers_campaign_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_campaign_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_campaign_stream_cursor_value_input {
  calendar: jsonb
  created_at: timestamptz
  current_location: String
  current_path_terrain: String
  cycle_id: String
  day: Int
  events: jsonb
  extended_calendar: Boolean
  history: jsonb
  id: Int
  missions: jsonb
  name: String
  notes: jsonb
  removed: jsonb
  rewards: jsonb
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type rangers_campaign_sum_fields {
  day: Int
  id: Int
}

"""
update columns of table "rangers.campaign"
"""
enum rangers_campaign_update_column {
  """column name"""
  calendar

  """column name"""
  created_at

  """column name"""
  current_location

  """column name"""
  current_path_terrain

  """column name"""
  cycle_id

  """column name"""
  day

  """column name"""
  events

  """column name"""
  extended_calendar

  """column name"""
  history

  """column name"""
  id

  """column name"""
  missions

  """column name"""
  name

  """column name"""
  notes

  """column name"""
  removed

  """column name"""
  rewards

  """column name"""
  updated_at

  """column name"""
  user_id
}

input rangers_campaign_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rangers_campaign_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rangers_campaign_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rangers_campaign_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rangers_campaign_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_campaign_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rangers_campaign_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_campaign_set_input

  """filter the rows which have to be updated"""
  where: rangers_campaign_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_campaign_var_pop_fields {
  day: Float
  id: Float
}

"""aggregate var_samp on columns"""
type rangers_campaign_var_samp_fields {
  day: Float
  id: Float
}

"""aggregate variance on columns"""
type rangers_campaign_variance_fields {
  day: Float
  id: Float
}

"""
columns and relationships of "rangers.card"
"""
type rangers_card {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String!
  illustrator: String
  imagesrc: String
  level: Int
  locations(
    """JSON select path"""
    path: String
  ): jsonb
  mountain_challenge: String
  name: String!
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int!
  set_id: String!
  set_position: Int!
  spoiler: Boolean
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): [rangers_card_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): rangers_card_text_aggregate!
  type_id: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.card"
"""
type rangers_card_aggregate {
  aggregate: rangers_card_aggregate_fields
  nodes: [rangers_card!]!
}

"""
aggregate fields of "rangers.card"
"""
type rangers_card_aggregate_fields {
  avg: rangers_card_avg_fields
  count(columns: [rangers_card_select_column!], distinct: Boolean): Int!
  max: rangers_card_max_fields
  min: rangers_card_min_fields
  stddev: rangers_card_stddev_fields
  stddev_pop: rangers_card_stddev_pop_fields
  stddev_samp: rangers_card_stddev_samp_fields
  sum: rangers_card_sum_fields
  var_pop: rangers_card_var_pop_fields
  var_samp: rangers_card_var_samp_fields
  variance: rangers_card_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rangers_card_append_input {
  locations: jsonb
}

"""aggregate avg on columns"""
type rangers_card_avg_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""
Boolean expression to filter rows from the table "rangers.card". All fields are combined with a logical 'AND'.
"""
input rangers_card_bool_exp {
  _and: [rangers_card_bool_exp!]
  _not: rangers_card_bool_exp
  _or: [rangers_card_bool_exp!]
  approach_conflict: Int_comparison_exp
  approach_connection: Int_comparison_exp
  approach_exploration: Int_comparison_exp
  approach_reason: Int_comparison_exp
  area_id: String_comparison_exp
  aspect_id: String_comparison_exp
  back_card_id: String_comparison_exp
  code: String_comparison_exp
  cost: Int_comparison_exp
  crest_challenge: String_comparison_exp
  deck_limit: Int_comparison_exp
  equip: Int_comparison_exp
  flavor: String_comparison_exp
  guide_entry: String_comparison_exp
  harm: Int_comparison_exp
  id: String_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  level: Int_comparison_exp
  locations: jsonb_comparison_exp
  mountain_challenge: String_comparison_exp
  name: String_comparison_exp
  objective: String_comparison_exp
  pack_id: String_comparison_exp
  position: Int_comparison_exp
  presence: Int_comparison_exp
  progress: Int_comparison_exp
  progress_fixed: Boolean_comparison_exp
  quantity: Int_comparison_exp
  set_id: String_comparison_exp
  set_position: Int_comparison_exp
  spoiler: Boolean_comparison_exp
  subset_id: String_comparison_exp
  subset_position: Int_comparison_exp
  sun_challenge: String_comparison_exp
  taboo_id: String_comparison_exp
  text: String_comparison_exp
  token_count: Int_comparison_exp
  token_id: String_comparison_exp
  traits: String_comparison_exp
  translations: rangers_card_text_bool_exp
  translations_aggregate: rangers_card_text_aggregate_bool_exp
  type_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.card"
"""
enum rangers_card_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  card_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rangers_card_delete_at_path_input {
  locations: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rangers_card_delete_elem_input {
  locations: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rangers_card_delete_key_input {
  locations: String
}

"""
input type for incrementing numeric columns in table "rangers.card"
"""
input rangers_card_inc_input {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  cost: Int
  deck_limit: Int
  equip: Int
  harm: Int
  level: Int
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  set_position: Int
  subset_position: Int
  token_count: Int
}

"""
input type for inserting data into table "rangers.card"
"""
input rangers_card_insert_input {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locations: jsonb
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int
  set_id: String
  set_position: Int
  spoiler: Boolean
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String
  translations: rangers_card_text_arr_rel_insert_input
  type_id: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.card_localized"
"""
type rangers_card_localized {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  area_name: String
  aspect_id: String
  aspect_name: String
  aspect_short_name: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locale: String
  locations(
    """JSON select path"""
    path: String
  ): jsonb
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int
  real_crest_challenge: String
  real_flavor: String
  real_imagesrc: String
  real_mountain_challenge: String
  real_name: String
  real_objective: String
  real_sun_challenge: String
  real_text: String
  real_traits: String
  set_id: String
  set_name: String
  set_position: Int
  set_size: Int
  set_type_id: String
  set_type_name: String
  spoiler: Boolean
  subset_id: String
  subset_name: String
  subset_pack_id: String
  subset_pack_name: String
  subset_position: Int
  subset_set_id: String
  subset_set_name: String
  subset_size: Int
  sun_challenge: String
  taboo_date: timestamptz
  taboo_id: String
  taboo_is_current: Boolean
  taboo_name: String
  text: String
  token_count: Int
  token_id: String
  token_name: String
  token_plurals: String
  traits: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.card_localized"
"""
type rangers_card_localized_aggregate {
  aggregate: rangers_card_localized_aggregate_fields
  nodes: [rangers_card_localized!]!
}

"""
aggregate fields of "rangers.card_localized"
"""
type rangers_card_localized_aggregate_fields {
  avg: rangers_card_localized_avg_fields
  count(columns: [rangers_card_localized_select_column!], distinct: Boolean): Int!
  max: rangers_card_localized_max_fields
  min: rangers_card_localized_min_fields
  stddev: rangers_card_localized_stddev_fields
  stddev_pop: rangers_card_localized_stddev_pop_fields
  stddev_samp: rangers_card_localized_stddev_samp_fields
  sum: rangers_card_localized_sum_fields
  var_pop: rangers_card_localized_var_pop_fields
  var_samp: rangers_card_localized_var_samp_fields
  variance: rangers_card_localized_variance_fields
}

"""aggregate avg on columns"""
type rangers_card_localized_avg_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""
Boolean expression to filter rows from the table "rangers.card_localized". All fields are combined with a logical 'AND'.
"""
input rangers_card_localized_bool_exp {
  _and: [rangers_card_localized_bool_exp!]
  _not: rangers_card_localized_bool_exp
  _or: [rangers_card_localized_bool_exp!]
  approach_conflict: Int_comparison_exp
  approach_connection: Int_comparison_exp
  approach_exploration: Int_comparison_exp
  approach_reason: Int_comparison_exp
  area_id: String_comparison_exp
  area_name: String_comparison_exp
  aspect_id: String_comparison_exp
  aspect_name: String_comparison_exp
  aspect_short_name: String_comparison_exp
  back_card_id: String_comparison_exp
  code: String_comparison_exp
  cost: Int_comparison_exp
  crest_challenge: String_comparison_exp
  deck_limit: Int_comparison_exp
  equip: Int_comparison_exp
  flavor: String_comparison_exp
  guide_entry: String_comparison_exp
  harm: Int_comparison_exp
  id: String_comparison_exp
  illustrator: String_comparison_exp
  imagesrc: String_comparison_exp
  level: Int_comparison_exp
  locale: String_comparison_exp
  locations: jsonb_comparison_exp
  mountain_challenge: String_comparison_exp
  name: String_comparison_exp
  objective: String_comparison_exp
  pack_id: String_comparison_exp
  pack_name: String_comparison_exp
  pack_position: Int_comparison_exp
  pack_short_name: String_comparison_exp
  position: Int_comparison_exp
  presence: Int_comparison_exp
  progress: Int_comparison_exp
  progress_fixed: Boolean_comparison_exp
  quantity: Int_comparison_exp
  real_crest_challenge: String_comparison_exp
  real_flavor: String_comparison_exp
  real_imagesrc: String_comparison_exp
  real_mountain_challenge: String_comparison_exp
  real_name: String_comparison_exp
  real_objective: String_comparison_exp
  real_sun_challenge: String_comparison_exp
  real_text: String_comparison_exp
  real_traits: String_comparison_exp
  set_id: String_comparison_exp
  set_name: String_comparison_exp
  set_position: Int_comparison_exp
  set_size: Int_comparison_exp
  set_type_id: String_comparison_exp
  set_type_name: String_comparison_exp
  spoiler: Boolean_comparison_exp
  subset_id: String_comparison_exp
  subset_name: String_comparison_exp
  subset_pack_id: String_comparison_exp
  subset_pack_name: String_comparison_exp
  subset_position: Int_comparison_exp
  subset_set_id: String_comparison_exp
  subset_set_name: String_comparison_exp
  subset_size: Int_comparison_exp
  sun_challenge: String_comparison_exp
  taboo_date: timestamptz_comparison_exp
  taboo_id: String_comparison_exp
  taboo_is_current: Boolean_comparison_exp
  taboo_name: String_comparison_exp
  text: String_comparison_exp
  token_count: Int_comparison_exp
  token_id: String_comparison_exp
  token_name: String_comparison_exp
  token_plurals: String_comparison_exp
  traits: String_comparison_exp
  type_id: String_comparison_exp
  type_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_card_localized_max_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  area_name: String
  aspect_id: String
  aspect_name: String
  aspect_short_name: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  real_crest_challenge: String
  real_flavor: String
  real_imagesrc: String
  real_mountain_challenge: String
  real_name: String
  real_objective: String
  real_sun_challenge: String
  real_text: String
  real_traits: String
  set_id: String
  set_name: String
  set_position: Int
  set_size: Int
  set_type_id: String
  set_type_name: String
  subset_id: String
  subset_name: String
  subset_pack_id: String
  subset_pack_name: String
  subset_position: Int
  subset_set_id: String
  subset_set_name: String
  subset_size: Int
  sun_challenge: String
  taboo_date: timestamptz
  taboo_id: String
  taboo_name: String
  text: String
  token_count: Int
  token_id: String
  token_name: String
  token_plurals: String
  traits: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_card_localized_min_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  area_name: String
  aspect_id: String
  aspect_name: String
  aspect_short_name: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  real_crest_challenge: String
  real_flavor: String
  real_imagesrc: String
  real_mountain_challenge: String
  real_name: String
  real_objective: String
  real_sun_challenge: String
  real_text: String
  real_traits: String
  set_id: String
  set_name: String
  set_position: Int
  set_size: Int
  set_type_id: String
  set_type_name: String
  subset_id: String
  subset_name: String
  subset_pack_id: String
  subset_pack_name: String
  subset_position: Int
  subset_set_id: String
  subset_set_name: String
  subset_size: Int
  sun_challenge: String
  taboo_date: timestamptz
  taboo_id: String
  taboo_name: String
  text: String
  token_count: Int
  token_id: String
  token_name: String
  token_plurals: String
  traits: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.card_localized"."""
input rangers_card_localized_order_by {
  approach_conflict: order_by
  approach_connection: order_by
  approach_exploration: order_by
  approach_reason: order_by
  area_id: order_by
  area_name: order_by
  aspect_id: order_by
  aspect_name: order_by
  aspect_short_name: order_by
  back_card_id: order_by
  code: order_by
  cost: order_by
  crest_challenge: order_by
  deck_limit: order_by
  equip: order_by
  flavor: order_by
  guide_entry: order_by
  harm: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  level: order_by
  locale: order_by
  locations: order_by
  mountain_challenge: order_by
  name: order_by
  objective: order_by
  pack_id: order_by
  pack_name: order_by
  pack_position: order_by
  pack_short_name: order_by
  position: order_by
  presence: order_by
  progress: order_by
  progress_fixed: order_by
  quantity: order_by
  real_crest_challenge: order_by
  real_flavor: order_by
  real_imagesrc: order_by
  real_mountain_challenge: order_by
  real_name: order_by
  real_objective: order_by
  real_sun_challenge: order_by
  real_text: order_by
  real_traits: order_by
  set_id: order_by
  set_name: order_by
  set_position: order_by
  set_size: order_by
  set_type_id: order_by
  set_type_name: order_by
  spoiler: order_by
  subset_id: order_by
  subset_name: order_by
  subset_pack_id: order_by
  subset_pack_name: order_by
  subset_position: order_by
  subset_set_id: order_by
  subset_set_name: order_by
  subset_size: order_by
  sun_challenge: order_by
  taboo_date: order_by
  taboo_id: order_by
  taboo_is_current: order_by
  taboo_name: order_by
  text: order_by
  token_count: order_by
  token_id: order_by
  token_name: order_by
  token_plurals: order_by
  traits: order_by
  type_id: order_by
  type_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.card_localized"
"""
enum rangers_card_localized_select_column {
  """column name"""
  approach_conflict

  """column name"""
  approach_connection

  """column name"""
  approach_exploration

  """column name"""
  approach_reason

  """column name"""
  area_id

  """column name"""
  area_name

  """column name"""
  aspect_id

  """column name"""
  aspect_name

  """column name"""
  aspect_short_name

  """column name"""
  back_card_id

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  crest_challenge

  """column name"""
  deck_limit

  """column name"""
  equip

  """column name"""
  flavor

  """column name"""
  guide_entry

  """column name"""
  harm

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  level

  """column name"""
  locale

  """column name"""
  locations

  """column name"""
  mountain_challenge

  """column name"""
  name

  """column name"""
  objective

  """column name"""
  pack_id

  """column name"""
  pack_name

  """column name"""
  pack_position

  """column name"""
  pack_short_name

  """column name"""
  position

  """column name"""
  presence

  """column name"""
  progress

  """column name"""
  progress_fixed

  """column name"""
  quantity

  """column name"""
  real_crest_challenge

  """column name"""
  real_flavor

  """column name"""
  real_imagesrc

  """column name"""
  real_mountain_challenge

  """column name"""
  real_name

  """column name"""
  real_objective

  """column name"""
  real_sun_challenge

  """column name"""
  real_text

  """column name"""
  real_traits

  """column name"""
  set_id

  """column name"""
  set_name

  """column name"""
  set_position

  """column name"""
  set_size

  """column name"""
  set_type_id

  """column name"""
  set_type_name

  """column name"""
  spoiler

  """column name"""
  subset_id

  """column name"""
  subset_name

  """column name"""
  subset_pack_id

  """column name"""
  subset_pack_name

  """column name"""
  subset_position

  """column name"""
  subset_set_id

  """column name"""
  subset_set_name

  """column name"""
  subset_size

  """column name"""
  sun_challenge

  """column name"""
  taboo_date

  """column name"""
  taboo_id

  """column name"""
  taboo_is_current

  """column name"""
  taboo_name

  """column name"""
  text

  """column name"""
  token_count

  """column name"""
  token_id

  """column name"""
  token_name

  """column name"""
  token_plurals

  """column name"""
  traits

  """column name"""
  type_id

  """column name"""
  type_name

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type rangers_card_localized_stddev_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""aggregate stddev_pop on columns"""
type rangers_card_localized_stddev_pop_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""aggregate stddev_samp on columns"""
type rangers_card_localized_stddev_samp_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""
Streaming cursor of the table "rangers_card_localized"
"""
input rangers_card_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_card_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_card_localized_stream_cursor_value_input {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  area_name: String
  aspect_id: String
  aspect_name: String
  aspect_short_name: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locale: String
  locations: jsonb
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int
  real_crest_challenge: String
  real_flavor: String
  real_imagesrc: String
  real_mountain_challenge: String
  real_name: String
  real_objective: String
  real_sun_challenge: String
  real_text: String
  real_traits: String
  set_id: String
  set_name: String
  set_position: Int
  set_size: Int
  set_type_id: String
  set_type_name: String
  spoiler: Boolean
  subset_id: String
  subset_name: String
  subset_pack_id: String
  subset_pack_name: String
  subset_position: Int
  subset_set_id: String
  subset_set_name: String
  subset_size: Int
  sun_challenge: String
  taboo_date: timestamptz
  taboo_id: String
  taboo_is_current: Boolean
  taboo_name: String
  text: String
  token_count: Int
  token_id: String
  token_name: String
  token_plurals: String
  traits: String
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_card_localized_sum_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  cost: Int
  deck_limit: Int
  equip: Int
  harm: Int
  level: Int
  pack_position: Int
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  set_position: Int
  set_size: Int
  subset_position: Int
  subset_size: Int
  token_count: Int
}

"""aggregate var_pop on columns"""
type rangers_card_localized_var_pop_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""aggregate var_samp on columns"""
type rangers_card_localized_var_samp_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""aggregate variance on columns"""
type rangers_card_localized_variance_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  pack_position: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  set_size: Float
  subset_position: Float
  subset_size: Float
  token_count: Float
}

"""aggregate max on columns"""
type rangers_card_max_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  set_id: String
  set_position: Int
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String
  type_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_card_min_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  set_id: String
  set_position: Int
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String
  type_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.card"
"""
type rangers_card_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_card!]!
}

"""
on_conflict condition type for table "rangers.card"
"""
input rangers_card_on_conflict {
  constraint: rangers_card_constraint!
  update_columns: [rangers_card_update_column!]! = []
  where: rangers_card_bool_exp
}

"""Ordering options when selecting data from "rangers.card"."""
input rangers_card_order_by {
  approach_conflict: order_by
  approach_connection: order_by
  approach_exploration: order_by
  approach_reason: order_by
  area_id: order_by
  aspect_id: order_by
  back_card_id: order_by
  code: order_by
  cost: order_by
  crest_challenge: order_by
  deck_limit: order_by
  equip: order_by
  flavor: order_by
  guide_entry: order_by
  harm: order_by
  id: order_by
  illustrator: order_by
  imagesrc: order_by
  level: order_by
  locations: order_by
  mountain_challenge: order_by
  name: order_by
  objective: order_by
  pack_id: order_by
  position: order_by
  presence: order_by
  progress: order_by
  progress_fixed: order_by
  quantity: order_by
  set_id: order_by
  set_position: order_by
  spoiler: order_by
  subset_id: order_by
  subset_position: order_by
  sun_challenge: order_by
  taboo_id: order_by
  text: order_by
  token_count: order_by
  token_id: order_by
  traits: order_by
  translations_aggregate: rangers_card_text_aggregate_order_by
  type_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.card"""
input rangers_card_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rangers_card_prepend_input {
  locations: jsonb
}

input rangers_card_search_args {
  _limit: Int
  _offset: Int
  aspect_in: _text
  level_eq: Int
  level_gt: Int
  level_lt: Int
  locale: String
  pack_in: _text
  search: String
  search_flavor: Boolean
  search_text: Boolean
  search_traits: Boolean
  set_in: _text
  type_in: _text
}

"""
select columns of table "rangers.card"
"""
enum rangers_card_select_column {
  """column name"""
  approach_conflict

  """column name"""
  approach_connection

  """column name"""
  approach_exploration

  """column name"""
  approach_reason

  """column name"""
  area_id

  """column name"""
  aspect_id

  """column name"""
  back_card_id

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  crest_challenge

  """column name"""
  deck_limit

  """column name"""
  equip

  """column name"""
  flavor

  """column name"""
  guide_entry

  """column name"""
  harm

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  level

  """column name"""
  locations

  """column name"""
  mountain_challenge

  """column name"""
  name

  """column name"""
  objective

  """column name"""
  pack_id

  """column name"""
  position

  """column name"""
  presence

  """column name"""
  progress

  """column name"""
  progress_fixed

  """column name"""
  quantity

  """column name"""
  set_id

  """column name"""
  set_position

  """column name"""
  spoiler

  """column name"""
  subset_id

  """column name"""
  subset_position

  """column name"""
  sun_challenge

  """column name"""
  taboo_id

  """column name"""
  text

  """column name"""
  token_count

  """column name"""
  token_id

  """column name"""
  traits

  """column name"""
  type_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.card"
"""
input rangers_card_set_input {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locations: jsonb
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int
  set_id: String
  set_position: Int
  spoiler: Boolean
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String
  type_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type rangers_card_stddev_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""aggregate stddev_pop on columns"""
type rangers_card_stddev_pop_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""aggregate stddev_samp on columns"""
type rangers_card_stddev_samp_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""
Streaming cursor of the table "rangers_card"
"""
input rangers_card_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_card_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_card_stream_cursor_value_input {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  area_id: String
  aspect_id: String
  back_card_id: String
  code: String
  cost: Int
  crest_challenge: String
  deck_limit: Int
  equip: Int
  flavor: String
  guide_entry: String
  harm: Int
  id: String
  illustrator: String
  imagesrc: String
  level: Int
  locations: jsonb
  mountain_challenge: String
  name: String
  objective: String
  pack_id: String
  position: Int
  presence: Int
  progress: Int
  progress_fixed: Boolean
  quantity: Int
  set_id: String
  set_position: Int
  spoiler: Boolean
  subset_id: String
  subset_position: Int
  sun_challenge: String
  taboo_id: String
  text: String
  token_count: Int
  token_id: String
  traits: String
  type_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_card_sum_fields {
  approach_conflict: Int
  approach_connection: Int
  approach_exploration: Int
  approach_reason: Int
  cost: Int
  deck_limit: Int
  equip: Int
  harm: Int
  level: Int
  position: Int
  presence: Int
  progress: Int
  quantity: Int
  set_position: Int
  subset_position: Int
  token_count: Int
}

"""
columns and relationships of "rangers.card_text"
"""
type rangers_card_text {
  crest_challenge: String
  flavor: String
  id: String!
  imagesrc: String
  locale: String!
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.card_text"
"""
type rangers_card_text_aggregate {
  aggregate: rangers_card_text_aggregate_fields
  nodes: [rangers_card_text!]!
}

input rangers_card_text_aggregate_bool_exp {
  count: rangers_card_text_aggregate_bool_exp_count
}

input rangers_card_text_aggregate_bool_exp_count {
  arguments: [rangers_card_text_select_column!]
  distinct: Boolean
  filter: rangers_card_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.card_text"
"""
type rangers_card_text_aggregate_fields {
  count(columns: [rangers_card_text_select_column!], distinct: Boolean): Int!
  max: rangers_card_text_max_fields
  min: rangers_card_text_min_fields
}

"""
order by aggregate values of table "rangers.card_text"
"""
input rangers_card_text_aggregate_order_by {
  count: order_by
  max: rangers_card_text_max_order_by
  min: rangers_card_text_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.card_text"
"""
input rangers_card_text_arr_rel_insert_input {
  data: [rangers_card_text_insert_input!]!

  """upsert condition"""
  on_conflict: rangers_card_text_on_conflict
}

"""
Boolean expression to filter rows from the table "rangers.card_text". All fields are combined with a logical 'AND'.
"""
input rangers_card_text_bool_exp {
  _and: [rangers_card_text_bool_exp!]
  _not: rangers_card_text_bool_exp
  _or: [rangers_card_text_bool_exp!]
  crest_challenge: String_comparison_exp
  flavor: String_comparison_exp
  id: String_comparison_exp
  imagesrc: String_comparison_exp
  locale: String_comparison_exp
  mountain_challenge: String_comparison_exp
  name: String_comparison_exp
  objective: String_comparison_exp
  sun_challenge: String_comparison_exp
  text: String_comparison_exp
  traits: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.card_text"
"""
enum rangers_card_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  card_text_pkey
}

"""
input type for inserting data into table "rangers.card_text"
"""
input rangers_card_text_insert_input {
  crest_challenge: String
  flavor: String
  id: String
  imagesrc: String
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_card_text_max_fields {
  crest_challenge: String
  flavor: String
  id: String
  imagesrc: String
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "rangers.card_text"
"""
input rangers_card_text_max_order_by {
  crest_challenge: order_by
  flavor: order_by
  id: order_by
  imagesrc: order_by
  locale: order_by
  mountain_challenge: order_by
  name: order_by
  objective: order_by
  sun_challenge: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type rangers_card_text_min_fields {
  crest_challenge: String
  flavor: String
  id: String
  imagesrc: String
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "rangers.card_text"
"""
input rangers_card_text_min_order_by {
  crest_challenge: order_by
  flavor: order_by
  id: order_by
  imagesrc: order_by
  locale: order_by
  mountain_challenge: order_by
  name: order_by
  objective: order_by
  sun_challenge: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "rangers.card_text"
"""
type rangers_card_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_card_text!]!
}

"""
on_conflict condition type for table "rangers.card_text"
"""
input rangers_card_text_on_conflict {
  constraint: rangers_card_text_constraint!
  update_columns: [rangers_card_text_update_column!]! = []
  where: rangers_card_text_bool_exp
}

"""Ordering options when selecting data from "rangers.card_text"."""
input rangers_card_text_order_by {
  crest_challenge: order_by
  flavor: order_by
  id: order_by
  imagesrc: order_by
  locale: order_by
  mountain_challenge: order_by
  name: order_by
  objective: order_by
  sun_challenge: order_by
  text: order_by
  traits: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.card_text"""
input rangers_card_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.card_text"
"""
enum rangers_card_text_select_column {
  """column name"""
  crest_challenge

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imagesrc

  """column name"""
  locale

  """column name"""
  mountain_challenge

  """column name"""
  name

  """column name"""
  objective

  """column name"""
  sun_challenge

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.card_text"
"""
input rangers_card_text_set_input {
  crest_challenge: String
  flavor: String
  id: String
  imagesrc: String
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_card_text"
"""
input rangers_card_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_card_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_card_text_stream_cursor_value_input {
  crest_challenge: String
  flavor: String
  id: String
  imagesrc: String
  locale: String
  mountain_challenge: String
  name: String
  objective: String
  sun_challenge: String
  text: String
  traits: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.card_text"
"""
enum rangers_card_text_update_column {
  """column name"""
  crest_challenge

  """column name"""
  flavor

  """column name"""
  id

  """column name"""
  imagesrc

  """column name"""
  locale

  """column name"""
  mountain_challenge

  """column name"""
  name

  """column name"""
  objective

  """column name"""
  sun_challenge

  """column name"""
  text

  """column name"""
  traits

  """column name"""
  updated_at
}

input rangers_card_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_card_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_card_text_bool_exp!
}

"""
update columns of table "rangers.card"
"""
enum rangers_card_update_column {
  """column name"""
  approach_conflict

  """column name"""
  approach_connection

  """column name"""
  approach_exploration

  """column name"""
  approach_reason

  """column name"""
  area_id

  """column name"""
  aspect_id

  """column name"""
  back_card_id

  """column name"""
  code

  """column name"""
  cost

  """column name"""
  crest_challenge

  """column name"""
  deck_limit

  """column name"""
  equip

  """column name"""
  flavor

  """column name"""
  guide_entry

  """column name"""
  harm

  """column name"""
  id

  """column name"""
  illustrator

  """column name"""
  imagesrc

  """column name"""
  level

  """column name"""
  locations

  """column name"""
  mountain_challenge

  """column name"""
  name

  """column name"""
  objective

  """column name"""
  pack_id

  """column name"""
  position

  """column name"""
  presence

  """column name"""
  progress

  """column name"""
  progress_fixed

  """column name"""
  quantity

  """column name"""
  set_id

  """column name"""
  set_position

  """column name"""
  spoiler

  """column name"""
  subset_id

  """column name"""
  subset_position

  """column name"""
  sun_challenge

  """column name"""
  taboo_id

  """column name"""
  text

  """column name"""
  token_count

  """column name"""
  token_id

  """column name"""
  traits

  """column name"""
  type_id

  """column name"""
  updated_at
}

"""
columns and relationships of "rangers.card_updated"
"""
type rangers_card_updated {
  locale: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.card_updated"
"""
type rangers_card_updated_aggregate {
  aggregate: rangers_card_updated_aggregate_fields
  nodes: [rangers_card_updated!]!
}

"""
aggregate fields of "rangers.card_updated"
"""
type rangers_card_updated_aggregate_fields {
  count(columns: [rangers_card_updated_select_column!], distinct: Boolean): Int!
  max: rangers_card_updated_max_fields
  min: rangers_card_updated_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.card_updated". All fields are combined with a logical 'AND'.
"""
input rangers_card_updated_bool_exp {
  _and: [rangers_card_updated_bool_exp!]
  _not: rangers_card_updated_bool_exp
  _or: [rangers_card_updated_bool_exp!]
  locale: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_card_updated_max_fields {
  locale: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_card_updated_min_fields {
  locale: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.card_updated"."""
input rangers_card_updated_order_by {
  locale: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.card_updated"
"""
enum rangers_card_updated_select_column {
  """column name"""
  locale

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "rangers_card_updated"
"""
input rangers_card_updated_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_card_updated_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_card_updated_stream_cursor_value_input {
  locale: String
  updated_at: timestamptz
}

input rangers_card_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rangers_card_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rangers_card_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rangers_card_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rangers_card_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_card_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rangers_card_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_card_set_input

  """filter the rows which have to be updated"""
  where: rangers_card_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_card_var_pop_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""aggregate var_samp on columns"""
type rangers_card_var_samp_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""aggregate variance on columns"""
type rangers_card_variance_fields {
  approach_conflict: Float
  approach_connection: Float
  approach_exploration: Float
  approach_reason: Float
  cost: Float
  deck_limit: Float
  equip: Float
  harm: Float
  level: Float
  position: Float
  presence: Float
  progress: Float
  quantity: Float
  set_position: Float
  subset_position: Float
  token_count: Float
}

"""
columns and relationships of "rangers.comment"
"""
type rangers_comment {
  comment_id: uuid
  created_at: timestamptz!

  """An object relationship"""
  deck: rangers_deck
  deck_id: Int
  id: uuid!

  """An object relationship"""
  parent: rangers_comment
  response_count: Int!

  """An array relationship"""
  responses(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): [rangers_comment!]!

  """An aggregate relationship"""
  responses_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): rangers_comment_aggregate!
  text: String
  updated_at: timestamptz!

  """An object relationship"""
  user: rangers_users!
  user_id: String!
}

"""
aggregated selection of "rangers.comment"
"""
type rangers_comment_aggregate {
  aggregate: rangers_comment_aggregate_fields
  nodes: [rangers_comment!]!
}

input rangers_comment_aggregate_bool_exp {
  count: rangers_comment_aggregate_bool_exp_count
}

input rangers_comment_aggregate_bool_exp_count {
  arguments: [rangers_comment_select_column!]
  distinct: Boolean
  filter: rangers_comment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.comment"
"""
type rangers_comment_aggregate_fields {
  avg: rangers_comment_avg_fields
  count(columns: [rangers_comment_select_column!], distinct: Boolean): Int!
  max: rangers_comment_max_fields
  min: rangers_comment_min_fields
  stddev: rangers_comment_stddev_fields
  stddev_pop: rangers_comment_stddev_pop_fields
  stddev_samp: rangers_comment_stddev_samp_fields
  sum: rangers_comment_sum_fields
  var_pop: rangers_comment_var_pop_fields
  var_samp: rangers_comment_var_samp_fields
  variance: rangers_comment_variance_fields
}

"""
order by aggregate values of table "rangers.comment"
"""
input rangers_comment_aggregate_order_by {
  avg: rangers_comment_avg_order_by
  count: order_by
  max: rangers_comment_max_order_by
  min: rangers_comment_min_order_by
  stddev: rangers_comment_stddev_order_by
  stddev_pop: rangers_comment_stddev_pop_order_by
  stddev_samp: rangers_comment_stddev_samp_order_by
  sum: rangers_comment_sum_order_by
  var_pop: rangers_comment_var_pop_order_by
  var_samp: rangers_comment_var_samp_order_by
  variance: rangers_comment_variance_order_by
}

"""
input type for inserting array relation for remote table "rangers.comment"
"""
input rangers_comment_arr_rel_insert_input {
  data: [rangers_comment_insert_input!]!

  """upsert condition"""
  on_conflict: rangers_comment_on_conflict
}

"""aggregate avg on columns"""
type rangers_comment_avg_fields {
  deck_id: Float
  response_count: Float
}

"""
order by avg() on columns of table "rangers.comment"
"""
input rangers_comment_avg_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
Boolean expression to filter rows from the table "rangers.comment". All fields are combined with a logical 'AND'.
"""
input rangers_comment_bool_exp {
  _and: [rangers_comment_bool_exp!]
  _not: rangers_comment_bool_exp
  _or: [rangers_comment_bool_exp!]
  comment_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deck: rangers_deck_bool_exp
  deck_id: Int_comparison_exp
  id: uuid_comparison_exp
  parent: rangers_comment_bool_exp
  response_count: Int_comparison_exp
  responses: rangers_comment_bool_exp
  responses_aggregate: rangers_comment_aggregate_bool_exp
  text: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.comment"
"""
enum rangers_comment_constraint {
  """
  unique or primary key constraint on columns "id", "deck_id"
  """
  comment_id_deck_id_key

  """
  unique or primary key constraint on columns "id"
  """
  comment_pkey
}

"""
input type for incrementing numeric columns in table "rangers.comment"
"""
input rangers_comment_inc_input {
  deck_id: Int
  response_count: Int
}

"""
input type for inserting data into table "rangers.comment"
"""
input rangers_comment_insert_input {
  comment_id: uuid
  created_at: timestamptz
  deck: rangers_deck_obj_rel_insert_input
  deck_id: Int
  id: uuid
  parent: rangers_comment_obj_rel_insert_input
  response_count: Int
  responses: rangers_comment_arr_rel_insert_input
  text: String
  updated_at: timestamptz
  user: rangers_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type rangers_comment_max_fields {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "rangers.comment"
"""
input rangers_comment_max_order_by {
  comment_id: order_by
  created_at: order_by
  deck_id: order_by
  id: order_by
  response_count: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type rangers_comment_min_fields {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "rangers.comment"
"""
input rangers_comment_min_order_by {
  comment_id: order_by
  created_at: order_by
  deck_id: order_by
  id: order_by
  response_count: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "rangers.comment"
"""
type rangers_comment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_comment!]!
}

"""
input type for inserting object relation for remote table "rangers.comment"
"""
input rangers_comment_obj_rel_insert_input {
  data: rangers_comment_insert_input!

  """upsert condition"""
  on_conflict: rangers_comment_on_conflict
}

"""
on_conflict condition type for table "rangers.comment"
"""
input rangers_comment_on_conflict {
  constraint: rangers_comment_constraint!
  update_columns: [rangers_comment_update_column!]! = []
  where: rangers_comment_bool_exp
}

"""Ordering options when selecting data from "rangers.comment"."""
input rangers_comment_order_by {
  comment_id: order_by
  created_at: order_by
  deck: rangers_deck_order_by
  deck_id: order_by
  id: order_by
  parent: rangers_comment_order_by
  response_count: order_by
  responses_aggregate: rangers_comment_aggregate_order_by
  text: order_by
  updated_at: order_by
  user: rangers_users_order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.comment"""
input rangers_comment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rangers.comment"
"""
enum rangers_comment_select_column {
  """column name"""
  comment_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  id

  """column name"""
  response_count

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.comment"
"""
input rangers_comment_set_input {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_comment_stddev_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev() on columns of table "rangers.comment"
"""
input rangers_comment_stddev_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate stddev_pop on columns"""
type rangers_comment_stddev_pop_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev_pop() on columns of table "rangers.comment"
"""
input rangers_comment_stddev_pop_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate stddev_samp on columns"""
type rangers_comment_stddev_samp_fields {
  deck_id: Float
  response_count: Float
}

"""
order by stddev_samp() on columns of table "rangers.comment"
"""
input rangers_comment_stddev_samp_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
Streaming cursor of the table "rangers_comment"
"""
input rangers_comment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_comment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_comment_stream_cursor_value_input {
  comment_id: uuid
  created_at: timestamptz
  deck_id: Int
  id: uuid
  response_count: Int
  text: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type rangers_comment_sum_fields {
  deck_id: Int
  response_count: Int
}

"""
order by sum() on columns of table "rangers.comment"
"""
input rangers_comment_sum_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
update columns of table "rangers.comment"
"""
enum rangers_comment_update_column {
  """column name"""
  comment_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  id

  """column name"""
  response_count

  """column name"""
  text

  """column name"""
  updated_at

  """column name"""
  user_id
}

input rangers_comment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_comment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_comment_set_input

  """filter the rows which have to be updated"""
  where: rangers_comment_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_comment_var_pop_fields {
  deck_id: Float
  response_count: Float
}

"""
order by var_pop() on columns of table "rangers.comment"
"""
input rangers_comment_var_pop_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate var_samp on columns"""
type rangers_comment_var_samp_fields {
  deck_id: Float
  response_count: Float
}

"""
order by var_samp() on columns of table "rangers.comment"
"""
input rangers_comment_var_samp_order_by {
  deck_id: order_by
  response_count: order_by
}

"""aggregate variance on columns"""
type rangers_comment_variance_fields {
  deck_id: Float
  response_count: Float
}

"""
order by variance() on columns of table "rangers.comment"
"""
input rangers_comment_variance_order_by {
  deck_id: order_by
  response_count: order_by
}

"""
columns and relationships of "rangers.deck"
"""
type rangers_deck {
  awa: Int!

  """An object relationship"""
  base_deck: rangers_deck
  base_deck_id: Int

  """An object relationship"""
  campaign: rangers_campaign
  campaign_id: Int
  comment_count: Int!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): [rangers_comment!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): rangers_comment_aggregate!
  copy_count: Int!
  created_at: timestamptz
  description: String
  extra_slots(
    """JSON select path"""
    path: String
  ): jsonb!
  fit: Int!
  foc: Int!
  id: Int!
  like_count: Int

  """
  A computed field, executes function "rangers.deck_liked_by_user"
  """
  liked_by_user: Boolean

  """An object relationship"""
  likes: rangers_deck_like_count
  meta(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!

  """An object relationship"""
  next_deck: rangers_deck
  next_deck_id: Int

  """An object relationship"""
  original_deck: rangers_deck_copy

  """An object relationship"""
  previous_deck: rangers_deck
  published: Boolean

  """An object relationship"""
  rank: rangers_deck_rank
  side_slots(
    """JSON select path"""
    path: String
  ): jsonb!
  slots(
    """JSON select path"""
    path: String
  ): jsonb!
  spi: Int!
  taboo_set_id: String
  tags(
    """JSON select path"""
    path: String
  ): jsonb!
  updated_at: timestamptz
  upgrade(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  user: rangers_users!
  user_id: String!
  version: Int!
}

"""
aggregated selection of "rangers.deck"
"""
type rangers_deck_aggregate {
  aggregate: rangers_deck_aggregate_fields
  nodes: [rangers_deck!]!
}

"""
aggregate fields of "rangers.deck"
"""
type rangers_deck_aggregate_fields {
  avg: rangers_deck_avg_fields
  count(columns: [rangers_deck_select_column!], distinct: Boolean): Int!
  max: rangers_deck_max_fields
  min: rangers_deck_min_fields
  stddev: rangers_deck_stddev_fields
  stddev_pop: rangers_deck_stddev_pop_fields
  stddev_samp: rangers_deck_stddev_samp_fields
  sum: rangers_deck_sum_fields
  var_pop: rangers_deck_var_pop_fields
  var_samp: rangers_deck_var_samp_fields
  variance: rangers_deck_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rangers_deck_append_input {
  extra_slots: jsonb
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  upgrade: jsonb
}

"""aggregate avg on columns"""
type rangers_deck_avg_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "rangers.deck". All fields are combined with a logical 'AND'.
"""
input rangers_deck_bool_exp {
  _and: [rangers_deck_bool_exp!]
  _not: rangers_deck_bool_exp
  _or: [rangers_deck_bool_exp!]
  awa: Int_comparison_exp
  base_deck: rangers_deck_bool_exp
  base_deck_id: Int_comparison_exp
  campaign: rangers_campaign_bool_exp
  campaign_id: Int_comparison_exp
  comment_count: Int_comparison_exp
  comments: rangers_comment_bool_exp
  comments_aggregate: rangers_comment_aggregate_bool_exp
  copy_count: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  extra_slots: jsonb_comparison_exp
  fit: Int_comparison_exp
  foc: Int_comparison_exp
  id: Int_comparison_exp
  like_count: Int_comparison_exp
  liked_by_user: Boolean_comparison_exp
  likes: rangers_deck_like_count_bool_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  next_deck: rangers_deck_bool_exp
  next_deck_id: Int_comparison_exp
  original_deck: rangers_deck_copy_bool_exp
  previous_deck: rangers_deck_bool_exp
  published: Boolean_comparison_exp
  rank: rangers_deck_rank_bool_exp
  side_slots: jsonb_comparison_exp
  slots: jsonb_comparison_exp
  spi: Int_comparison_exp
  taboo_set_id: String_comparison_exp
  tags: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  upgrade: jsonb_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "rangers.deck"
"""
enum rangers_deck_constraint {
  """
  unique or primary key constraint on columns "next_deck_id"
  """
  deck_next_deck_id_key

  """
  unique or primary key constraint on columns "id"
  """
  deck_pkey
}

"""
columns and relationships of "rangers.deck_copy"
"""
type rangers_deck_copy {
  copy_deck_id: Int!
  created_at: timestamptz!

  """An object relationship"""
  deck: rangers_deck!

  """An object relationship"""
  deck_copy: rangers_deck!
  deck_id: Int!
  updated_at: timestamptz!

  """An object relationship"""
  user: rangers_users!
  user_id: String!
}

"""
aggregated selection of "rangers.deck_copy"
"""
type rangers_deck_copy_aggregate {
  aggregate: rangers_deck_copy_aggregate_fields
  nodes: [rangers_deck_copy!]!
}

"""
aggregate fields of "rangers.deck_copy"
"""
type rangers_deck_copy_aggregate_fields {
  avg: rangers_deck_copy_avg_fields
  count(columns: [rangers_deck_copy_select_column!], distinct: Boolean): Int!
  max: rangers_deck_copy_max_fields
  min: rangers_deck_copy_min_fields
  stddev: rangers_deck_copy_stddev_fields
  stddev_pop: rangers_deck_copy_stddev_pop_fields
  stddev_samp: rangers_deck_copy_stddev_samp_fields
  sum: rangers_deck_copy_sum_fields
  var_pop: rangers_deck_copy_var_pop_fields
  var_samp: rangers_deck_copy_var_samp_fields
  variance: rangers_deck_copy_variance_fields
}

"""aggregate avg on columns"""
type rangers_deck_copy_avg_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
Boolean expression to filter rows from the table "rangers.deck_copy". All fields are combined with a logical 'AND'.
"""
input rangers_deck_copy_bool_exp {
  _and: [rangers_deck_copy_bool_exp!]
  _not: rangers_deck_copy_bool_exp
  _or: [rangers_deck_copy_bool_exp!]
  copy_deck_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deck: rangers_deck_bool_exp
  deck_copy: rangers_deck_bool_exp
  deck_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.deck_copy"
"""
enum rangers_deck_copy_constraint {
  """
  unique or primary key constraint on columns "copy_deck_id"
  """
  deck_copy_copy_deck_id_key

  """
  unique or primary key constraint on columns "copy_deck_id"
  """
  deck_copy_pkey
}

"""
input type for incrementing numeric columns in table "rangers.deck_copy"
"""
input rangers_deck_copy_inc_input {
  copy_deck_id: Int
  deck_id: Int
}

"""
input type for inserting data into table "rangers.deck_copy"
"""
input rangers_deck_copy_insert_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck: rangers_deck_obj_rel_insert_input
  deck_copy: rangers_deck_obj_rel_insert_input
  deck_id: Int
  updated_at: timestamptz
  user: rangers_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type rangers_deck_copy_max_fields {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type rangers_deck_copy_min_fields {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""
response of any mutation on the table "rangers.deck_copy"
"""
type rangers_deck_copy_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_deck_copy!]!
}

"""
input type for inserting object relation for remote table "rangers.deck_copy"
"""
input rangers_deck_copy_obj_rel_insert_input {
  data: rangers_deck_copy_insert_input!

  """upsert condition"""
  on_conflict: rangers_deck_copy_on_conflict
}

"""
on_conflict condition type for table "rangers.deck_copy"
"""
input rangers_deck_copy_on_conflict {
  constraint: rangers_deck_copy_constraint!
  update_columns: [rangers_deck_copy_update_column!]! = []
  where: rangers_deck_copy_bool_exp
}

"""Ordering options when selecting data from "rangers.deck_copy"."""
input rangers_deck_copy_order_by {
  copy_deck_id: order_by
  created_at: order_by
  deck: rangers_deck_order_by
  deck_copy: rangers_deck_order_by
  deck_id: order_by
  updated_at: order_by
  user: rangers_users_order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.deck_copy"""
input rangers_deck_copy_pk_columns_input {
  copy_deck_id: Int!
}

"""
select columns of table "rangers.deck_copy"
"""
enum rangers_deck_copy_select_column {
  """column name"""
  copy_deck_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.deck_copy"
"""
input rangers_deck_copy_set_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_deck_copy_stddev_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate stddev_pop on columns"""
type rangers_deck_copy_stddev_pop_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate stddev_samp on columns"""
type rangers_deck_copy_stddev_samp_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
Streaming cursor of the table "rangers_deck_copy"
"""
input rangers_deck_copy_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_deck_copy_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_deck_copy_stream_cursor_value_input {
  copy_deck_id: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type rangers_deck_copy_sum_fields {
  copy_deck_id: Int
  deck_id: Int
}

"""
update columns of table "rangers.deck_copy"
"""
enum rangers_deck_copy_update_column {
  """column name"""
  copy_deck_id

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input rangers_deck_copy_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_deck_copy_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_deck_copy_set_input

  """filter the rows which have to be updated"""
  where: rangers_deck_copy_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_deck_copy_var_pop_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate var_samp on columns"""
type rangers_deck_copy_var_samp_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""aggregate variance on columns"""
type rangers_deck_copy_variance_fields {
  copy_deck_id: Float
  deck_id: Float
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rangers_deck_delete_at_path_input {
  extra_slots: [String!]
  meta: [String!]
  side_slots: [String!]
  slots: [String!]
  tags: [String!]
  upgrade: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rangers_deck_delete_elem_input {
  extra_slots: Int
  meta: Int
  side_slots: Int
  slots: Int
  tags: Int
  upgrade: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rangers_deck_delete_key_input {
  extra_slots: String
  meta: String
  side_slots: String
  slots: String
  tags: String
  upgrade: String
}

"""
input type for incrementing numeric columns in table "rangers.deck"
"""
input rangers_deck_inc_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  next_deck_id: Int
  spi: Int
  version: Int
}

"""
input type for inserting data into table "rangers.deck"
"""
input rangers_deck_insert_input {
  awa: Int
  base_deck: rangers_deck_obj_rel_insert_input
  base_deck_id: Int
  campaign: rangers_campaign_obj_rel_insert_input
  campaign_id: Int
  comment_count: Int
  comments: rangers_comment_arr_rel_insert_input
  copy_count: Int
  created_at: timestamptz
  description: String
  extra_slots: jsonb
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  likes: rangers_deck_like_count_obj_rel_insert_input
  meta: jsonb
  name: String
  next_deck: rangers_deck_obj_rel_insert_input
  next_deck_id: Int
  original_deck: rangers_deck_copy_obj_rel_insert_input
  previous_deck: rangers_deck_obj_rel_insert_input
  published: Boolean
  rank: rangers_deck_rank_obj_rel_insert_input
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user: rangers_users_obj_rel_insert_input
  user_id: String
  version: Int
}

"""
columns and relationships of "rangers.deck_like"
"""
type rangers_deck_like {
  created_at: timestamptz!

  """An object relationship"""
  deck: rangers_deck!
  deck_id: Int!
  liked: Boolean!
  user_id: String!
}

"""
aggregated selection of "rangers.deck_like"
"""
type rangers_deck_like_aggregate {
  aggregate: rangers_deck_like_aggregate_fields
  nodes: [rangers_deck_like!]!
}

"""
aggregate fields of "rangers.deck_like"
"""
type rangers_deck_like_aggregate_fields {
  avg: rangers_deck_like_avg_fields
  count(columns: [rangers_deck_like_select_column!], distinct: Boolean): Int!
  max: rangers_deck_like_max_fields
  min: rangers_deck_like_min_fields
  stddev: rangers_deck_like_stddev_fields
  stddev_pop: rangers_deck_like_stddev_pop_fields
  stddev_samp: rangers_deck_like_stddev_samp_fields
  sum: rangers_deck_like_sum_fields
  var_pop: rangers_deck_like_var_pop_fields
  var_samp: rangers_deck_like_var_samp_fields
  variance: rangers_deck_like_variance_fields
}

"""aggregate avg on columns"""
type rangers_deck_like_avg_fields {
  deck_id: Float
}

"""
Boolean expression to filter rows from the table "rangers.deck_like". All fields are combined with a logical 'AND'.
"""
input rangers_deck_like_bool_exp {
  _and: [rangers_deck_like_bool_exp!]
  _not: rangers_deck_like_bool_exp
  _or: [rangers_deck_like_bool_exp!]
  created_at: timestamptz_comparison_exp
  deck: rangers_deck_bool_exp
  deck_id: Int_comparison_exp
  liked: Boolean_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.deck_like"
"""
enum rangers_deck_like_constraint {
  """
  unique or primary key constraint on columns "user_id", "deck_id"
  """
  deck_likes_pkey
}

"""
columns and relationships of "rangers.deck_like_count"
"""
type rangers_deck_like_count {
  count: Int!
  created_at: timestamptz!
  deck_id: Int!
  updated_at: timestamptz!
}

"""
aggregated selection of "rangers.deck_like_count"
"""
type rangers_deck_like_count_aggregate {
  aggregate: rangers_deck_like_count_aggregate_fields
  nodes: [rangers_deck_like_count!]!
}

"""
aggregate fields of "rangers.deck_like_count"
"""
type rangers_deck_like_count_aggregate_fields {
  avg: rangers_deck_like_count_avg_fields
  count(columns: [rangers_deck_like_count_select_column!], distinct: Boolean): Int!
  max: rangers_deck_like_count_max_fields
  min: rangers_deck_like_count_min_fields
  stddev: rangers_deck_like_count_stddev_fields
  stddev_pop: rangers_deck_like_count_stddev_pop_fields
  stddev_samp: rangers_deck_like_count_stddev_samp_fields
  sum: rangers_deck_like_count_sum_fields
  var_pop: rangers_deck_like_count_var_pop_fields
  var_samp: rangers_deck_like_count_var_samp_fields
  variance: rangers_deck_like_count_variance_fields
}

"""aggregate avg on columns"""
type rangers_deck_like_count_avg_fields {
  count: Float
  deck_id: Float
}

"""
Boolean expression to filter rows from the table "rangers.deck_like_count". All fields are combined with a logical 'AND'.
"""
input rangers_deck_like_count_bool_exp {
  _and: [rangers_deck_like_count_bool_exp!]
  _not: rangers_deck_like_count_bool_exp
  _or: [rangers_deck_like_count_bool_exp!]
  count: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  deck_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.deck_like_count"
"""
enum rangers_deck_like_count_constraint {
  """
  unique or primary key constraint on columns "deck_id"
  """
  deck_like_count_pkey
}

"""
input type for incrementing numeric columns in table "rangers.deck_like_count"
"""
input rangers_deck_like_count_inc_input {
  count: Int
  deck_id: Int
}

"""
input type for inserting data into table "rangers.deck_like_count"
"""
input rangers_deck_like_count_insert_input {
  count: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_deck_like_count_max_fields {
  count: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_deck_like_count_min_fields {
  count: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.deck_like_count"
"""
type rangers_deck_like_count_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_deck_like_count!]!
}

"""
input type for inserting object relation for remote table "rangers.deck_like_count"
"""
input rangers_deck_like_count_obj_rel_insert_input {
  data: rangers_deck_like_count_insert_input!

  """upsert condition"""
  on_conflict: rangers_deck_like_count_on_conflict
}

"""
on_conflict condition type for table "rangers.deck_like_count"
"""
input rangers_deck_like_count_on_conflict {
  constraint: rangers_deck_like_count_constraint!
  update_columns: [rangers_deck_like_count_update_column!]! = []
  where: rangers_deck_like_count_bool_exp
}

"""Ordering options when selecting data from "rangers.deck_like_count"."""
input rangers_deck_like_count_order_by {
  count: order_by
  created_at: order_by
  deck_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.deck_like_count"""
input rangers_deck_like_count_pk_columns_input {
  deck_id: Int!
}

"""
select columns of table "rangers.deck_like_count"
"""
enum rangers_deck_like_count_select_column {
  """column name"""
  count

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.deck_like_count"
"""
input rangers_deck_like_count_set_input {
  count: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type rangers_deck_like_count_stddev_fields {
  count: Float
  deck_id: Float
}

"""aggregate stddev_pop on columns"""
type rangers_deck_like_count_stddev_pop_fields {
  count: Float
  deck_id: Float
}

"""aggregate stddev_samp on columns"""
type rangers_deck_like_count_stddev_samp_fields {
  count: Float
  deck_id: Float
}

"""
Streaming cursor of the table "rangers_deck_like_count"
"""
input rangers_deck_like_count_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_deck_like_count_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_deck_like_count_stream_cursor_value_input {
  count: Int
  created_at: timestamptz
  deck_id: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_deck_like_count_sum_fields {
  count: Int
  deck_id: Int
}

"""
update columns of table "rangers.deck_like_count"
"""
enum rangers_deck_like_count_update_column {
  """column name"""
  count

  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  updated_at
}

input rangers_deck_like_count_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_deck_like_count_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_deck_like_count_set_input

  """filter the rows which have to be updated"""
  where: rangers_deck_like_count_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_deck_like_count_var_pop_fields {
  count: Float
  deck_id: Float
}

"""aggregate var_samp on columns"""
type rangers_deck_like_count_var_samp_fields {
  count: Float
  deck_id: Float
}

"""aggregate variance on columns"""
type rangers_deck_like_count_variance_fields {
  count: Float
  deck_id: Float
}

"""
input type for incrementing numeric columns in table "rangers.deck_like"
"""
input rangers_deck_like_inc_input {
  deck_id: Int
}

"""
input type for inserting data into table "rangers.deck_like"
"""
input rangers_deck_like_insert_input {
  created_at: timestamptz
  deck: rangers_deck_obj_rel_insert_input
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate max on columns"""
type rangers_deck_like_max_fields {
  created_at: timestamptz
  deck_id: Int
  user_id: String
}

"""aggregate min on columns"""
type rangers_deck_like_min_fields {
  created_at: timestamptz
  deck_id: Int
  user_id: String
}

"""
response of any mutation on the table "rangers.deck_like"
"""
type rangers_deck_like_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_deck_like!]!
}

"""
on_conflict condition type for table "rangers.deck_like"
"""
input rangers_deck_like_on_conflict {
  constraint: rangers_deck_like_constraint!
  update_columns: [rangers_deck_like_update_column!]! = []
  where: rangers_deck_like_bool_exp
}

"""Ordering options when selecting data from "rangers.deck_like"."""
input rangers_deck_like_order_by {
  created_at: order_by
  deck: rangers_deck_order_by
  deck_id: order_by
  liked: order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.deck_like"""
input rangers_deck_like_pk_columns_input {
  deck_id: Int!
  user_id: String!
}

"""
select columns of table "rangers.deck_like"
"""
enum rangers_deck_like_select_column {
  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  liked

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.deck_like"
"""
input rangers_deck_like_set_input {
  created_at: timestamptz
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_deck_like_stddev_fields {
  deck_id: Float
}

"""aggregate stddev_pop on columns"""
type rangers_deck_like_stddev_pop_fields {
  deck_id: Float
}

"""aggregate stddev_samp on columns"""
type rangers_deck_like_stddev_samp_fields {
  deck_id: Float
}

"""
Streaming cursor of the table "rangers_deck_like"
"""
input rangers_deck_like_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_deck_like_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_deck_like_stream_cursor_value_input {
  created_at: timestamptz
  deck_id: Int
  liked: Boolean
  user_id: String
}

"""aggregate sum on columns"""
type rangers_deck_like_sum_fields {
  deck_id: Int
}

"""
update columns of table "rangers.deck_like"
"""
enum rangers_deck_like_update_column {
  """column name"""
  created_at

  """column name"""
  deck_id

  """column name"""
  liked

  """column name"""
  user_id
}

input rangers_deck_like_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_deck_like_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_deck_like_set_input

  """filter the rows which have to be updated"""
  where: rangers_deck_like_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_deck_like_var_pop_fields {
  deck_id: Float
}

"""aggregate var_samp on columns"""
type rangers_deck_like_var_samp_fields {
  deck_id: Float
}

"""aggregate variance on columns"""
type rangers_deck_like_variance_fields {
  deck_id: Float
}

"""aggregate max on columns"""
type rangers_deck_max_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  name: String
  next_deck_id: Int
  spi: Int
  taboo_set_id: String
  updated_at: timestamptz
  user_id: String
  version: Int
}

"""aggregate min on columns"""
type rangers_deck_min_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  name: String
  next_deck_id: Int
  spi: Int
  taboo_set_id: String
  updated_at: timestamptz
  user_id: String
  version: Int
}

"""
response of any mutation on the table "rangers.deck"
"""
type rangers_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_deck!]!
}

"""
input type for inserting object relation for remote table "rangers.deck"
"""
input rangers_deck_obj_rel_insert_input {
  data: rangers_deck_insert_input!

  """upsert condition"""
  on_conflict: rangers_deck_on_conflict
}

"""
on_conflict condition type for table "rangers.deck"
"""
input rangers_deck_on_conflict {
  constraint: rangers_deck_constraint!
  update_columns: [rangers_deck_update_column!]! = []
  where: rangers_deck_bool_exp
}

"""Ordering options when selecting data from "rangers.deck"."""
input rangers_deck_order_by {
  awa: order_by
  base_deck: rangers_deck_order_by
  base_deck_id: order_by
  campaign: rangers_campaign_order_by
  campaign_id: order_by
  comment_count: order_by
  comments_aggregate: rangers_comment_aggregate_order_by
  copy_count: order_by
  created_at: order_by
  description: order_by
  extra_slots: order_by
  fit: order_by
  foc: order_by
  id: order_by
  like_count: order_by
  liked_by_user: order_by
  likes: rangers_deck_like_count_order_by
  meta: order_by
  name: order_by
  next_deck: rangers_deck_order_by
  next_deck_id: order_by
  original_deck: rangers_deck_copy_order_by
  previous_deck: rangers_deck_order_by
  published: order_by
  rank: rangers_deck_rank_order_by
  side_slots: order_by
  slots: order_by
  spi: order_by
  taboo_set_id: order_by
  tags: order_by
  updated_at: order_by
  upgrade: order_by
  user: rangers_users_order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: rangers.deck"""
input rangers_deck_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rangers_deck_prepend_input {
  extra_slots: jsonb
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  upgrade: jsonb
}

"""
columns and relationships of "rangers.deck_rank"
"""
type rangers_deck_rank {
  id: Int
  like_count: bigint
  score: float8
}

"""
aggregated selection of "rangers.deck_rank"
"""
type rangers_deck_rank_aggregate {
  aggregate: rangers_deck_rank_aggregate_fields
  nodes: [rangers_deck_rank!]!
}

"""
aggregate fields of "rangers.deck_rank"
"""
type rangers_deck_rank_aggregate_fields {
  avg: rangers_deck_rank_avg_fields
  count(columns: [rangers_deck_rank_select_column!], distinct: Boolean): Int!
  max: rangers_deck_rank_max_fields
  min: rangers_deck_rank_min_fields
  stddev: rangers_deck_rank_stddev_fields
  stddev_pop: rangers_deck_rank_stddev_pop_fields
  stddev_samp: rangers_deck_rank_stddev_samp_fields
  sum: rangers_deck_rank_sum_fields
  var_pop: rangers_deck_rank_var_pop_fields
  var_samp: rangers_deck_rank_var_samp_fields
  variance: rangers_deck_rank_variance_fields
}

"""aggregate avg on columns"""
type rangers_deck_rank_avg_fields {
  id: Float
  like_count: Float
  score: Float
}

"""
Boolean expression to filter rows from the table "rangers.deck_rank". All fields are combined with a logical 'AND'.
"""
input rangers_deck_rank_bool_exp {
  _and: [rangers_deck_rank_bool_exp!]
  _not: rangers_deck_rank_bool_exp
  _or: [rangers_deck_rank_bool_exp!]
  id: Int_comparison_exp
  like_count: bigint_comparison_exp
  score: float8_comparison_exp
}

"""
input type for inserting data into table "rangers.deck_rank"
"""
input rangers_deck_rank_insert_input {
  id: Int
  like_count: bigint
  score: float8
}

"""aggregate max on columns"""
type rangers_deck_rank_max_fields {
  id: Int
  like_count: bigint
  score: float8
}

"""aggregate min on columns"""
type rangers_deck_rank_min_fields {
  id: Int
  like_count: bigint
  score: float8
}

"""
input type for inserting object relation for remote table "rangers.deck_rank"
"""
input rangers_deck_rank_obj_rel_insert_input {
  data: rangers_deck_rank_insert_input!
}

"""Ordering options when selecting data from "rangers.deck_rank"."""
input rangers_deck_rank_order_by {
  id: order_by
  like_count: order_by
  score: order_by
}

"""
select columns of table "rangers.deck_rank"
"""
enum rangers_deck_rank_select_column {
  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  score
}

"""aggregate stddev on columns"""
type rangers_deck_rank_stddev_fields {
  id: Float
  like_count: Float
  score: Float
}

"""aggregate stddev_pop on columns"""
type rangers_deck_rank_stddev_pop_fields {
  id: Float
  like_count: Float
  score: Float
}

"""aggregate stddev_samp on columns"""
type rangers_deck_rank_stddev_samp_fields {
  id: Float
  like_count: Float
  score: Float
}

"""
Streaming cursor of the table "rangers_deck_rank"
"""
input rangers_deck_rank_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_deck_rank_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_deck_rank_stream_cursor_value_input {
  id: Int
  like_count: bigint
  score: float8
}

"""aggregate sum on columns"""
type rangers_deck_rank_sum_fields {
  id: Int
  like_count: bigint
  score: float8
}

"""aggregate var_pop on columns"""
type rangers_deck_rank_var_pop_fields {
  id: Float
  like_count: Float
  score: Float
}

"""aggregate var_samp on columns"""
type rangers_deck_rank_var_samp_fields {
  id: Float
  like_count: Float
  score: Float
}

"""aggregate variance on columns"""
type rangers_deck_rank_variance_fields {
  id: Float
  like_count: Float
  score: Float
}

input rangers_deck_search_args {
  _limit: Int
  _offset: Int
  _taboo_set_id: _text
  awa_eq: Int
  background: _text
  fit_eq: Int
  foc_eq: Int
  role: _text
  specialty: _text
  spi_eq: Int
  user_id_eq: String
}

"""
select columns of table "rangers.deck"
"""
enum rangers_deck_select_column {
  """column name"""
  awa

  """column name"""
  base_deck_id

  """column name"""
  campaign_id

  """column name"""
  comment_count

  """column name"""
  copy_count

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  extra_slots

  """column name"""
  fit

  """column name"""
  foc

  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  next_deck_id

  """column name"""
  published

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  spi

  """column name"""
  taboo_set_id

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  upgrade

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "rangers.deck"
"""
input rangers_deck_set_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  extra_slots: jsonb
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  next_deck_id: Int
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user_id: String
  version: Int
}

"""aggregate stddev on columns"""
type rangers_deck_stddev_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type rangers_deck_stddev_pop_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type rangers_deck_stddev_samp_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
Streaming cursor of the table "rangers_deck"
"""
input rangers_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_deck_stream_cursor_value_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  extra_slots: jsonb
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  next_deck_id: Int
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user_id: String
  version: Int
}

"""aggregate sum on columns"""
type rangers_deck_sum_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  next_deck_id: Int
  spi: Int
  version: Int
}

"""
update columns of table "rangers.deck"
"""
enum rangers_deck_update_column {
  """column name"""
  awa

  """column name"""
  base_deck_id

  """column name"""
  campaign_id

  """column name"""
  comment_count

  """column name"""
  copy_count

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  extra_slots

  """column name"""
  fit

  """column name"""
  foc

  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  next_deck_id

  """column name"""
  published

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  spi

  """column name"""
  taboo_set_id

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  upgrade

  """column name"""
  user_id

  """column name"""
  version
}

input rangers_deck_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rangers_deck_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rangers_deck_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rangers_deck_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rangers_deck_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_deck_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rangers_deck_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_deck_set_input

  """filter the rows which have to be updated"""
  where: rangers_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_deck_var_pop_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate var_samp on columns"""
type rangers_deck_var_samp_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate variance on columns"""
type rangers_deck_variance_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
columns and relationships of "rangers.faq_entry"
"""
type rangers_faq_entry {
  card_id: String!
  created_at: timestamptz!
  id: String!
  lang: String!
  text: String!
}

"""
aggregated selection of "rangers.faq_entry"
"""
type rangers_faq_entry_aggregate {
  aggregate: rangers_faq_entry_aggregate_fields
  nodes: [rangers_faq_entry!]!
}

"""
aggregate fields of "rangers.faq_entry"
"""
type rangers_faq_entry_aggregate_fields {
  count(columns: [rangers_faq_entry_select_column!], distinct: Boolean): Int!
  max: rangers_faq_entry_max_fields
  min: rangers_faq_entry_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.faq_entry". All fields are combined with a logical 'AND'.
"""
input rangers_faq_entry_bool_exp {
  _and: [rangers_faq_entry_bool_exp!]
  _not: rangers_faq_entry_bool_exp
  _or: [rangers_faq_entry_bool_exp!]
  card_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  lang: String_comparison_exp
  text: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.faq_entry"
"""
enum rangers_faq_entry_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  faq_entry_pkey
}

"""
input type for inserting data into table "rangers.faq_entry"
"""
input rangers_faq_entry_insert_input {
  card_id: String
  created_at: timestamptz
  id: String
  lang: String
  text: String
}

"""aggregate max on columns"""
type rangers_faq_entry_max_fields {
  card_id: String
  created_at: timestamptz
  id: String
  lang: String
  text: String
}

"""aggregate min on columns"""
type rangers_faq_entry_min_fields {
  card_id: String
  created_at: timestamptz
  id: String
  lang: String
  text: String
}

"""
response of any mutation on the table "rangers.faq_entry"
"""
type rangers_faq_entry_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_faq_entry!]!
}

"""
on_conflict condition type for table "rangers.faq_entry"
"""
input rangers_faq_entry_on_conflict {
  constraint: rangers_faq_entry_constraint!
  update_columns: [rangers_faq_entry_update_column!]! = []
  where: rangers_faq_entry_bool_exp
}

"""Ordering options when selecting data from "rangers.faq_entry"."""
input rangers_faq_entry_order_by {
  card_id: order_by
  created_at: order_by
  id: order_by
  lang: order_by
  text: order_by
}

"""primary key columns input for table: rangers.faq_entry"""
input rangers_faq_entry_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.faq_entry"
"""
enum rangers_faq_entry_select_column {
  """column name"""
  card_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  lang

  """column name"""
  text
}

"""
input type for updating data in table "rangers.faq_entry"
"""
input rangers_faq_entry_set_input {
  card_id: String
  created_at: timestamptz
  id: String
  lang: String
  text: String
}

"""
Streaming cursor of the table "rangers_faq_entry"
"""
input rangers_faq_entry_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_faq_entry_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_faq_entry_stream_cursor_value_input {
  card_id: String
  created_at: timestamptz
  id: String
  lang: String
  text: String
}

"""
update columns of table "rangers.faq_entry"
"""
enum rangers_faq_entry_update_column {
  """column name"""
  card_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  lang

  """column name"""
  text
}

input rangers_faq_entry_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_faq_entry_set_input

  """filter the rows which have to be updated"""
  where: rangers_faq_entry_bool_exp!
}

"""
columns and relationships of "rangers.friend_status"
"""
type rangers_friend_status {
  status: rangers_friend_status_type_enum!
  user_id_a: String!
  user_id_b: String!
}

"""
aggregated selection of "rangers.friend_status"
"""
type rangers_friend_status_aggregate {
  aggregate: rangers_friend_status_aggregate_fields
  nodes: [rangers_friend_status!]!
}

"""
aggregate fields of "rangers.friend_status"
"""
type rangers_friend_status_aggregate_fields {
  count(columns: [rangers_friend_status_select_column!], distinct: Boolean): Int!
  max: rangers_friend_status_max_fields
  min: rangers_friend_status_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.friend_status". All fields are combined with a logical 'AND'.
"""
input rangers_friend_status_bool_exp {
  _and: [rangers_friend_status_bool_exp!]
  _not: rangers_friend_status_bool_exp
  _or: [rangers_friend_status_bool_exp!]
  status: rangers_friend_status_type_enum_comparison_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.friend_status"
"""
enum rangers_friend_status_constraint {
  """
  unique or primary key constraint on columns "user_id_b", "user_id_a"
  """
  friend_status_pkey
}

"""
input type for inserting data into table "rangers.friend_status"
"""
input rangers_friend_status_insert_input {
  status: rangers_friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type rangers_friend_status_max_fields {
  user_id_a: String
  user_id_b: String
}

"""aggregate min on columns"""
type rangers_friend_status_min_fields {
  user_id_a: String
  user_id_b: String
}

"""
response of any mutation on the table "rangers.friend_status"
"""
type rangers_friend_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_friend_status!]!
}

"""
on_conflict condition type for table "rangers.friend_status"
"""
input rangers_friend_status_on_conflict {
  constraint: rangers_friend_status_constraint!
  update_columns: [rangers_friend_status_update_column!]! = []
  where: rangers_friend_status_bool_exp
}

"""Ordering options when selecting data from "rangers.friend_status"."""
input rangers_friend_status_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""primary key columns input for table: rangers.friend_status"""
input rangers_friend_status_pk_columns_input {
  user_id_a: String!
  user_id_b: String!
}

"""
select columns of table "rangers.friend_status"
"""
enum rangers_friend_status_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "rangers.friend_status"
"""
input rangers_friend_status_set_input {
  status: rangers_friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "rangers_friend_status"
"""
input rangers_friend_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_friend_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_friend_status_stream_cursor_value_input {
  status: rangers_friend_status_type_enum
  user_id_a: String
  user_id_b: String
}

"""
columns and relationships of "rangers.friend_status_type"
"""
type rangers_friend_status_type {
  value: String!
}

"""
aggregated selection of "rangers.friend_status_type"
"""
type rangers_friend_status_type_aggregate {
  aggregate: rangers_friend_status_type_aggregate_fields
  nodes: [rangers_friend_status_type!]!
}

"""
aggregate fields of "rangers.friend_status_type"
"""
type rangers_friend_status_type_aggregate_fields {
  count(columns: [rangers_friend_status_type_select_column!], distinct: Boolean): Int!
  max: rangers_friend_status_type_max_fields
  min: rangers_friend_status_type_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.friend_status_type". All fields are combined with a logical 'AND'.
"""
input rangers_friend_status_type_bool_exp {
  _and: [rangers_friend_status_type_bool_exp!]
  _not: rangers_friend_status_type_bool_exp
  _or: [rangers_friend_status_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.friend_status_type"
"""
enum rangers_friend_status_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  friend_status_type_pkey
}

enum rangers_friend_status_type_enum {
  friend
  none
  received
  sent
}

"""
Boolean expression to compare columns of type "rangers_friend_status_type_enum". All fields are combined with logical 'AND'.
"""
input rangers_friend_status_type_enum_comparison_exp {
  _eq: rangers_friend_status_type_enum
  _in: [rangers_friend_status_type_enum!]
  _is_null: Boolean
  _neq: rangers_friend_status_type_enum
  _nin: [rangers_friend_status_type_enum!]
}

"""
input type for inserting data into table "rangers.friend_status_type"
"""
input rangers_friend_status_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type rangers_friend_status_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type rangers_friend_status_type_min_fields {
  value: String
}

"""
response of any mutation on the table "rangers.friend_status_type"
"""
type rangers_friend_status_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_friend_status_type!]!
}

"""
on_conflict condition type for table "rangers.friend_status_type"
"""
input rangers_friend_status_type_on_conflict {
  constraint: rangers_friend_status_type_constraint!
  update_columns: [rangers_friend_status_type_update_column!]! = []
  where: rangers_friend_status_type_bool_exp
}

"""
Ordering options when selecting data from "rangers.friend_status_type".
"""
input rangers_friend_status_type_order_by {
  value: order_by
}

"""primary key columns input for table: rangers.friend_status_type"""
input rangers_friend_status_type_pk_columns_input {
  value: String!
}

"""
select columns of table "rangers.friend_status_type"
"""
enum rangers_friend_status_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "rangers.friend_status_type"
"""
input rangers_friend_status_type_set_input {
  value: String
}

"""
Streaming cursor of the table "rangers_friend_status_type"
"""
input rangers_friend_status_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_friend_status_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_friend_status_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "rangers.friend_status_type"
"""
enum rangers_friend_status_type_update_column {
  """column name"""
  value
}

input rangers_friend_status_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_friend_status_type_set_input

  """filter the rows which have to be updated"""
  where: rangers_friend_status_type_bool_exp!
}

"""
update columns of table "rangers.friend_status"
"""
enum rangers_friend_status_update_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

input rangers_friend_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_friend_status_set_input

  """filter the rows which have to be updated"""
  where: rangers_friend_status_bool_exp!
}

"""
columns and relationships of "rangers.latest_deck"
"""
type rangers_latest_deck {
  """An object relationship"""
  campaign: rangers_campaign
  campaign_id: Int

  """An object relationship"""
  deck: rangers_deck
  deck_id: Int

  """An object relationship"""
  user: rangers_users
  user_id: String
}

"""
aggregated selection of "rangers.latest_deck"
"""
type rangers_latest_deck_aggregate {
  aggregate: rangers_latest_deck_aggregate_fields
  nodes: [rangers_latest_deck!]!
}

input rangers_latest_deck_aggregate_bool_exp {
  count: rangers_latest_deck_aggregate_bool_exp_count
}

input rangers_latest_deck_aggregate_bool_exp_count {
  arguments: [rangers_latest_deck_select_column!]
  distinct: Boolean
  filter: rangers_latest_deck_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.latest_deck"
"""
type rangers_latest_deck_aggregate_fields {
  avg: rangers_latest_deck_avg_fields
  count(columns: [rangers_latest_deck_select_column!], distinct: Boolean): Int!
  max: rangers_latest_deck_max_fields
  min: rangers_latest_deck_min_fields
  stddev: rangers_latest_deck_stddev_fields
  stddev_pop: rangers_latest_deck_stddev_pop_fields
  stddev_samp: rangers_latest_deck_stddev_samp_fields
  sum: rangers_latest_deck_sum_fields
  var_pop: rangers_latest_deck_var_pop_fields
  var_samp: rangers_latest_deck_var_samp_fields
  variance: rangers_latest_deck_variance_fields
}

"""
order by aggregate values of table "rangers.latest_deck"
"""
input rangers_latest_deck_aggregate_order_by {
  avg: rangers_latest_deck_avg_order_by
  count: order_by
  max: rangers_latest_deck_max_order_by
  min: rangers_latest_deck_min_order_by
  stddev: rangers_latest_deck_stddev_order_by
  stddev_pop: rangers_latest_deck_stddev_pop_order_by
  stddev_samp: rangers_latest_deck_stddev_samp_order_by
  sum: rangers_latest_deck_sum_order_by
  var_pop: rangers_latest_deck_var_pop_order_by
  var_samp: rangers_latest_deck_var_samp_order_by
  variance: rangers_latest_deck_variance_order_by
}

"""
input type for inserting array relation for remote table "rangers.latest_deck"
"""
input rangers_latest_deck_arr_rel_insert_input {
  data: [rangers_latest_deck_insert_input!]!
}

"""aggregate avg on columns"""
type rangers_latest_deck_avg_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by avg() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_avg_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""
Boolean expression to filter rows from the table "rangers.latest_deck". All fields are combined with a logical 'AND'.
"""
input rangers_latest_deck_bool_exp {
  _and: [rangers_latest_deck_bool_exp!]
  _not: rangers_latest_deck_bool_exp
  _or: [rangers_latest_deck_bool_exp!]
  campaign: rangers_campaign_bool_exp
  campaign_id: Int_comparison_exp
  deck: rangers_deck_bool_exp
  deck_id: Int_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "rangers.latest_deck"
"""
input rangers_latest_deck_inc_input {
  campaign_id: Int
  deck_id: Int
}

"""
input type for inserting data into table "rangers.latest_deck"
"""
input rangers_latest_deck_insert_input {
  campaign: rangers_campaign_obj_rel_insert_input
  campaign_id: Int
  deck: rangers_deck_obj_rel_insert_input
  deck_id: Int
  user: rangers_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type rangers_latest_deck_max_fields {
  campaign_id: Int
  deck_id: Int
  user_id: String
}

"""
order by max() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_max_order_by {
  campaign_id: order_by
  deck_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type rangers_latest_deck_min_fields {
  campaign_id: Int
  deck_id: Int
  user_id: String
}

"""
order by min() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_min_order_by {
  campaign_id: order_by
  deck_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "rangers.latest_deck"
"""
type rangers_latest_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_latest_deck!]!
}

"""Ordering options when selecting data from "rangers.latest_deck"."""
input rangers_latest_deck_order_by {
  campaign: rangers_campaign_order_by
  campaign_id: order_by
  deck: rangers_deck_order_by
  deck_id: order_by
  user: rangers_users_order_by
  user_id: order_by
}

"""
select columns of table "rangers.latest_deck"
"""
enum rangers_latest_deck_select_column {
  """column name"""
  campaign_id

  """column name"""
  deck_id

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.latest_deck"
"""
input rangers_latest_deck_set_input {
  campaign_id: Int
  deck_id: Int
  user_id: String
}

"""aggregate stddev on columns"""
type rangers_latest_deck_stddev_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by stddev() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_stddev_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""aggregate stddev_pop on columns"""
type rangers_latest_deck_stddev_pop_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by stddev_pop() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_stddev_pop_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""aggregate stddev_samp on columns"""
type rangers_latest_deck_stddev_samp_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by stddev_samp() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_stddev_samp_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""
Streaming cursor of the table "rangers_latest_deck"
"""
input rangers_latest_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_latest_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_latest_deck_stream_cursor_value_input {
  campaign_id: Int
  deck_id: Int
  user_id: String
}

"""aggregate sum on columns"""
type rangers_latest_deck_sum_fields {
  campaign_id: Int
  deck_id: Int
}

"""
order by sum() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_sum_order_by {
  campaign_id: order_by
  deck_id: order_by
}

input rangers_latest_deck_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_latest_deck_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_latest_deck_set_input

  """filter the rows which have to be updated"""
  where: rangers_latest_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_latest_deck_var_pop_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by var_pop() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_var_pop_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""aggregate var_samp on columns"""
type rangers_latest_deck_var_samp_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by var_samp() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_var_samp_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""aggregate variance on columns"""
type rangers_latest_deck_variance_fields {
  campaign_id: Float
  deck_id: Float
}

"""
order by variance() on columns of table "rangers.latest_deck"
"""
input rangers_latest_deck_variance_order_by {
  campaign_id: order_by
  deck_id: order_by
}

"""
columns and relationships of "rangers.locale"
"""
type rangers_locale {
  locale: String!
}

"""
aggregated selection of "rangers.locale"
"""
type rangers_locale_aggregate {
  aggregate: rangers_locale_aggregate_fields
  nodes: [rangers_locale!]!
}

"""
aggregate fields of "rangers.locale"
"""
type rangers_locale_aggregate_fields {
  count(columns: [rangers_locale_select_column!], distinct: Boolean): Int!
  max: rangers_locale_max_fields
  min: rangers_locale_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.locale". All fields are combined with a logical 'AND'.
"""
input rangers_locale_bool_exp {
  _and: [rangers_locale_bool_exp!]
  _not: rangers_locale_bool_exp
  _or: [rangers_locale_bool_exp!]
  locale: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.locale"
"""
enum rangers_locale_constraint {
  """
  unique or primary key constraint on columns "locale"
  """
  locale_pkey
}

"""
input type for inserting data into table "rangers.locale"
"""
input rangers_locale_insert_input {
  locale: String
}

"""aggregate max on columns"""
type rangers_locale_max_fields {
  locale: String
}

"""aggregate min on columns"""
type rangers_locale_min_fields {
  locale: String
}

"""
response of any mutation on the table "rangers.locale"
"""
type rangers_locale_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_locale!]!
}

"""
on_conflict condition type for table "rangers.locale"
"""
input rangers_locale_on_conflict {
  constraint: rangers_locale_constraint!
  update_columns: [rangers_locale_update_column!]! = []
  where: rangers_locale_bool_exp
}

"""Ordering options when selecting data from "rangers.locale"."""
input rangers_locale_order_by {
  locale: order_by
}

"""primary key columns input for table: rangers.locale"""
input rangers_locale_pk_columns_input {
  locale: String!
}

"""
select columns of table "rangers.locale"
"""
enum rangers_locale_select_column {
  """column name"""
  locale
}

"""
input type for updating data in table "rangers.locale"
"""
input rangers_locale_set_input {
  locale: String
}

"""
Streaming cursor of the table "rangers_locale"
"""
input rangers_locale_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_locale_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_locale_stream_cursor_value_input {
  locale: String
}

"""
update columns of table "rangers.locale"
"""
enum rangers_locale_update_column {
  """column name"""
  locale
}

input rangers_locale_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_locale_set_input

  """filter the rows which have to be updated"""
  where: rangers_locale_bool_exp!
}

"""
columns and relationships of "rangers.pack"
"""
type rangers_pack {
  id: String!
  name: String!
  position: Int
  short_name: String

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): [rangers_pack_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): rangers_pack_text_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.pack"
"""
type rangers_pack_aggregate {
  aggregate: rangers_pack_aggregate_fields
  nodes: [rangers_pack!]!
}

"""
aggregate fields of "rangers.pack"
"""
type rangers_pack_aggregate_fields {
  avg: rangers_pack_avg_fields
  count(columns: [rangers_pack_select_column!], distinct: Boolean): Int!
  max: rangers_pack_max_fields
  min: rangers_pack_min_fields
  stddev: rangers_pack_stddev_fields
  stddev_pop: rangers_pack_stddev_pop_fields
  stddev_samp: rangers_pack_stddev_samp_fields
  sum: rangers_pack_sum_fields
  var_pop: rangers_pack_var_pop_fields
  var_samp: rangers_pack_var_samp_fields
  variance: rangers_pack_variance_fields
}

"""aggregate avg on columns"""
type rangers_pack_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "rangers.pack". All fields are combined with a logical 'AND'.
"""
input rangers_pack_bool_exp {
  _and: [rangers_pack_bool_exp!]
  _not: rangers_pack_bool_exp
  _or: [rangers_pack_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  position: Int_comparison_exp
  short_name: String_comparison_exp
  translations: rangers_pack_text_bool_exp
  translations_aggregate: rangers_pack_text_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.pack"
"""
enum rangers_pack_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  pack_pkey
}

"""
input type for incrementing numeric columns in table "rangers.pack"
"""
input rangers_pack_inc_input {
  position: Int
}

"""
input type for inserting data into table "rangers.pack"
"""
input rangers_pack_insert_input {
  id: String
  name: String
  position: Int
  short_name: String
  translations: rangers_pack_text_arr_rel_insert_input
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.pack_localized"
"""
type rangers_pack_localized {
  id: String
  locale: String
  name: String
  position: Int
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.pack_localized"
"""
type rangers_pack_localized_aggregate {
  aggregate: rangers_pack_localized_aggregate_fields
  nodes: [rangers_pack_localized!]!
}

"""
aggregate fields of "rangers.pack_localized"
"""
type rangers_pack_localized_aggregate_fields {
  avg: rangers_pack_localized_avg_fields
  count(columns: [rangers_pack_localized_select_column!], distinct: Boolean): Int!
  max: rangers_pack_localized_max_fields
  min: rangers_pack_localized_min_fields
  stddev: rangers_pack_localized_stddev_fields
  stddev_pop: rangers_pack_localized_stddev_pop_fields
  stddev_samp: rangers_pack_localized_stddev_samp_fields
  sum: rangers_pack_localized_sum_fields
  var_pop: rangers_pack_localized_var_pop_fields
  var_samp: rangers_pack_localized_var_samp_fields
  variance: rangers_pack_localized_variance_fields
}

"""aggregate avg on columns"""
type rangers_pack_localized_avg_fields {
  position: Float
}

"""
Boolean expression to filter rows from the table "rangers.pack_localized". All fields are combined with a logical 'AND'.
"""
input rangers_pack_localized_bool_exp {
  _and: [rangers_pack_localized_bool_exp!]
  _not: rangers_pack_localized_bool_exp
  _or: [rangers_pack_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  position: Int_comparison_exp
  real_name: String_comparison_exp
  real_short_name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_pack_localized_max_fields {
  id: String
  locale: String
  name: String
  position: Int
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_pack_localized_min_fields {
  id: String
  locale: String
  name: String
  position: Int
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.pack_localized"."""
input rangers_pack_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  position: order_by
  real_name: order_by
  real_short_name: order_by
  short_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.pack_localized"
"""
enum rangers_pack_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  position

  """column name"""
  real_name

  """column name"""
  real_short_name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type rangers_pack_localized_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type rangers_pack_localized_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type rangers_pack_localized_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "rangers_pack_localized"
"""
input rangers_pack_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_pack_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_pack_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  position: Int
  real_name: String
  real_short_name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_pack_localized_sum_fields {
  position: Int
}

"""aggregate var_pop on columns"""
type rangers_pack_localized_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type rangers_pack_localized_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type rangers_pack_localized_variance_fields {
  position: Float
}

"""aggregate max on columns"""
type rangers_pack_max_fields {
  id: String
  name: String
  position: Int
  short_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_pack_min_fields {
  id: String
  name: String
  position: Int
  short_name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.pack"
"""
type rangers_pack_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_pack!]!
}

"""
on_conflict condition type for table "rangers.pack"
"""
input rangers_pack_on_conflict {
  constraint: rangers_pack_constraint!
  update_columns: [rangers_pack_update_column!]! = []
  where: rangers_pack_bool_exp
}

"""Ordering options when selecting data from "rangers.pack"."""
input rangers_pack_order_by {
  id: order_by
  name: order_by
  position: order_by
  short_name: order_by
  translations_aggregate: rangers_pack_text_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.pack"""
input rangers_pack_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.pack"
"""
enum rangers_pack_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.pack"
"""
input rangers_pack_set_input {
  id: String
  name: String
  position: Int
  short_name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type rangers_pack_stddev_fields {
  position: Float
}

"""aggregate stddev_pop on columns"""
type rangers_pack_stddev_pop_fields {
  position: Float
}

"""aggregate stddev_samp on columns"""
type rangers_pack_stddev_samp_fields {
  position: Float
}

"""
Streaming cursor of the table "rangers_pack"
"""
input rangers_pack_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_pack_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_pack_stream_cursor_value_input {
  id: String
  name: String
  position: Int
  short_name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_pack_sum_fields {
  position: Int
}

"""
columns and relationships of "rangers.pack_text"
"""
type rangers_pack_text {
  id: String!
  locale: String!
  name: String!
  short_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.pack_text"
"""
type rangers_pack_text_aggregate {
  aggregate: rangers_pack_text_aggregate_fields
  nodes: [rangers_pack_text!]!
}

input rangers_pack_text_aggregate_bool_exp {
  count: rangers_pack_text_aggregate_bool_exp_count
}

input rangers_pack_text_aggregate_bool_exp_count {
  arguments: [rangers_pack_text_select_column!]
  distinct: Boolean
  filter: rangers_pack_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.pack_text"
"""
type rangers_pack_text_aggregate_fields {
  count(columns: [rangers_pack_text_select_column!], distinct: Boolean): Int!
  max: rangers_pack_text_max_fields
  min: rangers_pack_text_min_fields
}

"""
order by aggregate values of table "rangers.pack_text"
"""
input rangers_pack_text_aggregate_order_by {
  count: order_by
  max: rangers_pack_text_max_order_by
  min: rangers_pack_text_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.pack_text"
"""
input rangers_pack_text_arr_rel_insert_input {
  data: [rangers_pack_text_insert_input!]!

  """upsert condition"""
  on_conflict: rangers_pack_text_on_conflict
}

"""
Boolean expression to filter rows from the table "rangers.pack_text". All fields are combined with a logical 'AND'.
"""
input rangers_pack_text_bool_exp {
  _and: [rangers_pack_text_bool_exp!]
  _not: rangers_pack_text_bool_exp
  _or: [rangers_pack_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  short_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.pack_text"
"""
enum rangers_pack_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  pack_text_pkey
}

"""
input type for inserting data into table "rangers.pack_text"
"""
input rangers_pack_text_insert_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_pack_text_max_fields {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "rangers.pack_text"
"""
input rangers_pack_text_max_order_by {
  id: order_by
  locale: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type rangers_pack_text_min_fields {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "rangers.pack_text"
"""
input rangers_pack_text_min_order_by {
  id: order_by
  locale: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "rangers.pack_text"
"""
type rangers_pack_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_pack_text!]!
}

"""
on_conflict condition type for table "rangers.pack_text"
"""
input rangers_pack_text_on_conflict {
  constraint: rangers_pack_text_constraint!
  update_columns: [rangers_pack_text_update_column!]! = []
  where: rangers_pack_text_bool_exp
}

"""Ordering options when selecting data from "rangers.pack_text"."""
input rangers_pack_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  short_name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.pack_text"""
input rangers_pack_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.pack_text"
"""
enum rangers_pack_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.pack_text"
"""
input rangers_pack_text_set_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_pack_text"
"""
input rangers_pack_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_pack_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_pack_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  short_name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.pack_text"
"""
enum rangers_pack_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  short_name

  """column name"""
  updated_at
}

input rangers_pack_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_pack_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_pack_text_bool_exp!
}

"""
update columns of table "rangers.pack"
"""
enum rangers_pack_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  position

  """column name"""
  short_name

  """column name"""
  updated_at
}

input rangers_pack_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_pack_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_pack_set_input

  """filter the rows which have to be updated"""
  where: rangers_pack_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_pack_var_pop_fields {
  position: Float
}

"""aggregate var_samp on columns"""
type rangers_pack_var_samp_fields {
  position: Float
}

"""aggregate variance on columns"""
type rangers_pack_variance_fields {
  position: Float
}

input rangers_publish_deck_args {
  deck_id: Int
}

input rangers_remove_campaign_deck_args {
  deck_id: Int
  old_campaign_id: Int
}

input rangers_search_all_decks_args {
  _limit: Int
  _offset: Int
  _taboo_set_id: _text
  awa_eq: Int
  background: _text
  fit_eq: Int
  foc_eq: Int
  role: _text
  specialty: _text
  spi_eq: Int
  user_id_eq: String
}

"""
columns and relationships of "rangers.search_deck"
"""
type rangers_search_deck {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int

  """
  A computed field, executes function "rangers.search_deck_liked_by_user"
  """
  liked_by_user: Boolean

  """An object relationship"""
  likes: rangers_deck_like_count
  meta(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  next_deck_id: Int
  published: Boolean

  """An object relationship"""
  rank: rangers_deck_rank
  side_slots(
    """JSON select path"""
    path: String
  ): jsonb
  slots(
    """JSON select path"""
    path: String
  ): jsonb
  spi: Int
  taboo_set_id: String
  tags(
    """JSON select path"""
    path: String
  ): jsonb
  updated_at: timestamptz
  upgrade(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  user: rangers_users
  user_id: String
  version: Int
}

type rangers_search_deck_aggregate {
  aggregate: rangers_search_deck_aggregate_fields
  nodes: [rangers_search_deck!]!
}

"""
aggregate fields of "rangers.search_deck"
"""
type rangers_search_deck_aggregate_fields {
  avg: rangers_search_deck_avg_fields
  count(columns: [rangers_search_deck_select_column!], distinct: Boolean): Int!
  max: rangers_search_deck_max_fields
  min: rangers_search_deck_min_fields
  stddev: rangers_search_deck_stddev_fields
  stddev_pop: rangers_search_deck_stddev_pop_fields
  stddev_samp: rangers_search_deck_stddev_samp_fields
  sum: rangers_search_deck_sum_fields
  var_pop: rangers_search_deck_var_pop_fields
  var_samp: rangers_search_deck_var_samp_fields
  variance: rangers_search_deck_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rangers_search_deck_append_input {
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  upgrade: jsonb
}

"""aggregate avg on columns"""
type rangers_search_deck_avg_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "rangers.search_deck". All fields are combined with a logical 'AND'.
"""
input rangers_search_deck_bool_exp {
  _and: [rangers_search_deck_bool_exp!]
  _not: rangers_search_deck_bool_exp
  _or: [rangers_search_deck_bool_exp!]
  awa: Int_comparison_exp
  base_deck_id: Int_comparison_exp
  campaign_id: Int_comparison_exp
  comment_count: Int_comparison_exp
  copy_count: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  fit: Int_comparison_exp
  foc: Int_comparison_exp
  id: Int_comparison_exp
  like_count: Int_comparison_exp
  liked_by_user: Boolean_comparison_exp
  likes: rangers_deck_like_count_bool_exp
  meta: jsonb_comparison_exp
  name: String_comparison_exp
  next_deck_id: Int_comparison_exp
  published: Boolean_comparison_exp
  rank: rangers_deck_rank_bool_exp
  side_slots: jsonb_comparison_exp
  slots: jsonb_comparison_exp
  spi: Int_comparison_exp
  taboo_set_id: String_comparison_exp
  tags: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  upgrade: jsonb_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
  version: Int_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rangers_search_deck_delete_at_path_input {
  meta: [String!]
  side_slots: [String!]
  slots: [String!]
  tags: [String!]
  upgrade: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rangers_search_deck_delete_elem_input {
  meta: Int
  side_slots: Int
  slots: Int
  tags: Int
  upgrade: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rangers_search_deck_delete_key_input {
  meta: String
  side_slots: String
  slots: String
  tags: String
  upgrade: String
}

"""
input type for incrementing numeric columns in table "rangers.search_deck"
"""
input rangers_search_deck_inc_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  next_deck_id: Int
  spi: Int
  version: Int
}

"""
input type for inserting data into table "rangers.search_deck"
"""
input rangers_search_deck_insert_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  likes: rangers_deck_like_count_obj_rel_insert_input
  meta: jsonb
  name: String
  next_deck_id: Int
  published: Boolean
  rank: rangers_deck_rank_obj_rel_insert_input
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user: rangers_users_obj_rel_insert_input
  user_id: String
  version: Int
}

"""aggregate max on columns"""
type rangers_search_deck_max_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  name: String
  next_deck_id: Int
  spi: Int
  taboo_set_id: String
  updated_at: timestamptz
  user_id: String
  version: Int
}

"""aggregate min on columns"""
type rangers_search_deck_min_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  name: String
  next_deck_id: Int
  spi: Int
  taboo_set_id: String
  updated_at: timestamptz
  user_id: String
  version: Int
}

"""
response of any mutation on the table "rangers.search_deck"
"""
type rangers_search_deck_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_search_deck!]!
}

"""Ordering options when selecting data from "rangers.search_deck"."""
input rangers_search_deck_order_by {
  awa: order_by
  base_deck_id: order_by
  campaign_id: order_by
  comment_count: order_by
  copy_count: order_by
  created_at: order_by
  description: order_by
  fit: order_by
  foc: order_by
  id: order_by
  like_count: order_by
  liked_by_user: order_by
  likes: rangers_deck_like_count_order_by
  meta: order_by
  name: order_by
  next_deck_id: order_by
  published: order_by
  rank: rangers_deck_rank_order_by
  side_slots: order_by
  slots: order_by
  spi: order_by
  taboo_set_id: order_by
  tags: order_by
  updated_at: order_by
  upgrade: order_by
  user: rangers_users_order_by
  user_id: order_by
  version: order_by
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rangers_search_deck_prepend_input {
  meta: jsonb
  side_slots: jsonb
  slots: jsonb
  tags: jsonb
  upgrade: jsonb
}

"""
select columns of table "rangers.search_deck"
"""
enum rangers_search_deck_select_column {
  """column name"""
  awa

  """column name"""
  base_deck_id

  """column name"""
  campaign_id

  """column name"""
  comment_count

  """column name"""
  copy_count

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  fit

  """column name"""
  foc

  """column name"""
  id

  """column name"""
  like_count

  """column name"""
  meta

  """column name"""
  name

  """column name"""
  next_deck_id

  """column name"""
  published

  """column name"""
  side_slots

  """column name"""
  slots

  """column name"""
  spi

  """column name"""
  taboo_set_id

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  upgrade

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "rangers.search_deck"
"""
input rangers_search_deck_set_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  next_deck_id: Int
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user_id: String
  version: Int
}

"""aggregate stddev on columns"""
type rangers_search_deck_stddev_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type rangers_search_deck_stddev_pop_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type rangers_search_deck_stddev_samp_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
Streaming cursor of the table "rangers_search_deck"
"""
input rangers_search_deck_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_search_deck_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_search_deck_stream_cursor_value_input {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  created_at: timestamptz
  description: String
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  meta: jsonb
  name: String
  next_deck_id: Int
  published: Boolean
  side_slots: jsonb
  slots: jsonb
  spi: Int
  taboo_set_id: String
  tags: jsonb
  updated_at: timestamptz
  upgrade: jsonb
  user_id: String
  version: Int
}

"""aggregate sum on columns"""
type rangers_search_deck_sum_fields {
  awa: Int
  base_deck_id: Int
  campaign_id: Int
  comment_count: Int
  copy_count: Int
  fit: Int
  foc: Int
  id: Int
  like_count: Int
  next_deck_id: Int
  spi: Int
  version: Int
}

input rangers_search_deck_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rangers_search_deck_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rangers_search_deck_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rangers_search_deck_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rangers_search_deck_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_search_deck_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rangers_search_deck_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_search_deck_set_input

  """filter the rows which have to be updated"""
  where: rangers_search_deck_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_search_deck_var_pop_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate var_samp on columns"""
type rangers_search_deck_var_samp_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""aggregate variance on columns"""
type rangers_search_deck_variance_fields {
  awa: Float
  base_deck_id: Float
  campaign_id: Float
  comment_count: Float
  copy_count: Float
  fit: Float
  foc: Float
  id: Float
  like_count: Float
  next_deck_id: Float
  spi: Float
  version: Float
}

"""
columns and relationships of "rangers.set"
"""
type rangers_set {
  id: String!
  name: String!
  size: Int

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): [rangers_set_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): rangers_set_text_aggregate!
  type_id: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set"
"""
type rangers_set_aggregate {
  aggregate: rangers_set_aggregate_fields
  nodes: [rangers_set!]!
}

"""
aggregate fields of "rangers.set"
"""
type rangers_set_aggregate_fields {
  avg: rangers_set_avg_fields
  count(columns: [rangers_set_select_column!], distinct: Boolean): Int!
  max: rangers_set_max_fields
  min: rangers_set_min_fields
  stddev: rangers_set_stddev_fields
  stddev_pop: rangers_set_stddev_pop_fields
  stddev_samp: rangers_set_stddev_samp_fields
  sum: rangers_set_sum_fields
  var_pop: rangers_set_var_pop_fields
  var_samp: rangers_set_var_samp_fields
  variance: rangers_set_variance_fields
}

"""aggregate avg on columns"""
type rangers_set_avg_fields {
  size: Float
}

"""
Boolean expression to filter rows from the table "rangers.set". All fields are combined with a logical 'AND'.
"""
input rangers_set_bool_exp {
  _and: [rangers_set_bool_exp!]
  _not: rangers_set_bool_exp
  _or: [rangers_set_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  translations: rangers_set_text_bool_exp
  translations_aggregate: rangers_set_text_aggregate_bool_exp
  type_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

input rangers_set_campaign_deck_args {
  deck_id: Int
  new_campaign_id: Int
}

"""
unique or primary key constraints on table "rangers.set"
"""
enum rangers_set_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  set_pkey
}

input rangers_set_handle_args {
  handle: String
}

"""
input type for incrementing numeric columns in table "rangers.set"
"""
input rangers_set_inc_input {
  size: Int
}

"""
input type for inserting data into table "rangers.set"
"""
input rangers_set_insert_input {
  id: String
  name: String
  size: Int
  translations: rangers_set_text_arr_rel_insert_input
  type_id: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.set_localized"
"""
type rangers_set_localized {
  id: String
  locale: String
  name: String
  real_name: String
  size: Int
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set_localized"
"""
type rangers_set_localized_aggregate {
  aggregate: rangers_set_localized_aggregate_fields
  nodes: [rangers_set_localized!]!
}

input rangers_set_localized_aggregate_bool_exp {
  count: rangers_set_localized_aggregate_bool_exp_count
}

input rangers_set_localized_aggregate_bool_exp_count {
  arguments: [rangers_set_localized_select_column!]
  distinct: Boolean
  filter: rangers_set_localized_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.set_localized"
"""
type rangers_set_localized_aggregate_fields {
  avg: rangers_set_localized_avg_fields
  count(columns: [rangers_set_localized_select_column!], distinct: Boolean): Int!
  max: rangers_set_localized_max_fields
  min: rangers_set_localized_min_fields
  stddev: rangers_set_localized_stddev_fields
  stddev_pop: rangers_set_localized_stddev_pop_fields
  stddev_samp: rangers_set_localized_stddev_samp_fields
  sum: rangers_set_localized_sum_fields
  var_pop: rangers_set_localized_var_pop_fields
  var_samp: rangers_set_localized_var_samp_fields
  variance: rangers_set_localized_variance_fields
}

"""
order by aggregate values of table "rangers.set_localized"
"""
input rangers_set_localized_aggregate_order_by {
  avg: rangers_set_localized_avg_order_by
  count: order_by
  max: rangers_set_localized_max_order_by
  min: rangers_set_localized_min_order_by
  stddev: rangers_set_localized_stddev_order_by
  stddev_pop: rangers_set_localized_stddev_pop_order_by
  stddev_samp: rangers_set_localized_stddev_samp_order_by
  sum: rangers_set_localized_sum_order_by
  var_pop: rangers_set_localized_var_pop_order_by
  var_samp: rangers_set_localized_var_samp_order_by
  variance: rangers_set_localized_variance_order_by
}

"""aggregate avg on columns"""
type rangers_set_localized_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "rangers.set_localized". All fields are combined with a logical 'AND'.
"""
input rangers_set_localized_bool_exp {
  _and: [rangers_set_localized_bool_exp!]
  _not: rangers_set_localized_bool_exp
  _or: [rangers_set_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  real_name: String_comparison_exp
  size: Int_comparison_exp
  type_id: String_comparison_exp
  type_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_set_localized_max_fields {
  id: String
  locale: String
  name: String
  real_name: String
  size: Int
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_max_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  size: order_by
  type_id: order_by
  type_name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type rangers_set_localized_min_fields {
  id: String
  locale: String
  name: String
  real_name: String
  size: Int
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_min_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  size: order_by
  type_id: order_by
  type_name: order_by
  updated_at: order_by
}

"""Ordering options when selecting data from "rangers.set_localized"."""
input rangers_set_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  size: order_by
  type_id: order_by
  type_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.set_localized"
"""
enum rangers_set_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  real_name

  """column name"""
  size

  """column name"""
  type_id

  """column name"""
  type_name

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type rangers_set_localized_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type rangers_set_localized_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type rangers_set_localized_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "rangers_set_localized"
"""
input rangers_set_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  real_name: String
  size: Int
  type_id: String
  type_name: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_set_localized_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_sum_order_by {
  size: order_by
}

"""aggregate var_pop on columns"""
type rangers_set_localized_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type rangers_set_localized_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type rangers_set_localized_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "rangers.set_localized"
"""
input rangers_set_localized_variance_order_by {
  size: order_by
}

"""aggregate max on columns"""
type rangers_set_max_fields {
  id: String
  name: String
  size: Int
  type_id: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_set_min_fields {
  id: String
  name: String
  size: Int
  type_id: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.set"
"""
type rangers_set_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_set!]!
}

"""
on_conflict condition type for table "rangers.set"
"""
input rangers_set_on_conflict {
  constraint: rangers_set_constraint!
  update_columns: [rangers_set_update_column!]! = []
  where: rangers_set_bool_exp
}

"""Ordering options when selecting data from "rangers.set"."""
input rangers_set_order_by {
  id: order_by
  name: order_by
  size: order_by
  translations_aggregate: rangers_set_text_aggregate_order_by
  type_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.set"""
input rangers_set_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.set"
"""
enum rangers_set_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  size

  """column name"""
  type_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.set"
"""
input rangers_set_set_input {
  id: String
  name: String
  size: Int
  type_id: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type rangers_set_stddev_fields {
  size: Float
}

"""aggregate stddev_pop on columns"""
type rangers_set_stddev_pop_fields {
  size: Float
}

"""aggregate stddev_samp on columns"""
type rangers_set_stddev_samp_fields {
  size: Float
}

"""
Streaming cursor of the table "rangers_set"
"""
input rangers_set_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_stream_cursor_value_input {
  id: String
  name: String
  size: Int
  type_id: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_set_sum_fields {
  size: Int
}

"""
columns and relationships of "rangers.set_text"
"""
type rangers_set_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set_text"
"""
type rangers_set_text_aggregate {
  aggregate: rangers_set_text_aggregate_fields
  nodes: [rangers_set_text!]!
}

input rangers_set_text_aggregate_bool_exp {
  count: rangers_set_text_aggregate_bool_exp_count
}

input rangers_set_text_aggregate_bool_exp_count {
  arguments: [rangers_set_text_select_column!]
  distinct: Boolean
  filter: rangers_set_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.set_text"
"""
type rangers_set_text_aggregate_fields {
  count(columns: [rangers_set_text_select_column!], distinct: Boolean): Int!
  max: rangers_set_text_max_fields
  min: rangers_set_text_min_fields
}

"""
order by aggregate values of table "rangers.set_text"
"""
input rangers_set_text_aggregate_order_by {
  count: order_by
  max: rangers_set_text_max_order_by
  min: rangers_set_text_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.set_text"
"""
input rangers_set_text_arr_rel_insert_input {
  data: [rangers_set_text_insert_input!]!

  """upsert condition"""
  on_conflict: rangers_set_text_on_conflict
}

"""
Boolean expression to filter rows from the table "rangers.set_text". All fields are combined with a logical 'AND'.
"""
input rangers_set_text_bool_exp {
  _and: [rangers_set_text_bool_exp!]
  _not: rangers_set_text_bool_exp
  _or: [rangers_set_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.set_text"
"""
enum rangers_set_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  set_text_pkey
}

"""
input type for inserting data into table "rangers.set_text"
"""
input rangers_set_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_set_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "rangers.set_text"
"""
input rangers_set_text_max_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type rangers_set_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "rangers.set_text"
"""
input rangers_set_text_min_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "rangers.set_text"
"""
type rangers_set_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_set_text!]!
}

"""
on_conflict condition type for table "rangers.set_text"
"""
input rangers_set_text_on_conflict {
  constraint: rangers_set_text_constraint!
  update_columns: [rangers_set_text_update_column!]! = []
  where: rangers_set_text_bool_exp
}

"""Ordering options when selecting data from "rangers.set_text"."""
input rangers_set_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.set_text"""
input rangers_set_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.set_text"
"""
enum rangers_set_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.set_text"
"""
input rangers_set_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_set_text"
"""
input rangers_set_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.set_text"
"""
enum rangers_set_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_set_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_set_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_set_text_bool_exp!
}

"""
columns and relationships of "rangers.set_type"
"""
type rangers_set_type {
  id: String!
  name: String!

  """An array relationship"""
  translations(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): [rangers_set_type_text!]!

  """An aggregate relationship"""
  translations_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): rangers_set_type_text_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set_type"
"""
type rangers_set_type_aggregate {
  aggregate: rangers_set_type_aggregate_fields
  nodes: [rangers_set_type!]!
}

"""
aggregate fields of "rangers.set_type"
"""
type rangers_set_type_aggregate_fields {
  count(columns: [rangers_set_type_select_column!], distinct: Boolean): Int!
  max: rangers_set_type_max_fields
  min: rangers_set_type_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.set_type". All fields are combined with a logical 'AND'.
"""
input rangers_set_type_bool_exp {
  _and: [rangers_set_type_bool_exp!]
  _not: rangers_set_type_bool_exp
  _or: [rangers_set_type_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  translations: rangers_set_type_text_bool_exp
  translations_aggregate: rangers_set_type_text_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.set_type"
"""
enum rangers_set_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  set_type_pkey
}

"""
input type for inserting data into table "rangers.set_type"
"""
input rangers_set_type_insert_input {
  id: String
  name: String
  translations: rangers_set_type_text_arr_rel_insert_input
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.set_type_localized"
"""
type rangers_set_type_localized {
  id: String
  locale: String
  name: String
  real_name: String

  """An array relationship"""
  sets(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): [rangers_set_localized!]!

  """An aggregate relationship"""
  sets_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): rangers_set_localized_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set_type_localized"
"""
type rangers_set_type_localized_aggregate {
  aggregate: rangers_set_type_localized_aggregate_fields
  nodes: [rangers_set_type_localized!]!
}

"""
aggregate fields of "rangers.set_type_localized"
"""
type rangers_set_type_localized_aggregate_fields {
  count(columns: [rangers_set_type_localized_select_column!], distinct: Boolean): Int!
  max: rangers_set_type_localized_max_fields
  min: rangers_set_type_localized_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.set_type_localized". All fields are combined with a logical 'AND'.
"""
input rangers_set_type_localized_bool_exp {
  _and: [rangers_set_type_localized_bool_exp!]
  _not: rangers_set_type_localized_bool_exp
  _or: [rangers_set_type_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  real_name: String_comparison_exp
  sets: rangers_set_localized_bool_exp
  sets_aggregate: rangers_set_localized_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_set_type_localized_max_fields {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_set_type_localized_min_fields {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""
Ordering options when selecting data from "rangers.set_type_localized".
"""
input rangers_set_type_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  sets_aggregate: rangers_set_localized_aggregate_order_by
  updated_at: order_by
}

"""
select columns of table "rangers.set_type_localized"
"""
enum rangers_set_type_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  real_name

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "rangers_set_type_localized"
"""
input rangers_set_type_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_type_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_type_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_set_type_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_set_type_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.set_type"
"""
type rangers_set_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_set_type!]!
}

"""
on_conflict condition type for table "rangers.set_type"
"""
input rangers_set_type_on_conflict {
  constraint: rangers_set_type_constraint!
  update_columns: [rangers_set_type_update_column!]! = []
  where: rangers_set_type_bool_exp
}

"""Ordering options when selecting data from "rangers.set_type"."""
input rangers_set_type_order_by {
  id: order_by
  name: order_by
  translations_aggregate: rangers_set_type_text_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.set_type"""
input rangers_set_type_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.set_type"
"""
enum rangers_set_type_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.set_type"
"""
input rangers_set_type_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_set_type"
"""
input rangers_set_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_type_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.set_type_text"
"""
type rangers_set_type_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.set_type_text"
"""
type rangers_set_type_text_aggregate {
  aggregate: rangers_set_type_text_aggregate_fields
  nodes: [rangers_set_type_text!]!
}

input rangers_set_type_text_aggregate_bool_exp {
  count: rangers_set_type_text_aggregate_bool_exp_count
}

input rangers_set_type_text_aggregate_bool_exp_count {
  arguments: [rangers_set_type_text_select_column!]
  distinct: Boolean
  filter: rangers_set_type_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.set_type_text"
"""
type rangers_set_type_text_aggregate_fields {
  count(columns: [rangers_set_type_text_select_column!], distinct: Boolean): Int!
  max: rangers_set_type_text_max_fields
  min: rangers_set_type_text_min_fields
}

"""
order by aggregate values of table "rangers.set_type_text"
"""
input rangers_set_type_text_aggregate_order_by {
  count: order_by
  max: rangers_set_type_text_max_order_by
  min: rangers_set_type_text_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.set_type_text"
"""
input rangers_set_type_text_arr_rel_insert_input {
  data: [rangers_set_type_text_insert_input!]!

  """upsert condition"""
  on_conflict: rangers_set_type_text_on_conflict
}

"""
Boolean expression to filter rows from the table "rangers.set_type_text". All fields are combined with a logical 'AND'.
"""
input rangers_set_type_text_bool_exp {
  _and: [rangers_set_type_text_bool_exp!]
  _not: rangers_set_type_text_bool_exp
  _or: [rangers_set_type_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.set_type_text"
"""
enum rangers_set_type_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  set_type_text_pkey
}

"""
input type for inserting data into table "rangers.set_type_text"
"""
input rangers_set_type_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_set_type_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "rangers.set_type_text"
"""
input rangers_set_type_text_max_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type rangers_set_type_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "rangers.set_type_text"
"""
input rangers_set_type_text_min_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "rangers.set_type_text"
"""
type rangers_set_type_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_set_type_text!]!
}

"""
on_conflict condition type for table "rangers.set_type_text"
"""
input rangers_set_type_text_on_conflict {
  constraint: rangers_set_type_text_constraint!
  update_columns: [rangers_set_type_text_update_column!]! = []
  where: rangers_set_type_text_bool_exp
}

"""Ordering options when selecting data from "rangers.set_type_text"."""
input rangers_set_type_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.set_type_text"""
input rangers_set_type_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.set_type_text"
"""
enum rangers_set_type_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.set_type_text"
"""
input rangers_set_type_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_set_type_text"
"""
input rangers_set_type_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_set_type_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_set_type_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.set_type_text"
"""
enum rangers_set_type_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_set_type_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_set_type_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_set_type_text_bool_exp!
}

"""
update columns of table "rangers.set_type"
"""
enum rangers_set_type_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_set_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_set_type_set_input

  """filter the rows which have to be updated"""
  where: rangers_set_type_bool_exp!
}

"""
update columns of table "rangers.set"
"""
enum rangers_set_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  size

  """column name"""
  type_id

  """column name"""
  updated_at
}

input rangers_set_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_set_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_set_set_input

  """filter the rows which have to be updated"""
  where: rangers_set_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_set_var_pop_fields {
  size: Float
}

"""aggregate var_samp on columns"""
type rangers_set_var_samp_fields {
  size: Float
}

"""aggregate variance on columns"""
type rangers_set_variance_fields {
  size: Float
}

"""
columns and relationships of "rangers.subset"
"""
type rangers_subset {
  id: String!
  name: String!
  pack_id: String!
  set_id: String!
  size: Int!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.subset"
"""
type rangers_subset_aggregate {
  aggregate: rangers_subset_aggregate_fields
  nodes: [rangers_subset!]!
}

"""
aggregate fields of "rangers.subset"
"""
type rangers_subset_aggregate_fields {
  avg: rangers_subset_avg_fields
  count(columns: [rangers_subset_select_column!], distinct: Boolean): Int!
  max: rangers_subset_max_fields
  min: rangers_subset_min_fields
  stddev: rangers_subset_stddev_fields
  stddev_pop: rangers_subset_stddev_pop_fields
  stddev_samp: rangers_subset_stddev_samp_fields
  sum: rangers_subset_sum_fields
  var_pop: rangers_subset_var_pop_fields
  var_samp: rangers_subset_var_samp_fields
  variance: rangers_subset_variance_fields
}

"""aggregate avg on columns"""
type rangers_subset_avg_fields {
  size: Float
}

"""
Boolean expression to filter rows from the table "rangers.subset". All fields are combined with a logical 'AND'.
"""
input rangers_subset_bool_exp {
  _and: [rangers_subset_bool_exp!]
  _not: rangers_subset_bool_exp
  _or: [rangers_subset_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  pack_id: String_comparison_exp
  set_id: String_comparison_exp
  size: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.subset"
"""
enum rangers_subset_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  subset_pkey
}

"""
input type for incrementing numeric columns in table "rangers.subset"
"""
input rangers_subset_inc_input {
  size: Int
}

"""
input type for inserting data into table "rangers.subset"
"""
input rangers_subset_insert_input {
  id: String
  name: String
  pack_id: String
  set_id: String
  size: Int
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.subset_localized"
"""
type rangers_subset_localized {
  id: String
  locale: String
  name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  real_name: String
  set_id: String
  set_name: String
  set_size: Int
  set_type_id: String
  set_type_name: String
  size: Int
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.subset_localized"
"""
type rangers_subset_localized_aggregate {
  aggregate: rangers_subset_localized_aggregate_fields
  nodes: [rangers_subset_localized!]!
}

"""
aggregate fields of "rangers.subset_localized"
"""
type rangers_subset_localized_aggregate_fields {
  avg: rangers_subset_localized_avg_fields
  count(columns: [rangers_subset_localized_select_column!], distinct: Boolean): Int!
  max: rangers_subset_localized_max_fields
  min: rangers_subset_localized_min_fields
  stddev: rangers_subset_localized_stddev_fields
  stddev_pop: rangers_subset_localized_stddev_pop_fields
  stddev_samp: rangers_subset_localized_stddev_samp_fields
  sum: rangers_subset_localized_sum_fields
  var_pop: rangers_subset_localized_var_pop_fields
  var_samp: rangers_subset_localized_var_samp_fields
  variance: rangers_subset_localized_variance_fields
}

"""aggregate avg on columns"""
type rangers_subset_localized_avg_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""
Boolean expression to filter rows from the table "rangers.subset_localized". All fields are combined with a logical 'AND'.
"""
input rangers_subset_localized_bool_exp {
  _and: [rangers_subset_localized_bool_exp!]
  _not: rangers_subset_localized_bool_exp
  _or: [rangers_subset_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  pack_id: String_comparison_exp
  pack_name: String_comparison_exp
  pack_position: Int_comparison_exp
  pack_short_name: String_comparison_exp
  real_name: String_comparison_exp
  set_id: String_comparison_exp
  set_name: String_comparison_exp
  set_size: Int_comparison_exp
  set_type_id: String_comparison_exp
  set_type_name: String_comparison_exp
  size: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_subset_localized_max_fields {
  id: String
  locale: String
  name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  real_name: String
  set_id: String
  set_name: String
  set_size: Int
  set_type_id: String
  set_type_name: String
  size: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_subset_localized_min_fields {
  id: String
  locale: String
  name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  real_name: String
  set_id: String
  set_name: String
  set_size: Int
  set_type_id: String
  set_type_name: String
  size: Int
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.subset_localized"."""
input rangers_subset_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  pack_id: order_by
  pack_name: order_by
  pack_position: order_by
  pack_short_name: order_by
  real_name: order_by
  set_id: order_by
  set_name: order_by
  set_size: order_by
  set_type_id: order_by
  set_type_name: order_by
  size: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.subset_localized"
"""
enum rangers_subset_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  pack_id

  """column name"""
  pack_name

  """column name"""
  pack_position

  """column name"""
  pack_short_name

  """column name"""
  real_name

  """column name"""
  set_id

  """column name"""
  set_name

  """column name"""
  set_size

  """column name"""
  set_type_id

  """column name"""
  set_type_name

  """column name"""
  size

  """column name"""
  updated_at
}

"""aggregate stddev on columns"""
type rangers_subset_localized_stddev_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""aggregate stddev_pop on columns"""
type rangers_subset_localized_stddev_pop_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""aggregate stddev_samp on columns"""
type rangers_subset_localized_stddev_samp_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""
Streaming cursor of the table "rangers_subset_localized"
"""
input rangers_subset_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_subset_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_subset_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  pack_id: String
  pack_name: String
  pack_position: Int
  pack_short_name: String
  real_name: String
  set_id: String
  set_name: String
  set_size: Int
  set_type_id: String
  set_type_name: String
  size: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_subset_localized_sum_fields {
  pack_position: Int
  set_size: Int
  size: Int
}

"""aggregate var_pop on columns"""
type rangers_subset_localized_var_pop_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""aggregate var_samp on columns"""
type rangers_subset_localized_var_samp_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""aggregate variance on columns"""
type rangers_subset_localized_variance_fields {
  pack_position: Float
  set_size: Float
  size: Float
}

"""aggregate max on columns"""
type rangers_subset_max_fields {
  id: String
  name: String
  pack_id: String
  set_id: String
  size: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_subset_min_fields {
  id: String
  name: String
  pack_id: String
  set_id: String
  size: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.subset"
"""
type rangers_subset_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_subset!]!
}

"""
on_conflict condition type for table "rangers.subset"
"""
input rangers_subset_on_conflict {
  constraint: rangers_subset_constraint!
  update_columns: [rangers_subset_update_column!]! = []
  where: rangers_subset_bool_exp
}

"""Ordering options when selecting data from "rangers.subset"."""
input rangers_subset_order_by {
  id: order_by
  name: order_by
  pack_id: order_by
  set_id: order_by
  size: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.subset"""
input rangers_subset_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.subset"
"""
enum rangers_subset_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  pack_id

  """column name"""
  set_id

  """column name"""
  size

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.subset"
"""
input rangers_subset_set_input {
  id: String
  name: String
  pack_id: String
  set_id: String
  size: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type rangers_subset_stddev_fields {
  size: Float
}

"""aggregate stddev_pop on columns"""
type rangers_subset_stddev_pop_fields {
  size: Float
}

"""aggregate stddev_samp on columns"""
type rangers_subset_stddev_samp_fields {
  size: Float
}

"""
Streaming cursor of the table "rangers_subset"
"""
input rangers_subset_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_subset_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_subset_stream_cursor_value_input {
  id: String
  name: String
  pack_id: String
  set_id: String
  size: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type rangers_subset_sum_fields {
  size: Int
}

"""
columns and relationships of "rangers.subset_text"
"""
type rangers_subset_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.subset_text"
"""
type rangers_subset_text_aggregate {
  aggregate: rangers_subset_text_aggregate_fields
  nodes: [rangers_subset_text!]!
}

"""
aggregate fields of "rangers.subset_text"
"""
type rangers_subset_text_aggregate_fields {
  count(columns: [rangers_subset_text_select_column!], distinct: Boolean): Int!
  max: rangers_subset_text_max_fields
  min: rangers_subset_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.subset_text". All fields are combined with a logical 'AND'.
"""
input rangers_subset_text_bool_exp {
  _and: [rangers_subset_text_bool_exp!]
  _not: rangers_subset_text_bool_exp
  _or: [rangers_subset_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.subset_text"
"""
enum rangers_subset_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  subset_text_pkey
}

"""
input type for inserting data into table "rangers.subset_text"
"""
input rangers_subset_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_subset_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_subset_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.subset_text"
"""
type rangers_subset_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_subset_text!]!
}

"""
on_conflict condition type for table "rangers.subset_text"
"""
input rangers_subset_text_on_conflict {
  constraint: rangers_subset_text_constraint!
  update_columns: [rangers_subset_text_update_column!]! = []
  where: rangers_subset_text_bool_exp
}

"""Ordering options when selecting data from "rangers.subset_text"."""
input rangers_subset_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.subset_text"""
input rangers_subset_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.subset_text"
"""
enum rangers_subset_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.subset_text"
"""
input rangers_subset_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_subset_text"
"""
input rangers_subset_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_subset_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_subset_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.subset_text"
"""
enum rangers_subset_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_subset_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_subset_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_subset_text_bool_exp!
}

"""
update columns of table "rangers.subset"
"""
enum rangers_subset_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  pack_id

  """column name"""
  set_id

  """column name"""
  size

  """column name"""
  updated_at
}

input rangers_subset_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rangers_subset_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_subset_set_input

  """filter the rows which have to be updated"""
  where: rangers_subset_bool_exp!
}

"""aggregate var_pop on columns"""
type rangers_subset_var_pop_fields {
  size: Float
}

"""aggregate var_samp on columns"""
type rangers_subset_var_samp_fields {
  size: Float
}

"""aggregate variance on columns"""
type rangers_subset_variance_fields {
  size: Float
}

"""
columns and relationships of "rangers.taboo_set"
"""
type rangers_taboo_set {
  date: timestamptz
  id: String!
  is_current: Boolean!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.taboo_set"
"""
type rangers_taboo_set_aggregate {
  aggregate: rangers_taboo_set_aggregate_fields
  nodes: [rangers_taboo_set!]!
}

"""
aggregate fields of "rangers.taboo_set"
"""
type rangers_taboo_set_aggregate_fields {
  count(columns: [rangers_taboo_set_select_column!], distinct: Boolean): Int!
  max: rangers_taboo_set_max_fields
  min: rangers_taboo_set_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.taboo_set". All fields are combined with a logical 'AND'.
"""
input rangers_taboo_set_bool_exp {
  _and: [rangers_taboo_set_bool_exp!]
  _not: rangers_taboo_set_bool_exp
  _or: [rangers_taboo_set_bool_exp!]
  date: timestamptz_comparison_exp
  id: String_comparison_exp
  is_current: Boolean_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.taboo_set"
"""
enum rangers_taboo_set_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  taboo_set_pkey
}

"""
input type for inserting data into table "rangers.taboo_set"
"""
input rangers_taboo_set_insert_input {
  date: timestamptz
  id: String
  is_current: Boolean
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.taboo_set_localized"
"""
type rangers_taboo_set_localized {
  date: timestamptz
  id: String
  is_current: Boolean
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.taboo_set_localized"
"""
type rangers_taboo_set_localized_aggregate {
  aggregate: rangers_taboo_set_localized_aggregate_fields
  nodes: [rangers_taboo_set_localized!]!
}

"""
aggregate fields of "rangers.taboo_set_localized"
"""
type rangers_taboo_set_localized_aggregate_fields {
  count(columns: [rangers_taboo_set_localized_select_column!], distinct: Boolean): Int!
  max: rangers_taboo_set_localized_max_fields
  min: rangers_taboo_set_localized_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.taboo_set_localized". All fields are combined with a logical 'AND'.
"""
input rangers_taboo_set_localized_bool_exp {
  _and: [rangers_taboo_set_localized_bool_exp!]
  _not: rangers_taboo_set_localized_bool_exp
  _or: [rangers_taboo_set_localized_bool_exp!]
  date: timestamptz_comparison_exp
  id: String_comparison_exp
  is_current: Boolean_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  real_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_taboo_set_localized_max_fields {
  date: timestamptz
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_taboo_set_localized_min_fields {
  date: timestamptz
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""
Ordering options when selecting data from "rangers.taboo_set_localized".
"""
input rangers_taboo_set_localized_order_by {
  date: order_by
  id: order_by
  is_current: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.taboo_set_localized"
"""
enum rangers_taboo_set_localized_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_current

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  real_name

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "rangers_taboo_set_localized"
"""
input rangers_taboo_set_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_taboo_set_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_taboo_set_localized_stream_cursor_value_input {
  date: timestamptz
  id: String
  is_current: Boolean
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_taboo_set_max_fields {
  date: timestamptz
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_taboo_set_min_fields {
  date: timestamptz
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.taboo_set"
"""
type rangers_taboo_set_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_taboo_set!]!
}

"""
on_conflict condition type for table "rangers.taboo_set"
"""
input rangers_taboo_set_on_conflict {
  constraint: rangers_taboo_set_constraint!
  update_columns: [rangers_taboo_set_update_column!]! = []
  where: rangers_taboo_set_bool_exp
}

"""Ordering options when selecting data from "rangers.taboo_set"."""
input rangers_taboo_set_order_by {
  date: order_by
  id: order_by
  is_current: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.taboo_set"""
input rangers_taboo_set_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.taboo_set"
"""
enum rangers_taboo_set_select_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_current

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.taboo_set"
"""
input rangers_taboo_set_set_input {
  date: timestamptz
  id: String
  is_current: Boolean
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_taboo_set"
"""
input rangers_taboo_set_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_taboo_set_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_taboo_set_stream_cursor_value_input {
  date: timestamptz
  id: String
  is_current: Boolean
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.taboo_set_text"
"""
type rangers_taboo_set_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "rangers.taboo_set_text"
"""
type rangers_taboo_set_text_aggregate {
  aggregate: rangers_taboo_set_text_aggregate_fields
  nodes: [rangers_taboo_set_text!]!
}

"""
aggregate fields of "rangers.taboo_set_text"
"""
type rangers_taboo_set_text_aggregate_fields {
  count(columns: [rangers_taboo_set_text_select_column!], distinct: Boolean): Int!
  max: rangers_taboo_set_text_max_fields
  min: rangers_taboo_set_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.taboo_set_text". All fields are combined with a logical 'AND'.
"""
input rangers_taboo_set_text_bool_exp {
  _and: [rangers_taboo_set_text_bool_exp!]
  _not: rangers_taboo_set_text_bool_exp
  _or: [rangers_taboo_set_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.taboo_set_text"
"""
enum rangers_taboo_set_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  taboo_set_text_pkey
}

"""
input type for inserting data into table "rangers.taboo_set_text"
"""
input rangers_taboo_set_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_taboo_set_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_taboo_set_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.taboo_set_text"
"""
type rangers_taboo_set_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_taboo_set_text!]!
}

"""
on_conflict condition type for table "rangers.taboo_set_text"
"""
input rangers_taboo_set_text_on_conflict {
  constraint: rangers_taboo_set_text_constraint!
  update_columns: [rangers_taboo_set_text_update_column!]! = []
  where: rangers_taboo_set_text_bool_exp
}

"""Ordering options when selecting data from "rangers.taboo_set_text"."""
input rangers_taboo_set_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.taboo_set_text"""
input rangers_taboo_set_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.taboo_set_text"
"""
enum rangers_taboo_set_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.taboo_set_text"
"""
input rangers_taboo_set_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_taboo_set_text"
"""
input rangers_taboo_set_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_taboo_set_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_taboo_set_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.taboo_set_text"
"""
enum rangers_taboo_set_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_taboo_set_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_taboo_set_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_taboo_set_text_bool_exp!
}

"""
update columns of table "rangers.taboo_set"
"""
enum rangers_taboo_set_update_column {
  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_current

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_taboo_set_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_taboo_set_set_input

  """filter the rows which have to be updated"""
  where: rangers_taboo_set_bool_exp!
}

"""
columns and relationships of "rangers.token"
"""
type rangers_token {
  id: String!
  name: String!
  plurals: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.token"
"""
type rangers_token_aggregate {
  aggregate: rangers_token_aggregate_fields
  nodes: [rangers_token!]!
}

"""
aggregate fields of "rangers.token"
"""
type rangers_token_aggregate_fields {
  count(columns: [rangers_token_select_column!], distinct: Boolean): Int!
  max: rangers_token_max_fields
  min: rangers_token_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.token". All fields are combined with a logical 'AND'.
"""
input rangers_token_bool_exp {
  _and: [rangers_token_bool_exp!]
  _not: rangers_token_bool_exp
  _or: [rangers_token_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  plurals: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.token"
"""
enum rangers_token_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  token_pkey
}

"""
input type for inserting data into table "rangers.token"
"""
input rangers_token_insert_input {
  id: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_token_max_fields {
  id: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_token_min_fields {
  id: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.token"
"""
type rangers_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_token!]!
}

"""
on_conflict condition type for table "rangers.token"
"""
input rangers_token_on_conflict {
  constraint: rangers_token_constraint!
  update_columns: [rangers_token_update_column!]! = []
  where: rangers_token_bool_exp
}

"""Ordering options when selecting data from "rangers.token"."""
input rangers_token_order_by {
  id: order_by
  name: order_by
  plurals: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.token"""
input rangers_token_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.token"
"""
enum rangers_token_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  plurals

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.token"
"""
input rangers_token_set_input {
  id: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_token"
"""
input rangers_token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_token_stream_cursor_value_input {
  id: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.token_text"
"""
type rangers_token_text {
  id: String!
  locale: String!
  name: String!
  plurals: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.token_text"
"""
type rangers_token_text_aggregate {
  aggregate: rangers_token_text_aggregate_fields
  nodes: [rangers_token_text!]!
}

"""
aggregate fields of "rangers.token_text"
"""
type rangers_token_text_aggregate_fields {
  count(columns: [rangers_token_text_select_column!], distinct: Boolean): Int!
  max: rangers_token_text_max_fields
  min: rangers_token_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.token_text". All fields are combined with a logical 'AND'.
"""
input rangers_token_text_bool_exp {
  _and: [rangers_token_text_bool_exp!]
  _not: rangers_token_text_bool_exp
  _or: [rangers_token_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  plurals: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.token_text"
"""
enum rangers_token_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  token_text_pkey
}

"""
input type for inserting data into table "rangers.token_text"
"""
input rangers_token_text_insert_input {
  id: String
  locale: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_token_text_max_fields {
  id: String
  locale: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_token_text_min_fields {
  id: String
  locale: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.token_text"
"""
type rangers_token_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_token_text!]!
}

"""
on_conflict condition type for table "rangers.token_text"
"""
input rangers_token_text_on_conflict {
  constraint: rangers_token_text_constraint!
  update_columns: [rangers_token_text_update_column!]! = []
  where: rangers_token_text_bool_exp
}

"""Ordering options when selecting data from "rangers.token_text"."""
input rangers_token_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  plurals: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.token_text"""
input rangers_token_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.token_text"
"""
enum rangers_token_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  plurals

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.token_text"
"""
input rangers_token_text_set_input {
  id: String
  locale: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_token_text"
"""
input rangers_token_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_token_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_token_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  plurals: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.token_text"
"""
enum rangers_token_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  plurals

  """column name"""
  updated_at
}

input rangers_token_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_token_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_token_text_bool_exp!
}

"""
update columns of table "rangers.token"
"""
enum rangers_token_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  plurals

  """column name"""
  updated_at
}

input rangers_token_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_token_set_input

  """filter the rows which have to be updated"""
  where: rangers_token_bool_exp!
}

"""
columns and relationships of "rangers.type"
"""
type rangers_type {
  id: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.type"
"""
type rangers_type_aggregate {
  aggregate: rangers_type_aggregate_fields
  nodes: [rangers_type!]!
}

"""
aggregate fields of "rangers.type"
"""
type rangers_type_aggregate_fields {
  count(columns: [rangers_type_select_column!], distinct: Boolean): Int!
  max: rangers_type_max_fields
  min: rangers_type_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.type". All fields are combined with a logical 'AND'.
"""
input rangers_type_bool_exp {
  _and: [rangers_type_bool_exp!]
  _not: rangers_type_bool_exp
  _or: [rangers_type_bool_exp!]
  id: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.type"
"""
enum rangers_type_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  type_pkey
}

"""
input type for inserting data into table "rangers.type"
"""
input rangers_type_insert_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.type_localized"
"""
type rangers_type_localized {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.type_localized"
"""
type rangers_type_localized_aggregate {
  aggregate: rangers_type_localized_aggregate_fields
  nodes: [rangers_type_localized!]!
}

"""
aggregate fields of "rangers.type_localized"
"""
type rangers_type_localized_aggregate_fields {
  count(columns: [rangers_type_localized_select_column!], distinct: Boolean): Int!
  max: rangers_type_localized_max_fields
  min: rangers_type_localized_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.type_localized". All fields are combined with a logical 'AND'.
"""
input rangers_type_localized_bool_exp {
  _and: [rangers_type_localized_bool_exp!]
  _not: rangers_type_localized_bool_exp
  _or: [rangers_type_localized_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  real_name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""aggregate max on columns"""
type rangers_type_localized_max_fields {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_type_localized_min_fields {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""Ordering options when selecting data from "rangers.type_localized"."""
input rangers_type_localized_order_by {
  id: order_by
  locale: order_by
  name: order_by
  real_name: order_by
  updated_at: order_by
}

"""
select columns of table "rangers.type_localized"
"""
enum rangers_type_localized_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  real_name

  """column name"""
  updated_at
}

"""
Streaming cursor of the table "rangers_type_localized"
"""
input rangers_type_localized_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_type_localized_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_type_localized_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  real_name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_type_max_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_type_min_fields {
  id: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.type"
"""
type rangers_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_type!]!
}

"""
on_conflict condition type for table "rangers.type"
"""
input rangers_type_on_conflict {
  constraint: rangers_type_constraint!
  update_columns: [rangers_type_update_column!]! = []
  where: rangers_type_bool_exp
}

"""Ordering options when selecting data from "rangers.type"."""
input rangers_type_order_by {
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.type"""
input rangers_type_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.type"
"""
enum rangers_type_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.type"
"""
input rangers_type_set_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_type"
"""
input rangers_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_type_stream_cursor_value_input {
  id: String
  name: String
  updated_at: timestamptz
}

"""
columns and relationships of "rangers.type_text"
"""
type rangers_type_text {
  id: String!
  locale: String!
  name: String!
  updated_at: timestamptz
}

"""
aggregated selection of "rangers.type_text"
"""
type rangers_type_text_aggregate {
  aggregate: rangers_type_text_aggregate_fields
  nodes: [rangers_type_text!]!
}

"""
aggregate fields of "rangers.type_text"
"""
type rangers_type_text_aggregate_fields {
  count(columns: [rangers_type_text_select_column!], distinct: Boolean): Int!
  max: rangers_type_text_max_fields
  min: rangers_type_text_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.type_text". All fields are combined with a logical 'AND'.
"""
input rangers_type_text_bool_exp {
  _and: [rangers_type_text_bool_exp!]
  _not: rangers_type_text_bool_exp
  _or: [rangers_type_text_bool_exp!]
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.type_text"
"""
enum rangers_type_text_constraint {
  """
  unique or primary key constraint on columns "id", "locale"
  """
  type_text_pkey
}

"""
input type for inserting data into table "rangers.type_text"
"""
input rangers_type_text_insert_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_type_text_max_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_type_text_min_fields {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.type_text"
"""
type rangers_type_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_type_text!]!
}

"""
on_conflict condition type for table "rangers.type_text"
"""
input rangers_type_text_on_conflict {
  constraint: rangers_type_text_constraint!
  update_columns: [rangers_type_text_update_column!]! = []
  where: rangers_type_text_bool_exp
}

"""Ordering options when selecting data from "rangers.type_text"."""
input rangers_type_text_order_by {
  id: order_by
  locale: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.type_text"""
input rangers_type_text_pk_columns_input {
  id: String!
  locale: String!
}

"""
select columns of table "rangers.type_text"
"""
enum rangers_type_text_select_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.type_text"
"""
input rangers_type_text_set_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_type_text"
"""
input rangers_type_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_type_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_type_text_stream_cursor_value_input {
  id: String
  locale: String
  name: String
  updated_at: timestamptz
}

"""
update columns of table "rangers.type_text"
"""
enum rangers_type_text_update_column {
  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_type_text_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_type_text_set_input

  """filter the rows which have to be updated"""
  where: rangers_type_text_bool_exp!
}

"""
update columns of table "rangers.type"
"""
enum rangers_type_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input rangers_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_type_set_input

  """filter the rows which have to be updated"""
  where: rangers_type_bool_exp!
}

input rangers_update_friend_request_args {
  action: String
  target_user_id: String
}

input rangers_upgrade_deck_args {
  deck_id: Int
  upgrade_data: json
}

"""
columns and relationships of "rangers.user_campaign"
"""
type rangers_user_campaign {
  """An object relationship"""
  campaign: rangers_campaign
  campaign_id: Int
  updated_at: timestamptz

  """An object relationship"""
  user: rangers_users
  user_id: String
}

"""
aggregated selection of "rangers.user_campaign"
"""
type rangers_user_campaign_aggregate {
  aggregate: rangers_user_campaign_aggregate_fields
  nodes: [rangers_user_campaign!]!
}

input rangers_user_campaign_aggregate_bool_exp {
  count: rangers_user_campaign_aggregate_bool_exp_count
}

input rangers_user_campaign_aggregate_bool_exp_count {
  arguments: [rangers_user_campaign_select_column!]
  distinct: Boolean
  filter: rangers_user_campaign_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.user_campaign"
"""
type rangers_user_campaign_aggregate_fields {
  avg: rangers_user_campaign_avg_fields
  count(columns: [rangers_user_campaign_select_column!], distinct: Boolean): Int!
  max: rangers_user_campaign_max_fields
  min: rangers_user_campaign_min_fields
  stddev: rangers_user_campaign_stddev_fields
  stddev_pop: rangers_user_campaign_stddev_pop_fields
  stddev_samp: rangers_user_campaign_stddev_samp_fields
  sum: rangers_user_campaign_sum_fields
  var_pop: rangers_user_campaign_var_pop_fields
  var_samp: rangers_user_campaign_var_samp_fields
  variance: rangers_user_campaign_variance_fields
}

"""
order by aggregate values of table "rangers.user_campaign"
"""
input rangers_user_campaign_aggregate_order_by {
  avg: rangers_user_campaign_avg_order_by
  count: order_by
  max: rangers_user_campaign_max_order_by
  min: rangers_user_campaign_min_order_by
  stddev: rangers_user_campaign_stddev_order_by
  stddev_pop: rangers_user_campaign_stddev_pop_order_by
  stddev_samp: rangers_user_campaign_stddev_samp_order_by
  sum: rangers_user_campaign_sum_order_by
  var_pop: rangers_user_campaign_var_pop_order_by
  var_samp: rangers_user_campaign_var_samp_order_by
  variance: rangers_user_campaign_variance_order_by
}

"""
input type for inserting array relation for remote table "rangers.user_campaign"
"""
input rangers_user_campaign_arr_rel_insert_input {
  data: [rangers_user_campaign_insert_input!]!
}

"""aggregate avg on columns"""
type rangers_user_campaign_avg_fields {
  campaign_id: Float
}

"""
order by avg() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_avg_order_by {
  campaign_id: order_by
}

"""
Boolean expression to filter rows from the table "rangers.user_campaign". All fields are combined with a logical 'AND'.
"""
input rangers_user_campaign_bool_exp {
  _and: [rangers_user_campaign_bool_exp!]
  _not: rangers_user_campaign_bool_exp
  _or: [rangers_user_campaign_bool_exp!]
  campaign: rangers_campaign_bool_exp
  campaign_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: rangers_users_bool_exp
  user_id: String_comparison_exp
}

"""
input type for inserting data into table "rangers.user_campaign"
"""
input rangers_user_campaign_insert_input {
  campaign: rangers_campaign_obj_rel_insert_input
  campaign_id: Int
  updated_at: timestamptz
  user: rangers_users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type rangers_user_campaign_max_fields {
  campaign_id: Int
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_max_order_by {
  campaign_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type rangers_user_campaign_min_fields {
  campaign_id: Int
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_min_order_by {
  campaign_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "rangers.user_campaign"."""
input rangers_user_campaign_order_by {
  campaign: rangers_campaign_order_by
  campaign_id: order_by
  updated_at: order_by
  user: rangers_users_order_by
  user_id: order_by
}

"""
select columns of table "rangers.user_campaign"
"""
enum rangers_user_campaign_select_column {
  """column name"""
  campaign_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type rangers_user_campaign_stddev_fields {
  campaign_id: Float
}

"""
order by stddev() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_stddev_order_by {
  campaign_id: order_by
}

"""aggregate stddev_pop on columns"""
type rangers_user_campaign_stddev_pop_fields {
  campaign_id: Float
}

"""
order by stddev_pop() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_stddev_pop_order_by {
  campaign_id: order_by
}

"""aggregate stddev_samp on columns"""
type rangers_user_campaign_stddev_samp_fields {
  campaign_id: Float
}

"""
order by stddev_samp() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_stddev_samp_order_by {
  campaign_id: order_by
}

"""
Streaming cursor of the table "rangers_user_campaign"
"""
input rangers_user_campaign_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_campaign_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_campaign_stream_cursor_value_input {
  campaign_id: Int
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type rangers_user_campaign_sum_fields {
  campaign_id: Int
}

"""
order by sum() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_sum_order_by {
  campaign_id: order_by
}

"""aggregate var_pop on columns"""
type rangers_user_campaign_var_pop_fields {
  campaign_id: Float
}

"""
order by var_pop() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_var_pop_order_by {
  campaign_id: order_by
}

"""aggregate var_samp on columns"""
type rangers_user_campaign_var_samp_fields {
  campaign_id: Float
}

"""
order by var_samp() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_var_samp_order_by {
  campaign_id: order_by
}

"""aggregate variance on columns"""
type rangers_user_campaign_variance_fields {
  campaign_id: Float
}

"""
order by variance() on columns of table "rangers.user_campaign"
"""
input rangers_user_campaign_variance_order_by {
  campaign_id: order_by
}

"""
columns and relationships of "rangers.user_friends"
"""
type rangers_user_friends {
  status: String

  """An object relationship"""
  user: rangers_users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "rangers.user_friends"
"""
type rangers_user_friends_aggregate {
  aggregate: rangers_user_friends_aggregate_fields
  nodes: [rangers_user_friends!]!
}

input rangers_user_friends_aggregate_bool_exp {
  count: rangers_user_friends_aggregate_bool_exp_count
}

input rangers_user_friends_aggregate_bool_exp_count {
  arguments: [rangers_user_friends_select_column!]
  distinct: Boolean
  filter: rangers_user_friends_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.user_friends"
"""
type rangers_user_friends_aggregate_fields {
  count(columns: [rangers_user_friends_select_column!], distinct: Boolean): Int!
  max: rangers_user_friends_max_fields
  min: rangers_user_friends_min_fields
}

"""
order by aggregate values of table "rangers.user_friends"
"""
input rangers_user_friends_aggregate_order_by {
  count: order_by
  max: rangers_user_friends_max_order_by
  min: rangers_user_friends_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.user_friends"
"""
input rangers_user_friends_arr_rel_insert_input {
  data: [rangers_user_friends_insert_input!]!
}

"""
Boolean expression to filter rows from the table "rangers.user_friends". All fields are combined with a logical 'AND'.
"""
input rangers_user_friends_bool_exp {
  _and: [rangers_user_friends_bool_exp!]
  _not: rangers_user_friends_bool_exp
  _or: [rangers_user_friends_bool_exp!]
  status: String_comparison_exp
  user: rangers_users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "rangers.user_friends"
"""
input rangers_user_friends_insert_input {
  status: String
  user: rangers_users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type rangers_user_friends_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "rangers.user_friends"
"""
input rangers_user_friends_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type rangers_user_friends_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "rangers.user_friends"
"""
input rangers_user_friends_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "rangers.user_friends"
"""
type rangers_user_friends_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_user_friends!]!
}

"""Ordering options when selecting data from "rangers.user_friends"."""
input rangers_user_friends_order_by {
  status: order_by
  user: rangers_users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "rangers.user_friends"
"""
enum rangers_user_friends_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "rangers.user_friends"
"""
input rangers_user_friends_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "rangers_user_friends"
"""
input rangers_user_friends_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_friends_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_friends_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input rangers_user_friends_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_user_friends_set_input

  """filter the rows which have to be updated"""
  where: rangers_user_friends_bool_exp!
}

"""
columns and relationships of "rangers.user_received_friend_requests"
"""
type rangers_user_received_friend_requests {
  status: String

  """An object relationship"""
  user: rangers_users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "rangers.user_received_friend_requests"
"""
type rangers_user_received_friend_requests_aggregate {
  aggregate: rangers_user_received_friend_requests_aggregate_fields
  nodes: [rangers_user_received_friend_requests!]!
}

input rangers_user_received_friend_requests_aggregate_bool_exp {
  count: rangers_user_received_friend_requests_aggregate_bool_exp_count
}

input rangers_user_received_friend_requests_aggregate_bool_exp_count {
  arguments: [rangers_user_received_friend_requests_select_column!]
  distinct: Boolean
  filter: rangers_user_received_friend_requests_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.user_received_friend_requests"
"""
type rangers_user_received_friend_requests_aggregate_fields {
  count(columns: [rangers_user_received_friend_requests_select_column!], distinct: Boolean): Int!
  max: rangers_user_received_friend_requests_max_fields
  min: rangers_user_received_friend_requests_min_fields
}

"""
order by aggregate values of table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_aggregate_order_by {
  count: order_by
  max: rangers_user_received_friend_requests_max_order_by
  min: rangers_user_received_friend_requests_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_arr_rel_insert_input {
  data: [rangers_user_received_friend_requests_insert_input!]!
}

"""
Boolean expression to filter rows from the table "rangers.user_received_friend_requests". All fields are combined with a logical 'AND'.
"""
input rangers_user_received_friend_requests_bool_exp {
  _and: [rangers_user_received_friend_requests_bool_exp!]
  _not: rangers_user_received_friend_requests_bool_exp
  _or: [rangers_user_received_friend_requests_bool_exp!]
  status: String_comparison_exp
  user: rangers_users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_insert_input {
  status: String
  user: rangers_users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type rangers_user_received_friend_requests_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type rangers_user_received_friend_requests_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "rangers.user_received_friend_requests"
"""
type rangers_user_received_friend_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_user_received_friend_requests!]!
}

"""
Ordering options when selecting data from "rangers.user_received_friend_requests".
"""
input rangers_user_received_friend_requests_order_by {
  status: order_by
  user: rangers_users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "rangers.user_received_friend_requests"
"""
enum rangers_user_received_friend_requests_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "rangers.user_received_friend_requests"
"""
input rangers_user_received_friend_requests_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "rangers_user_received_friend_requests"
"""
input rangers_user_received_friend_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_received_friend_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_received_friend_requests_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input rangers_user_received_friend_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_user_received_friend_requests_set_input

  """filter the rows which have to be updated"""
  where: rangers_user_received_friend_requests_bool_exp!
}

"""
columns and relationships of "rangers.user_role"
"""
type rangers_user_role {
  id: String!
}

"""
aggregated selection of "rangers.user_role"
"""
type rangers_user_role_aggregate {
  aggregate: rangers_user_role_aggregate_fields
  nodes: [rangers_user_role!]!
}

"""
aggregate fields of "rangers.user_role"
"""
type rangers_user_role_aggregate_fields {
  count(columns: [rangers_user_role_select_column!], distinct: Boolean): Int!
  max: rangers_user_role_max_fields
  min: rangers_user_role_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.user_role". All fields are combined with a logical 'AND'.
"""
input rangers_user_role_bool_exp {
  _and: [rangers_user_role_bool_exp!]
  _not: rangers_user_role_bool_exp
  _or: [rangers_user_role_bool_exp!]
  id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.user_role"
"""
enum rangers_user_role_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_role_pkey
}

enum rangers_user_role_enum {
  admin
  moderator
}

"""
Boolean expression to compare columns of type "rangers_user_role_enum". All fields are combined with logical 'AND'.
"""
input rangers_user_role_enum_comparison_exp {
  _eq: rangers_user_role_enum
  _in: [rangers_user_role_enum!]
  _is_null: Boolean
  _neq: rangers_user_role_enum
  _nin: [rangers_user_role_enum!]
}

"""
input type for inserting data into table "rangers.user_role"
"""
input rangers_user_role_insert_input {
  id: String
}

"""aggregate max on columns"""
type rangers_user_role_max_fields {
  id: String
}

"""aggregate min on columns"""
type rangers_user_role_min_fields {
  id: String
}

"""
response of any mutation on the table "rangers.user_role"
"""
type rangers_user_role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_user_role!]!
}

"""
on_conflict condition type for table "rangers.user_role"
"""
input rangers_user_role_on_conflict {
  constraint: rangers_user_role_constraint!
  update_columns: [rangers_user_role_update_column!]! = []
  where: rangers_user_role_bool_exp
}

"""Ordering options when selecting data from "rangers.user_role"."""
input rangers_user_role_order_by {
  id: order_by
}

"""primary key columns input for table: rangers.user_role"""
input rangers_user_role_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.user_role"
"""
enum rangers_user_role_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "rangers.user_role"
"""
input rangers_user_role_set_input {
  id: String
}

"""
Streaming cursor of the table "rangers_user_role"
"""
input rangers_user_role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_role_stream_cursor_value_input {
  id: String
}

"""
update columns of table "rangers.user_role"
"""
enum rangers_user_role_update_column {
  """column name"""
  id
}

input rangers_user_role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_user_role_set_input

  """filter the rows which have to be updated"""
  where: rangers_user_role_bool_exp!
}

"""
columns and relationships of "rangers.user_sent_friend_requests"
"""
type rangers_user_sent_friend_requests {
  status: String

  """An object relationship"""
  user: rangers_users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "rangers.user_sent_friend_requests"
"""
type rangers_user_sent_friend_requests_aggregate {
  aggregate: rangers_user_sent_friend_requests_aggregate_fields
  nodes: [rangers_user_sent_friend_requests!]!
}

input rangers_user_sent_friend_requests_aggregate_bool_exp {
  count: rangers_user_sent_friend_requests_aggregate_bool_exp_count
}

input rangers_user_sent_friend_requests_aggregate_bool_exp_count {
  arguments: [rangers_user_sent_friend_requests_select_column!]
  distinct: Boolean
  filter: rangers_user_sent_friend_requests_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "rangers.user_sent_friend_requests"
"""
type rangers_user_sent_friend_requests_aggregate_fields {
  count(columns: [rangers_user_sent_friend_requests_select_column!], distinct: Boolean): Int!
  max: rangers_user_sent_friend_requests_max_fields
  min: rangers_user_sent_friend_requests_min_fields
}

"""
order by aggregate values of table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_aggregate_order_by {
  count: order_by
  max: rangers_user_sent_friend_requests_max_order_by
  min: rangers_user_sent_friend_requests_min_order_by
}

"""
input type for inserting array relation for remote table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_arr_rel_insert_input {
  data: [rangers_user_sent_friend_requests_insert_input!]!
}

"""
Boolean expression to filter rows from the table "rangers.user_sent_friend_requests". All fields are combined with a logical 'AND'.
"""
input rangers_user_sent_friend_requests_bool_exp {
  _and: [rangers_user_sent_friend_requests_bool_exp!]
  _not: rangers_user_sent_friend_requests_bool_exp
  _or: [rangers_user_sent_friend_requests_bool_exp!]
  status: String_comparison_exp
  user: rangers_users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_insert_input {
  status: String
  user: rangers_users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type rangers_user_sent_friend_requests_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type rangers_user_sent_friend_requests_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "rangers.user_sent_friend_requests"
"""
type rangers_user_sent_friend_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_user_sent_friend_requests!]!
}

"""
Ordering options when selecting data from "rangers.user_sent_friend_requests".
"""
input rangers_user_sent_friend_requests_order_by {
  status: order_by
  user: rangers_users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "rangers.user_sent_friend_requests"
"""
enum rangers_user_sent_friend_requests_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "rangers.user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "rangers_user_sent_friend_requests"
"""
input rangers_user_sent_friend_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_sent_friend_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_sent_friend_requests_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input rangers_user_sent_friend_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_user_sent_friend_requests_set_input

  """filter the rows which have to be updated"""
  where: rangers_user_sent_friend_requests_bool_exp!
}

"""
columns and relationships of "rangers.user_settings"
"""
type rangers_user_settings {
  adhere_taboos: Boolean
  pack_collection(
    """JSON select path"""
    path: String
  ): jsonb
  private_decks: Boolean!
  user_id: String!
}

"""
aggregated selection of "rangers.user_settings"
"""
type rangers_user_settings_aggregate {
  aggregate: rangers_user_settings_aggregate_fields
  nodes: [rangers_user_settings!]!
}

"""
aggregate fields of "rangers.user_settings"
"""
type rangers_user_settings_aggregate_fields {
  count(columns: [rangers_user_settings_select_column!], distinct: Boolean): Int!
  max: rangers_user_settings_max_fields
  min: rangers_user_settings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rangers_user_settings_append_input {
  pack_collection: jsonb
}

"""
Boolean expression to filter rows from the table "rangers.user_settings". All fields are combined with a logical 'AND'.
"""
input rangers_user_settings_bool_exp {
  _and: [rangers_user_settings_bool_exp!]
  _not: rangers_user_settings_bool_exp
  _or: [rangers_user_settings_bool_exp!]
  adhere_taboos: Boolean_comparison_exp
  pack_collection: jsonb_comparison_exp
  private_decks: Boolean_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "rangers.user_settings"
"""
enum rangers_user_settings_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  user_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rangers_user_settings_delete_at_path_input {
  pack_collection: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rangers_user_settings_delete_elem_input {
  pack_collection: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rangers_user_settings_delete_key_input {
  pack_collection: String
}

"""
input type for inserting data into table "rangers.user_settings"
"""
input rangers_user_settings_insert_input {
  adhere_taboos: Boolean
  pack_collection: jsonb
  private_decks: Boolean
  user_id: String
}

"""aggregate max on columns"""
type rangers_user_settings_max_fields {
  user_id: String
}

"""aggregate min on columns"""
type rangers_user_settings_min_fields {
  user_id: String
}

"""
response of any mutation on the table "rangers.user_settings"
"""
type rangers_user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_user_settings!]!
}

"""
input type for inserting object relation for remote table "rangers.user_settings"
"""
input rangers_user_settings_obj_rel_insert_input {
  data: rangers_user_settings_insert_input!

  """upsert condition"""
  on_conflict: rangers_user_settings_on_conflict
}

"""
on_conflict condition type for table "rangers.user_settings"
"""
input rangers_user_settings_on_conflict {
  constraint: rangers_user_settings_constraint!
  update_columns: [rangers_user_settings_update_column!]! = []
  where: rangers_user_settings_bool_exp
}

"""Ordering options when selecting data from "rangers.user_settings"."""
input rangers_user_settings_order_by {
  adhere_taboos: order_by
  pack_collection: order_by
  private_decks: order_by
  user_id: order_by
}

"""primary key columns input for table: rangers.user_settings"""
input rangers_user_settings_pk_columns_input {
  user_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rangers_user_settings_prepend_input {
  pack_collection: jsonb
}

"""
select columns of table "rangers.user_settings"
"""
enum rangers_user_settings_select_column {
  """column name"""
  adhere_taboos

  """column name"""
  pack_collection

  """column name"""
  private_decks

  """column name"""
  user_id
}

"""
input type for updating data in table "rangers.user_settings"
"""
input rangers_user_settings_set_input {
  adhere_taboos: Boolean
  pack_collection: jsonb
  private_decks: Boolean
  user_id: String
}

"""
Streaming cursor of the table "rangers_user_settings"
"""
input rangers_user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_user_settings_stream_cursor_value_input {
  adhere_taboos: Boolean
  pack_collection: jsonb
  private_decks: Boolean
  user_id: String
}

"""
update columns of table "rangers.user_settings"
"""
enum rangers_user_settings_update_column {
  """column name"""
  adhere_taboos

  """column name"""
  pack_collection

  """column name"""
  private_decks

  """column name"""
  user_id
}

input rangers_user_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rangers_user_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: rangers_user_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: rangers_user_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: rangers_user_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rangers_user_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: rangers_user_settings_set_input

  """filter the rows which have to be updated"""
  where: rangers_user_settings_bool_exp!
}

"""
columns and relationships of "rangers.users"
"""
type rangers_users {
  """An array relationship"""
  campaigns(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): [rangers_user_campaign!]!

  """An aggregate relationship"""
  campaigns_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): rangers_user_campaign_aggregate!
  created_at: timestamptz!

  """An array relationship"""
  friends(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): [rangers_user_friends!]!

  """An aggregate relationship"""
  friends_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): rangers_user_friends_aggregate!
  handle: String
  id: String!
  normalized_handle: String

  """An array relationship"""
  received_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): [rangers_user_received_friend_requests!]!

  """An aggregate relationship"""
  received_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): rangers_user_received_friend_requests_aggregate!
  role: rangers_user_role_enum

  """An array relationship"""
  sent_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): [rangers_user_sent_friend_requests!]!

  """An aggregate relationship"""
  sent_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): rangers_user_sent_friend_requests_aggregate!

  """An object relationship"""
  settings: rangers_user_settings
  updated_at: timestamptz!
}

"""
aggregated selection of "rangers.users"
"""
type rangers_users_aggregate {
  aggregate: rangers_users_aggregate_fields
  nodes: [rangers_users!]!
}

"""
aggregate fields of "rangers.users"
"""
type rangers_users_aggregate_fields {
  count(columns: [rangers_users_select_column!], distinct: Boolean): Int!
  max: rangers_users_max_fields
  min: rangers_users_min_fields
}

"""
Boolean expression to filter rows from the table "rangers.users". All fields are combined with a logical 'AND'.
"""
input rangers_users_bool_exp {
  _and: [rangers_users_bool_exp!]
  _not: rangers_users_bool_exp
  _or: [rangers_users_bool_exp!]
  campaigns: rangers_user_campaign_bool_exp
  campaigns_aggregate: rangers_user_campaign_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  friends: rangers_user_friends_bool_exp
  friends_aggregate: rangers_user_friends_aggregate_bool_exp
  handle: String_comparison_exp
  id: String_comparison_exp
  normalized_handle: String_comparison_exp
  received_requests: rangers_user_received_friend_requests_bool_exp
  received_requests_aggregate: rangers_user_received_friend_requests_aggregate_bool_exp
  role: rangers_user_role_enum_comparison_exp
  sent_requests: rangers_user_sent_friend_requests_bool_exp
  sent_requests_aggregate: rangers_user_sent_friend_requests_aggregate_bool_exp
  settings: rangers_user_settings_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rangers.users"
"""
enum rangers_users_constraint {
  """
  unique or primary key constraint on columns "normalized_handle"
  """
  users_normalized_handle_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "rangers.users"
"""
input rangers_users_insert_input {
  campaigns: rangers_user_campaign_arr_rel_insert_input
  created_at: timestamptz
  friends: rangers_user_friends_arr_rel_insert_input
  handle: String
  id: String
  normalized_handle: String
  received_requests: rangers_user_received_friend_requests_arr_rel_insert_input
  role: rangers_user_role_enum
  sent_requests: rangers_user_sent_friend_requests_arr_rel_insert_input
  settings: rangers_user_settings_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type rangers_users_max_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type rangers_users_min_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "rangers.users"
"""
type rangers_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rangers_users!]!
}

"""
input type for inserting object relation for remote table "rangers.users"
"""
input rangers_users_obj_rel_insert_input {
  data: rangers_users_insert_input!

  """upsert condition"""
  on_conflict: rangers_users_on_conflict
}

"""
on_conflict condition type for table "rangers.users"
"""
input rangers_users_on_conflict {
  constraint: rangers_users_constraint!
  update_columns: [rangers_users_update_column!]! = []
  where: rangers_users_bool_exp
}

"""Ordering options when selecting data from "rangers.users"."""
input rangers_users_order_by {
  campaigns_aggregate: rangers_user_campaign_aggregate_order_by
  created_at: order_by
  friends_aggregate: rangers_user_friends_aggregate_order_by
  handle: order_by
  id: order_by
  normalized_handle: order_by
  received_requests_aggregate: rangers_user_received_friend_requests_aggregate_order_by
  role: order_by
  sent_requests_aggregate: rangers_user_sent_friend_requests_aggregate_order_by
  settings: rangers_user_settings_order_by
  updated_at: order_by
}

"""primary key columns input for table: rangers.users"""
input rangers_users_pk_columns_input {
  id: String!
}

"""
select columns of table "rangers.users"
"""
enum rangers_users_select_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  role

  """column name"""
  updated_at
}

"""
input type for updating data in table "rangers.users"
"""
input rangers_users_set_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  role: rangers_user_role_enum
  updated_at: timestamptz
}

"""
Streaming cursor of the table "rangers_users"
"""
input rangers_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: rangers_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input rangers_users_stream_cursor_value_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  role: rangers_user_role_enum
  updated_at: timestamptz
}

"""
update columns of table "rangers.users"
"""
enum rangers_users_update_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  role

  """column name"""
  updated_at
}

input rangers_users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: rangers_users_set_input

  """filter the rows which have to be updated"""
  where: rangers_users_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "all_card"
  """
  all_card(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """
  fetch aggregated fields from the table: "all_card"
  """
  all_card_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): all_card_aggregate!

  """fetch data from the table: "all_card" using primary key columns"""
  all_card_by_pk(id: String!): all_card

  """
  fetch data from the table in a streaming manner: "all_card"
  """
  all_card_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [all_card_stream_cursor_input]!

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """
  fetch data from the table: "all_card_text"
  """
  all_card_text(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): [all_card_text!]!

  """
  fetch aggregated fields from the table: "all_card_text"
  """
  all_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_text_order_by!]

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): all_card_text_aggregate!

  """fetch data from the table: "all_card_text" using primary key columns"""
  all_card_text_by_pk(id: String!, locale: String!): all_card_text

  """
  fetch data from the table in a streaming manner: "all_card_text"
  """
  all_card_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [all_card_text_stream_cursor_input]!

    """filter the rows returned"""
    where: all_card_text_bool_exp
  ): [all_card_text!]!

  """
  fetch data from the table: "all_card_updated"
  """
  all_card_updated(
    """distinct select on columns"""
    distinct_on: [all_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_order_by!]

    """filter the rows returned"""
    where: all_card_updated_bool_exp
  ): [all_card_updated!]!

  """
  fetch aggregated fields from the table: "all_card_updated"
  """
  all_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_order_by!]

    """filter the rows returned"""
    where: all_card_updated_bool_exp
  ): all_card_updated_aggregate!

  """
  fetch data from the table: "all_card_updated" using primary key columns
  """
  all_card_updated_by_pk(locale: String!): all_card_updated

  """
  fetch data from the table: "all_card_updated_by_version"
  """
  all_card_updated_by_version(
    """distinct select on columns"""
    distinct_on: [all_card_updated_by_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_by_version_order_by!]

    """filter the rows returned"""
    where: all_card_updated_by_version_bool_exp
  ): [all_card_updated_by_version!]!

  """
  fetch aggregated fields from the table: "all_card_updated_by_version"
  """
  all_card_updated_by_version_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_updated_by_version_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_updated_by_version_order_by!]

    """filter the rows returned"""
    where: all_card_updated_by_version_bool_exp
  ): all_card_updated_by_version_aggregate!

  """
  fetch data from the table: "all_card_updated_by_version" using primary key columns
  """
  all_card_updated_by_version_by_pk(locale: String!, version: Int!): all_card_updated_by_version

  """
  fetch data from the table in a streaming manner: "all_card_updated_by_version"
  """
  all_card_updated_by_version_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [all_card_updated_by_version_stream_cursor_input]!

    """filter the rows returned"""
    where: all_card_updated_by_version_bool_exp
  ): [all_card_updated_by_version!]!

  """
  fetch data from the table in a streaming manner: "all_card_updated"
  """
  all_card_updated_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [all_card_updated_stream_cursor_input]!

    """filter the rows returned"""
    where: all_card_updated_bool_exp
  ): [all_card_updated!]!

  """
  fetch data from the table: "arkhamdb_auth"
  """
  arkhamdb_auth(
    """distinct select on columns"""
    distinct_on: [arkhamdb_auth_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_auth_order_by!]

    """filter the rows returned"""
    where: arkhamdb_auth_bool_exp
  ): [arkhamdb_auth!]!

  """
  fetch aggregated fields from the table: "arkhamdb_auth"
  """
  arkhamdb_auth_aggregate(
    """distinct select on columns"""
    distinct_on: [arkhamdb_auth_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_auth_order_by!]

    """filter the rows returned"""
    where: arkhamdb_auth_bool_exp
  ): arkhamdb_auth_aggregate!

  """fetch data from the table: "arkhamdb_auth" using primary key columns"""
  arkhamdb_auth_by_pk(user_id: String!): arkhamdb_auth

  """
  fetch data from the table in a streaming manner: "arkhamdb_auth"
  """
  arkhamdb_auth_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [arkhamdb_auth_stream_cursor_input]!

    """filter the rows returned"""
    where: arkhamdb_auth_bool_exp
  ): [arkhamdb_auth!]!

  """
  fetch data from the table: "arkhamdb_deck"
  """
  arkhamdb_deck(
    """distinct select on columns"""
    distinct_on: [arkhamdb_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_deck_order_by!]

    """filter the rows returned"""
    where: arkhamdb_deck_bool_exp
  ): [arkhamdb_deck!]!

  """
  fetch aggregated fields from the table: "arkhamdb_deck"
  """
  arkhamdb_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [arkhamdb_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [arkhamdb_deck_order_by!]

    """filter the rows returned"""
    where: arkhamdb_deck_bool_exp
  ): arkhamdb_deck_aggregate!

  """fetch data from the table: "arkhamdb_deck" using primary key columns"""
  arkhamdb_deck_by_pk(id: Int!): arkhamdb_deck

  """
  fetch data from the table in a streaming manner: "arkhamdb_deck"
  """
  arkhamdb_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [arkhamdb_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: arkhamdb_deck_bool_exp
  ): [arkhamdb_deck!]!

  """An array relationship"""
  base_decks(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): [base_decks!]!

  """An aggregate relationship"""
  base_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [base_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [base_decks_order_by!]

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): base_decks_aggregate!

  """
  fetch data from the table in a streaming manner: "base_decks"
  """
  base_decks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [base_decks_stream_cursor_input]!

    """filter the rows returned"""
    where: base_decks_bool_exp
  ): [base_decks!]!

  """
  fetch data from the table: "campaign"
  """
  campaign(
    """distinct select on columns"""
    distinct_on: [campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_order_by!]

    """filter the rows returned"""
    where: campaign_bool_exp
  ): [campaign!]!

  """
  fetch data from the table: "campaign_access"
  """
  campaign_access(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): [campaign_access!]!

  """
  fetch aggregated fields from the table: "campaign_access"
  """
  campaign_access_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_access_order_by!]

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): campaign_access_aggregate!

  """fetch data from the table: "campaign_access" using primary key columns"""
  campaign_access_by_pk(id: Int!): campaign_access

  """
  fetch data from the table in a streaming manner: "campaign_access"
  """
  campaign_access_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_access_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_access_bool_exp
  ): [campaign_access!]!

  """
  fetch aggregated fields from the table: "campaign"
  """
  campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_order_by!]

    """filter the rows returned"""
    where: campaign_bool_exp
  ): campaign_aggregate!

  """fetch data from the table: "campaign" using primary key columns"""
  campaign_by_pk(id: Int!): campaign

  """
  fetch data from the table: "campaign_deck"
  """
  campaign_deck(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """
  fetch aggregated fields from the table: "campaign_deck"
  """
  campaign_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): campaign_deck_aggregate!

  """fetch data from the table: "campaign_deck" using primary key columns"""
  campaign_deck_by_pk(id: Int!): campaign_deck

  """
  fetch data from the table in a streaming manner: "campaign_deck"
  """
  campaign_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """
  fetch data from the table: "campaign_difficulty"
  """
  campaign_difficulty(
    """distinct select on columns"""
    distinct_on: [campaign_difficulty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_difficulty_order_by!]

    """filter the rows returned"""
    where: campaign_difficulty_bool_exp
  ): [campaign_difficulty!]!

  """
  fetch aggregated fields from the table: "campaign_difficulty"
  """
  campaign_difficulty_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_difficulty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_difficulty_order_by!]

    """filter the rows returned"""
    where: campaign_difficulty_bool_exp
  ): campaign_difficulty_aggregate!

  """
  fetch data from the table: "campaign_difficulty" using primary key columns
  """
  campaign_difficulty_by_pk(value: String!): campaign_difficulty

  """
  fetch data from the table in a streaming manner: "campaign_difficulty"
  """
  campaign_difficulty_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_difficulty_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_difficulty_bool_exp
  ): [campaign_difficulty!]!

  """
  fetch data from the table: "campaign_guide"
  """
  campaign_guide(
    """distinct select on columns"""
    distinct_on: [campaign_guide_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_guide_order_by!]

    """filter the rows returned"""
    where: campaign_guide_bool_exp
  ): [campaign_guide!]!

  """
  fetch aggregated fields from the table: "campaign_guide"
  """
  campaign_guide_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_guide_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_guide_order_by!]

    """filter the rows returned"""
    where: campaign_guide_bool_exp
  ): campaign_guide_aggregate!

  """
  fetch data from the table in a streaming manner: "campaign_guide"
  """
  campaign_guide_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_guide_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_guide_bool_exp
  ): [campaign_guide!]!

  """
  fetch data from the table: "campaign_investigator"
  """
  campaign_investigator(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): [campaign_investigator!]!

  """
  fetch aggregated fields from the table: "campaign_investigator"
  """
  campaign_investigator_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_investigator_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_investigator_order_by!]

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): campaign_investigator_aggregate!

  """
  fetch data from the table: "campaign_investigator" using primary key columns
  """
  campaign_investigator_by_pk(campaign_id: Int!, investigator: String!): campaign_investigator

  """
  fetch data from the table in a streaming manner: "campaign_investigator"
  """
  campaign_investigator_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_investigator_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_investigator_bool_exp
  ): [campaign_investigator!]!

  """
  fetch data from the table in a streaming manner: "campaign"
  """
  campaign_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaign_stream_cursor_input]!

    """filter the rows returned"""
    where: campaign_bool_exp
  ): [campaign!]!

  """
  fetch data from the table: "campaigns_by_cycle"
  """
  campaigns_by_cycle(
    """distinct select on columns"""
    distinct_on: [campaigns_by_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaigns_by_cycle_order_by!]

    """filter the rows returned"""
    where: campaigns_by_cycle_bool_exp
  ): [campaigns_by_cycle!]!

  """
  fetch aggregated fields from the table: "campaigns_by_cycle"
  """
  campaigns_by_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [campaigns_by_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaigns_by_cycle_order_by!]

    """filter the rows returned"""
    where: campaigns_by_cycle_bool_exp
  ): campaigns_by_cycle_aggregate!

  """
  fetch data from the table in a streaming manner: "campaigns_by_cycle"
  """
  campaigns_by_cycle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [campaigns_by_cycle_stream_cursor_input]!

    """filter the rows returned"""
    where: campaigns_by_cycle_bool_exp
  ): [campaigns_by_cycle!]!

  """
  fetch data from the table: "card"
  """
  card(
    """distinct select on columns"""
    distinct_on: [card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_order_by!]

    """filter the rows returned"""
    where: card_bool_exp
  ): [card!]!

  """
  fetch aggregated fields from the table: "card"
  """
  card_aggregate(
    """distinct select on columns"""
    distinct_on: [card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_order_by!]

    """filter the rows returned"""
    where: card_bool_exp
  ): card_aggregate!

  """fetch data from the table: "card" using primary key columns"""
  card_by_pk(code: String!): card

  """
  fetch data from the table: "card_cycle"
  """
  card_cycle(
    """distinct select on columns"""
    distinct_on: [card_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_cycle_order_by!]

    """filter the rows returned"""
    where: card_cycle_bool_exp
  ): [card_cycle!]!

  """
  fetch aggregated fields from the table: "card_cycle"
  """
  card_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [card_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_cycle_order_by!]

    """filter the rows returned"""
    where: card_cycle_bool_exp
  ): card_cycle_aggregate!

  """fetch data from the table: "card_cycle" using primary key columns"""
  card_cycle_by_pk(code: String!, locale: String!): card_cycle

  """
  fetch data from the table in a streaming manner: "card_cycle"
  """
  card_cycle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_cycle_stream_cursor_input]!

    """filter the rows returned"""
    where: card_cycle_bool_exp
  ): [card_cycle!]!

  """
  fetch data from the table: "card_encounter_set"
  """
  card_encounter_set(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): [card_encounter_set!]!

  """
  fetch aggregated fields from the table: "card_encounter_set"
  """
  card_encounter_set_aggregate(
    """distinct select on columns"""
    distinct_on: [card_encounter_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_encounter_set_order_by!]

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): card_encounter_set_aggregate!

  """
  fetch data from the table: "card_encounter_set" using primary key columns
  """
  card_encounter_set_by_pk(code: String!, locale: String!): card_encounter_set

  """
  fetch data from the table in a streaming manner: "card_encounter_set"
  """
  card_encounter_set_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_encounter_set_stream_cursor_input]!

    """filter the rows returned"""
    where: card_encounter_set_bool_exp
  ): [card_encounter_set!]!

  """
  fetch data from the table: "card_pack"
  """
  card_pack(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """
  fetch aggregated fields from the table: "card_pack"
  """
  card_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [card_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_pack_order_by!]

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): card_pack_aggregate!

  """fetch data from the table: "card_pack" using primary key columns"""
  card_pack_by_pk(code: String!, locale: String!): card_pack

  """
  fetch data from the table in a streaming manner: "card_pack"
  """
  card_pack_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_pack_stream_cursor_input]!

    """filter the rows returned"""
    where: card_pack_bool_exp
  ): [card_pack!]!

  """
  fetch data from the table in a streaming manner: "card"
  """
  card_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_stream_cursor_input]!

    """filter the rows returned"""
    where: card_bool_exp
  ): [card!]!

  """
  fetch data from the table: "card_subtype_name"
  """
  card_subtype_name(
    """distinct select on columns"""
    distinct_on: [card_subtype_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_subtype_name_order_by!]

    """filter the rows returned"""
    where: card_subtype_name_bool_exp
  ): [card_subtype_name!]!

  """
  fetch aggregated fields from the table: "card_subtype_name"
  """
  card_subtype_name_aggregate(
    """distinct select on columns"""
    distinct_on: [card_subtype_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_subtype_name_order_by!]

    """filter the rows returned"""
    where: card_subtype_name_bool_exp
  ): card_subtype_name_aggregate!

  """
  fetch data from the table: "card_subtype_name" using primary key columns
  """
  card_subtype_name_by_pk(code: String!, locale: String!): card_subtype_name

  """
  fetch data from the table in a streaming manner: "card_subtype_name"
  """
  card_subtype_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_subtype_name_stream_cursor_input]!

    """filter the rows returned"""
    where: card_subtype_name_bool_exp
  ): [card_subtype_name!]!

  """
  fetch data from the table: "card_text"
  """
  card_text(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): [card_text!]!

  """
  fetch aggregated fields from the table: "card_text"
  """
  card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_text_order_by!]

    """filter the rows returned"""
    where: card_text_bool_exp
  ): card_text_aggregate!

  """fetch data from the table: "card_text" using primary key columns"""
  card_text_by_pk(code: String!, locale: String!): card_text

  """
  fetch data from the table in a streaming manner: "card_text"
  """
  card_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_text_stream_cursor_input]!

    """filter the rows returned"""
    where: card_text_bool_exp
  ): [card_text!]!

  """
  fetch data from the table: "card_type_code"
  """
  card_type_code(
    """distinct select on columns"""
    distinct_on: [card_type_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_code_order_by!]

    """filter the rows returned"""
    where: card_type_code_bool_exp
  ): [card_type_code!]!

  """
  fetch aggregated fields from the table: "card_type_code"
  """
  card_type_code_aggregate(
    """distinct select on columns"""
    distinct_on: [card_type_code_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_code_order_by!]

    """filter the rows returned"""
    where: card_type_code_bool_exp
  ): card_type_code_aggregate!

  """fetch data from the table: "card_type_code" using primary key columns"""
  card_type_code_by_pk(code: String!): card_type_code

  """
  fetch data from the table in a streaming manner: "card_type_code"
  """
  card_type_code_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_type_code_stream_cursor_input]!

    """filter the rows returned"""
    where: card_type_code_bool_exp
  ): [card_type_code!]!

  """
  fetch data from the table: "card_type_name"
  """
  card_type_name(
    """distinct select on columns"""
    distinct_on: [card_type_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_name_order_by!]

    """filter the rows returned"""
    where: card_type_name_bool_exp
  ): [card_type_name!]!

  """
  fetch aggregated fields from the table: "card_type_name"
  """
  card_type_name_aggregate(
    """distinct select on columns"""
    distinct_on: [card_type_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [card_type_name_order_by!]

    """filter the rows returned"""
    where: card_type_name_bool_exp
  ): card_type_name_aggregate!

  """fetch data from the table: "card_type_name" using primary key columns"""
  card_type_name_by_pk(code: card_type_code_enum!, locale: String!): card_type_name

  """
  fetch data from the table in a streaming manner: "card_type_name"
  """
  card_type_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [card_type_name_stream_cursor_input]!

    """filter the rows returned"""
    where: card_type_name_bool_exp
  ): [card_type_name!]!

  """An array relationship"""
  chaos_bag_result(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): [chaos_bag_result!]!

  """An aggregate relationship"""
  chaos_bag_result_aggregate(
    """distinct select on columns"""
    distinct_on: [chaos_bag_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_result_order_by!]

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): chaos_bag_result_aggregate!

  """
  fetch data from the table: "chaos_bag_result" using primary key columns
  """
  chaos_bag_result_by_pk(id: Int!): chaos_bag_result

  """
  fetch data from the table in a streaming manner: "chaos_bag_result"
  """
  chaos_bag_result_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chaos_bag_result_stream_cursor_input]!

    """filter the rows returned"""
    where: chaos_bag_result_bool_exp
  ): [chaos_bag_result!]!

  """
  fetch data from the table: "chaos_bag_tarot_mode"
  """
  chaos_bag_tarot_mode(
    """distinct select on columns"""
    distinct_on: [chaos_bag_tarot_mode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_tarot_mode_order_by!]

    """filter the rows returned"""
    where: chaos_bag_tarot_mode_bool_exp
  ): [chaos_bag_tarot_mode!]!

  """
  fetch aggregated fields from the table: "chaos_bag_tarot_mode"
  """
  chaos_bag_tarot_mode_aggregate(
    """distinct select on columns"""
    distinct_on: [chaos_bag_tarot_mode_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chaos_bag_tarot_mode_order_by!]

    """filter the rows returned"""
    where: chaos_bag_tarot_mode_bool_exp
  ): chaos_bag_tarot_mode_aggregate!

  """
  fetch data from the table: "chaos_bag_tarot_mode" using primary key columns
  """
  chaos_bag_tarot_mode_by_pk(value: String!): chaos_bag_tarot_mode

  """
  fetch data from the table in a streaming manner: "chaos_bag_tarot_mode"
  """
  chaos_bag_tarot_mode_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chaos_bag_tarot_mode_stream_cursor_input]!

    """filter the rows returned"""
    where: chaos_bag_tarot_mode_bool_exp
  ): [chaos_bag_tarot_mode!]!

  """
  fetch data from the table: "conquest.card"
  """
  conquest_card(
    """distinct select on columns"""
    distinct_on: [conquest_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_order_by!]

    """filter the rows returned"""
    where: conquest_card_bool_exp
  ): [conquest_card!]!

  """
  fetch aggregated fields from the table: "conquest.card"
  """
  conquest_card_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_order_by!]

    """filter the rows returned"""
    where: conquest_card_bool_exp
  ): conquest_card_aggregate!

  """fetch data from the table: "conquest.card" using primary key columns"""
  conquest_card_by_pk(id: String!): conquest_card

  """
  fetch data from the table: "conquest.card_localized"
  """
  conquest_card_localized(
    """distinct select on columns"""
    distinct_on: [conquest_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_localized_order_by!]

    """filter the rows returned"""
    where: conquest_card_localized_bool_exp
  ): [conquest_card_localized!]!

  """
  fetch aggregated fields from the table: "conquest.card_localized"
  """
  conquest_card_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_localized_order_by!]

    """filter the rows returned"""
    where: conquest_card_localized_bool_exp
  ): conquest_card_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "conquest.card_localized"
  """
  conquest_card_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_card_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_card_localized_bool_exp
  ): [conquest_card_localized!]!

  """
  fetch data from the table in a streaming manner: "conquest.card"
  """
  conquest_card_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_card_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_card_bool_exp
  ): [conquest_card!]!

  """
  fetch data from the table: "conquest.card_text"
  """
  conquest_card_text(
    """distinct select on columns"""
    distinct_on: [conquest_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_text_order_by!]

    """filter the rows returned"""
    where: conquest_card_text_bool_exp
  ): [conquest_card_text!]!

  """
  fetch aggregated fields from the table: "conquest.card_text"
  """
  conquest_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_text_order_by!]

    """filter the rows returned"""
    where: conquest_card_text_bool_exp
  ): conquest_card_text_aggregate!

  """
  fetch data from the table: "conquest.card_text" using primary key columns
  """
  conquest_card_text_by_pk(id: String!, locale: String!): conquest_card_text

  """
  fetch data from the table in a streaming manner: "conquest.card_text"
  """
  conquest_card_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_card_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_card_text_bool_exp
  ): [conquest_card_text!]!

  """
  fetch data from the table: "conquest.card_updated"
  """
  conquest_card_updated(
    """distinct select on columns"""
    distinct_on: [conquest_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_updated_order_by!]

    """filter the rows returned"""
    where: conquest_card_updated_bool_exp
  ): [conquest_card_updated!]!

  """
  fetch aggregated fields from the table: "conquest.card_updated"
  """
  conquest_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_card_updated_order_by!]

    """filter the rows returned"""
    where: conquest_card_updated_bool_exp
  ): conquest_card_updated_aggregate!

  """
  fetch data from the table in a streaming manner: "conquest.card_updated"
  """
  conquest_card_updated_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_card_updated_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_card_updated_bool_exp
  ): [conquest_card_updated!]!

  """
  fetch data from the table: "conquest.comment"
  """
  conquest_comment(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): [conquest_comment!]!

  """
  fetch aggregated fields from the table: "conquest.comment"
  """
  conquest_comment_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_comment_order_by!]

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): conquest_comment_aggregate!

  """
  fetch data from the table: "conquest.comment" using primary key columns
  """
  conquest_comment_by_pk(id: uuid!): conquest_comment

  """
  fetch data from the table in a streaming manner: "conquest.comment"
  """
  conquest_comment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_comment_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_comment_bool_exp
  ): [conquest_comment!]!

  """
  fetch data from the table: "conquest.cycle"
  """
  conquest_cycle(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_bool_exp
  ): [conquest_cycle!]!

  """
  fetch aggregated fields from the table: "conquest.cycle"
  """
  conquest_cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_bool_exp
  ): conquest_cycle_aggregate!

  """fetch data from the table: "conquest.cycle" using primary key columns"""
  conquest_cycle_by_pk(id: String!): conquest_cycle

  """
  fetch data from the table in a streaming manner: "conquest.cycle"
  """
  conquest_cycle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_cycle_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_cycle_bool_exp
  ): [conquest_cycle!]!

  """
  fetch data from the table: "conquest.cycle_text"
  """
  conquest_cycle_text(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_text_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_text_bool_exp
  ): [conquest_cycle_text!]!

  """
  fetch aggregated fields from the table: "conquest.cycle_text"
  """
  conquest_cycle_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_cycle_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_cycle_text_order_by!]

    """filter the rows returned"""
    where: conquest_cycle_text_bool_exp
  ): conquest_cycle_text_aggregate!

  """
  fetch data from the table: "conquest.cycle_text" using primary key columns
  """
  conquest_cycle_text_by_pk(id: String!, locale: String!): conquest_cycle_text

  """
  fetch data from the table in a streaming manner: "conquest.cycle_text"
  """
  conquest_cycle_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_cycle_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_cycle_text_bool_exp
  ): [conquest_cycle_text!]!

  """
  fetch data from the table: "conquest.deck"
  """
  conquest_deck(
    """distinct select on columns"""
    distinct_on: [conquest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_order_by!]

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): [conquest_deck!]!

  """
  fetch aggregated fields from the table: "conquest.deck"
  """
  conquest_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_order_by!]

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): conquest_deck_aggregate!

  """fetch data from the table: "conquest.deck" using primary key columns"""
  conquest_deck_by_pk(id: Int!): conquest_deck

  """
  fetch data from the table: "conquest.deck_copy"
  """
  conquest_deck_copy(
    """distinct select on columns"""
    distinct_on: [conquest_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_copy_order_by!]

    """filter the rows returned"""
    where: conquest_deck_copy_bool_exp
  ): [conquest_deck_copy!]!

  """
  fetch aggregated fields from the table: "conquest.deck_copy"
  """
  conquest_deck_copy_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_copy_order_by!]

    """filter the rows returned"""
    where: conquest_deck_copy_bool_exp
  ): conquest_deck_copy_aggregate!

  """
  fetch data from the table: "conquest.deck_copy" using primary key columns
  """
  conquest_deck_copy_by_pk(copy_deck_id: Int!): conquest_deck_copy

  """
  fetch data from the table in a streaming manner: "conquest.deck_copy"
  """
  conquest_deck_copy_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_deck_copy_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_deck_copy_bool_exp
  ): [conquest_deck_copy!]!

  """
  fetch data from the table: "conquest.deck_like"
  """
  conquest_deck_like(
    """distinct select on columns"""
    distinct_on: [conquest_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_like_order_by!]

    """filter the rows returned"""
    where: conquest_deck_like_bool_exp
  ): [conquest_deck_like!]!

  """
  fetch aggregated fields from the table: "conquest.deck_like"
  """
  conquest_deck_like_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_deck_like_order_by!]

    """filter the rows returned"""
    where: conquest_deck_like_bool_exp
  ): conquest_deck_like_aggregate!

  """
  fetch data from the table: "conquest.deck_like" using primary key columns
  """
  conquest_deck_like_by_pk(deck_id: Int!, user_id: String!): conquest_deck_like

  """
  fetch data from the table in a streaming manner: "conquest.deck_like"
  """
  conquest_deck_like_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_deck_like_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_deck_like_bool_exp
  ): [conquest_deck_like!]!

  """
  fetch data from the table in a streaming manner: "conquest.deck"
  """
  conquest_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_deck_bool_exp
  ): [conquest_deck!]!

  """
  fetch data from the table: "conquest.faction"
  """
  conquest_faction(
    """distinct select on columns"""
    distinct_on: [conquest_faction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_order_by!]

    """filter the rows returned"""
    where: conquest_faction_bool_exp
  ): [conquest_faction!]!

  """
  fetch aggregated fields from the table: "conquest.faction"
  """
  conquest_faction_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_faction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_order_by!]

    """filter the rows returned"""
    where: conquest_faction_bool_exp
  ): conquest_faction_aggregate!

  """
  fetch data from the table: "conquest.faction" using primary key columns
  """
  conquest_faction_by_pk(id: String!): conquest_faction

  """
  fetch data from the table in a streaming manner: "conquest.faction"
  """
  conquest_faction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_faction_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_faction_bool_exp
  ): [conquest_faction!]!

  """
  fetch data from the table: "conquest.faction_text"
  """
  conquest_faction_text(
    """distinct select on columns"""
    distinct_on: [conquest_faction_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_text_order_by!]

    """filter the rows returned"""
    where: conquest_faction_text_bool_exp
  ): [conquest_faction_text!]!

  """
  fetch aggregated fields from the table: "conquest.faction_text"
  """
  conquest_faction_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_faction_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_faction_text_order_by!]

    """filter the rows returned"""
    where: conquest_faction_text_bool_exp
  ): conquest_faction_text_aggregate!

  """
  fetch data from the table: "conquest.faction_text" using primary key columns
  """
  conquest_faction_text_by_pk(id: String!, locale: String!): conquest_faction_text

  """
  fetch data from the table in a streaming manner: "conquest.faction_text"
  """
  conquest_faction_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_faction_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_faction_text_bool_exp
  ): [conquest_faction_text!]!

  """
  fetch data from the table: "conquest.loyalty"
  """
  conquest_loyalty(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_bool_exp
  ): [conquest_loyalty!]!

  """
  fetch aggregated fields from the table: "conquest.loyalty"
  """
  conquest_loyalty_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_bool_exp
  ): conquest_loyalty_aggregate!

  """
  fetch data from the table: "conquest.loyalty" using primary key columns
  """
  conquest_loyalty_by_pk(id: String!): conquest_loyalty

  """
  fetch data from the table in a streaming manner: "conquest.loyalty"
  """
  conquest_loyalty_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_loyalty_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_loyalty_bool_exp
  ): [conquest_loyalty!]!

  """
  fetch data from the table: "conquest.loyalty_text"
  """
  conquest_loyalty_text(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_text_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_text_bool_exp
  ): [conquest_loyalty_text!]!

  """
  fetch aggregated fields from the table: "conquest.loyalty_text"
  """
  conquest_loyalty_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_loyalty_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_loyalty_text_order_by!]

    """filter the rows returned"""
    where: conquest_loyalty_text_bool_exp
  ): conquest_loyalty_text_aggregate!

  """
  fetch data from the table: "conquest.loyalty_text" using primary key columns
  """
  conquest_loyalty_text_by_pk(id: String!, locale: String!): conquest_loyalty_text

  """
  fetch data from the table in a streaming manner: "conquest.loyalty_text"
  """
  conquest_loyalty_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_loyalty_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_loyalty_text_bool_exp
  ): [conquest_loyalty_text!]!

  """
  fetch data from the table: "conquest.pack"
  """
  conquest_pack(
    """distinct select on columns"""
    distinct_on: [conquest_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_order_by!]

    """filter the rows returned"""
    where: conquest_pack_bool_exp
  ): [conquest_pack!]!

  """
  fetch aggregated fields from the table: "conquest.pack"
  """
  conquest_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_order_by!]

    """filter the rows returned"""
    where: conquest_pack_bool_exp
  ): conquest_pack_aggregate!

  """fetch data from the table: "conquest.pack" using primary key columns"""
  conquest_pack_by_pk(id: String!): conquest_pack

  """
  fetch data from the table in a streaming manner: "conquest.pack"
  """
  conquest_pack_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_pack_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_pack_bool_exp
  ): [conquest_pack!]!

  """
  fetch data from the table: "conquest.pack_text"
  """
  conquest_pack_text(
    """distinct select on columns"""
    distinct_on: [conquest_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_text_order_by!]

    """filter the rows returned"""
    where: conquest_pack_text_bool_exp
  ): [conquest_pack_text!]!

  """
  fetch aggregated fields from the table: "conquest.pack_text"
  """
  conquest_pack_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_pack_text_order_by!]

    """filter the rows returned"""
    where: conquest_pack_text_bool_exp
  ): conquest_pack_text_aggregate!

  """
  fetch data from the table: "conquest.pack_text" using primary key columns
  """
  conquest_pack_text_by_pk(id: String!, locale: String!): conquest_pack_text

  """
  fetch data from the table in a streaming manner: "conquest.pack_text"
  """
  conquest_pack_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_pack_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_pack_text_bool_exp
  ): [conquest_pack_text!]!

  """
  fetch data from the table: "conquest.type"
  """
  conquest_type(
    """distinct select on columns"""
    distinct_on: [conquest_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_order_by!]

    """filter the rows returned"""
    where: conquest_type_bool_exp
  ): [conquest_type!]!

  """
  fetch aggregated fields from the table: "conquest.type"
  """
  conquest_type_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_order_by!]

    """filter the rows returned"""
    where: conquest_type_bool_exp
  ): conquest_type_aggregate!

  """fetch data from the table: "conquest.type" using primary key columns"""
  conquest_type_by_pk(id: String!): conquest_type

  """
  fetch data from the table in a streaming manner: "conquest.type"
  """
  conquest_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_type_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_type_bool_exp
  ): [conquest_type!]!

  """
  fetch data from the table: "conquest.type_text"
  """
  conquest_type_text(
    """distinct select on columns"""
    distinct_on: [conquest_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_text_order_by!]

    """filter the rows returned"""
    where: conquest_type_text_bool_exp
  ): [conquest_type_text!]!

  """
  fetch aggregated fields from the table: "conquest.type_text"
  """
  conquest_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_type_text_order_by!]

    """filter the rows returned"""
    where: conquest_type_text_bool_exp
  ): conquest_type_text_aggregate!

  """
  fetch data from the table: "conquest.type_text" using primary key columns
  """
  conquest_type_text_by_pk(id: String!, locale: String!): conquest_type_text

  """
  fetch data from the table in a streaming manner: "conquest.type_text"
  """
  conquest_type_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_type_text_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_type_text_bool_exp
  ): [conquest_type_text!]!

  """
  fetch data from the table: "conquest.user_role"
  """
  conquest_user_role(
    """distinct select on columns"""
    distinct_on: [conquest_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_role_order_by!]

    """filter the rows returned"""
    where: conquest_user_role_bool_exp
  ): [conquest_user_role!]!

  """
  fetch aggregated fields from the table: "conquest.user_role"
  """
  conquest_user_role_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_role_order_by!]

    """filter the rows returned"""
    where: conquest_user_role_bool_exp
  ): conquest_user_role_aggregate!

  """
  fetch data from the table: "conquest.user_role" using primary key columns
  """
  conquest_user_role_by_pk(id: String!): conquest_user_role

  """
  fetch data from the table in a streaming manner: "conquest.user_role"
  """
  conquest_user_role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_user_role_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_user_role_bool_exp
  ): [conquest_user_role!]!

  """
  fetch data from the table: "conquest.user_settings"
  """
  conquest_user_settings(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): [conquest_user_settings!]!

  """
  fetch aggregated fields from the table: "conquest.user_settings"
  """
  conquest_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_user_settings_order_by!]

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): conquest_user_settings_aggregate!

  """
  fetch data from the table: "conquest.user_settings" using primary key columns
  """
  conquest_user_settings_by_pk(user_id: String!): conquest_user_settings

  """
  fetch data from the table in a streaming manner: "conquest.user_settings"
  """
  conquest_user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_user_settings_bool_exp
  ): [conquest_user_settings!]!

  """
  fetch data from the table: "conquest.users"
  """
  conquest_users(
    """distinct select on columns"""
    distinct_on: [conquest_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_users_order_by!]

    """filter the rows returned"""
    where: conquest_users_bool_exp
  ): [conquest_users!]!

  """
  fetch aggregated fields from the table: "conquest.users"
  """
  conquest_users_aggregate(
    """distinct select on columns"""
    distinct_on: [conquest_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conquest_users_order_by!]

    """filter the rows returned"""
    where: conquest_users_bool_exp
  ): conquest_users_aggregate!

  """fetch data from the table: "conquest.users" using primary key columns"""
  conquest_users_by_pk(id: String!): conquest_users

  """
  fetch data from the table in a streaming manner: "conquest.users"
  """
  conquest_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conquest_users_stream_cursor_input]!

    """filter the rows returned"""
    where: conquest_users_bool_exp
  ): [conquest_users!]!

  """
  fetch data from the table: "cycle"
  """
  cycle(
    """distinct select on columns"""
    distinct_on: [cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_order_by!]

    """filter the rows returned"""
    where: cycle_bool_exp
  ): [cycle!]!

  """
  fetch aggregated fields from the table: "cycle"
  """
  cycle_aggregate(
    """distinct select on columns"""
    distinct_on: [cycle_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_order_by!]

    """filter the rows returned"""
    where: cycle_bool_exp
  ): cycle_aggregate!

  """fetch data from the table: "cycle" using primary key columns"""
  cycle_by_pk(code: String!): cycle

  """
  fetch data from the table: "cycle_name"
  """
  cycle_name(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): [cycle_name!]!

  """
  fetch aggregated fields from the table: "cycle_name"
  """
  cycle_name_aggregate(
    """distinct select on columns"""
    distinct_on: [cycle_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cycle_name_order_by!]

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): cycle_name_aggregate!

  """fetch data from the table: "cycle_name" using primary key columns"""
  cycle_name_by_pk(code: String!, locale: String!): cycle_name

  """
  fetch data from the table in a streaming manner: "cycle_name"
  """
  cycle_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cycle_name_stream_cursor_input]!

    """filter the rows returned"""
    where: cycle_name_bool_exp
  ): [cycle_name!]!

  """
  fetch data from the table in a streaming manner: "cycle"
  """
  cycle_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cycle_stream_cursor_input]!

    """filter the rows returned"""
    where: cycle_bool_exp
  ): [cycle!]!

  """
  fetch data from the table: "faction_name"
  """
  faction_name(
    """distinct select on columns"""
    distinct_on: [faction_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faction_name_order_by!]

    """filter the rows returned"""
    where: faction_name_bool_exp
  ): [faction_name!]!

  """
  fetch aggregated fields from the table: "faction_name"
  """
  faction_name_aggregate(
    """distinct select on columns"""
    distinct_on: [faction_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faction_name_order_by!]

    """filter the rows returned"""
    where: faction_name_bool_exp
  ): faction_name_aggregate!

  """fetch data from the table: "faction_name" using primary key columns"""
  faction_name_by_pk(code: String!, locale: String!): faction_name

  """
  fetch data from the table in a streaming manner: "faction_name"
  """
  faction_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [faction_name_stream_cursor_input]!

    """filter the rows returned"""
    where: faction_name_bool_exp
  ): [faction_name!]!

  """
  fetch data from the table: "faq"
  """
  faq(
    """distinct select on columns"""
    distinct_on: [faq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_order_by!]

    """filter the rows returned"""
    where: faq_bool_exp
  ): [faq!]!

  """
  fetch aggregated fields from the table: "faq"
  """
  faq_aggregate(
    """distinct select on columns"""
    distinct_on: [faq_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_order_by!]

    """filter the rows returned"""
    where: faq_bool_exp
  ): faq_aggregate!

  """fetch data from the table: "faq" using primary key columns"""
  faq_by_pk(code: String!): faq

  """
  fetch data from the table in a streaming manner: "faq"
  """
  faq_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [faq_stream_cursor_input]!

    """filter the rows returned"""
    where: faq_bool_exp
  ): [faq!]!

  """
  fetch data from the table: "faq_text"
  """
  faq_text(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): [faq_text!]!

  """
  fetch aggregated fields from the table: "faq_text"
  """
  faq_text_aggregate(
    """distinct select on columns"""
    distinct_on: [faq_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [faq_text_order_by!]

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): faq_text_aggregate!

  """fetch data from the table: "faq_text" using primary key columns"""
  faq_text_by_pk(code: String!, locale: String!): faq_text

  """
  fetch data from the table in a streaming manner: "faq_text"
  """
  faq_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [faq_text_stream_cursor_input]!

    """filter the rows returned"""
    where: faq_text_bool_exp
  ): [faq_text!]!

  """
  fetch data from the table: "friend_status"
  """
  friend_status(
    """distinct select on columns"""
    distinct_on: [friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_order_by!]

    """filter the rows returned"""
    where: friend_status_bool_exp
  ): [friend_status!]!

  """
  fetch aggregated fields from the table: "friend_status"
  """
  friend_status_aggregate(
    """distinct select on columns"""
    distinct_on: [friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_order_by!]

    """filter the rows returned"""
    where: friend_status_bool_exp
  ): friend_status_aggregate!

  """fetch data from the table: "friend_status" using primary key columns"""
  friend_status_by_pk(user_id_a: String!, user_id_b: String!): friend_status

  """
  fetch data from the table in a streaming manner: "friend_status"
  """
  friend_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [friend_status_stream_cursor_input]!

    """filter the rows returned"""
    where: friend_status_bool_exp
  ): [friend_status!]!

  """
  fetch data from the table: "friend_status_type"
  """
  friend_status_type(
    """distinct select on columns"""
    distinct_on: [friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_type_order_by!]

    """filter the rows returned"""
    where: friend_status_type_bool_exp
  ): [friend_status_type!]!

  """
  fetch aggregated fields from the table: "friend_status_type"
  """
  friend_status_type_aggregate(
    """distinct select on columns"""
    distinct_on: [friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [friend_status_type_order_by!]

    """filter the rows returned"""
    where: friend_status_type_bool_exp
  ): friend_status_type_aggregate!

  """
  fetch data from the table: "friend_status_type" using primary key columns
  """
  friend_status_type_by_pk(value: String!): friend_status_type

  """
  fetch data from the table in a streaming manner: "friend_status_type"
  """
  friend_status_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [friend_status_type_stream_cursor_input]!

    """filter the rows returned"""
    where: friend_status_type_bool_exp
  ): [friend_status_type!]!

  """
  fetch data from the table: "full_card"
  """
  full_card(
    """distinct select on columns"""
    distinct_on: [full_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_order_by!]

    """filter the rows returned"""
    where: full_card_bool_exp
  ): [full_card!]!

  """
  fetch aggregated fields from the table: "full_card"
  """
  full_card_aggregate(
    """distinct select on columns"""
    distinct_on: [full_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_order_by!]

    """filter the rows returned"""
    where: full_card_bool_exp
  ): full_card_aggregate!

  """fetch data from the table: "full_card" using primary key columns"""
  full_card_by_pk(code: String!): full_card

  """
  fetch data from the table in a streaming manner: "full_card"
  """
  full_card_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [full_card_stream_cursor_input]!

    """filter the rows returned"""
    where: full_card_bool_exp
  ): [full_card!]!

  """
  fetch data from the table: "full_card_text"
  """
  full_card_text(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): [full_card_text!]!

  """
  fetch aggregated fields from the table: "full_card_text"
  """
  full_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [full_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [full_card_text_order_by!]

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): full_card_text_aggregate!

  """fetch data from the table: "full_card_text" using primary key columns"""
  full_card_text_by_pk(code: String!, locale: String!): full_card_text

  """
  fetch data from the table in a streaming manner: "full_card_text"
  """
  full_card_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [full_card_text_stream_cursor_input]!

    """filter the rows returned"""
    where: full_card_text_bool_exp
  ): [full_card_text!]!

  """
  fetch data from the table: "gender"
  """
  gender(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch aggregated fields from the table: "gender"
  """
  gender_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_order_by!]

    """filter the rows returned"""
    where: gender_bool_exp
  ): gender_aggregate!

  """fetch data from the table: "gender" using primary key columns"""
  gender_by_pk(code: String!): gender

  """
  fetch data from the table in a streaming manner: "gender"
  """
  gender_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [gender_stream_cursor_input]!

    """filter the rows returned"""
    where: gender_bool_exp
  ): [gender!]!

  """
  fetch data from the table: "guide_achievement"
  """
  guide_achievement(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): [guide_achievement!]!

  """
  fetch aggregated fields from the table: "guide_achievement"
  """
  guide_achievement_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_achievement_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_achievement_order_by!]

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): guide_achievement_aggregate!

  """
  fetch data from the table: "guide_achievement" using primary key columns
  """
  guide_achievement_by_pk(campaign_id: Int!, id: String!): guide_achievement

  """
  fetch data from the table in a streaming manner: "guide_achievement"
  """
  guide_achievement_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [guide_achievement_stream_cursor_input]!

    """filter the rows returned"""
    where: guide_achievement_bool_exp
  ): [guide_achievement!]!

  """
  fetch data from the table: "guide_input"
  """
  guide_input(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): [guide_input!]!

  """
  fetch aggregated fields from the table: "guide_input"
  """
  guide_input_aggregate(
    """distinct select on columns"""
    distinct_on: [guide_input_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [guide_input_order_by!]

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): guide_input_aggregate!

  """fetch data from the table: "guide_input" using primary key columns"""
  guide_input_by_pk(campaign_id: Int!, id: String!): guide_input

  """
  fetch data from the table in a streaming manner: "guide_input"
  """
  guide_input_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [guide_input_stream_cursor_input]!

    """filter the rows returned"""
    where: guide_input_bool_exp
  ): [guide_input!]!

  """An array relationship"""
  investigator_data(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): [investigator_data!]!

  """An aggregate relationship"""
  investigator_data_aggregate(
    """distinct select on columns"""
    distinct_on: [investigator_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [investigator_data_order_by!]

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): investigator_data_aggregate!

  """
  fetch data from the table: "investigator_data" using primary key columns
  """
  investigator_data_by_pk(campaign_id: Int!, investigator: String!): investigator_data

  """
  fetch data from the table in a streaming manner: "investigator_data"
  """
  investigator_data_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [investigator_data_stream_cursor_input]!

    """filter the rows returned"""
    where: investigator_data_bool_exp
  ): [investigator_data!]!

  """An array relationship"""
  latest_decks(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): [latest_decks!]!

  """An aggregate relationship"""
  latest_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): latest_decks_aggregate!

  """
  fetch data from the table in a streaming manner: "latest_decks"
  """
  latest_decks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [latest_decks_stream_cursor_input]!

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): [latest_decks!]!

  """An array relationship"""
  local_decks(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): [local_decks!]!

  """An aggregate relationship"""
  local_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): local_decks_aggregate!

  """
  fetch data from the table in a streaming manner: "local_decks"
  """
  local_decks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [local_decks_stream_cursor_input]!

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): [local_decks!]!

  """
  fetch data from the table: "pack"
  """
  pack(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): [pack!]!

  """
  fetch aggregated fields from the table: "pack"
  """
  pack_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_order_by!]

    """filter the rows returned"""
    where: pack_bool_exp
  ): pack_aggregate!

  """fetch data from the table: "pack" using primary key columns"""
  pack_by_pk(code: String!): pack

  """
  fetch data from the table: "pack_name"
  """
  pack_name(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): [pack_name!]!

  """
  fetch aggregated fields from the table: "pack_name"
  """
  pack_name_aggregate(
    """distinct select on columns"""
    distinct_on: [pack_name_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pack_name_order_by!]

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): pack_name_aggregate!

  """fetch data from the table: "pack_name" using primary key columns"""
  pack_name_by_pk(code: String!, locale: String!): pack_name

  """
  fetch data from the table in a streaming manner: "pack_name"
  """
  pack_name_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pack_name_stream_cursor_input]!

    """filter the rows returned"""
    where: pack_name_bool_exp
  ): [pack_name!]!

  """
  fetch data from the table in a streaming manner: "pack"
  """
  pack_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pack_stream_cursor_input]!

    """filter the rows returned"""
    where: pack_bool_exp
  ): [pack!]!

  """
  fetch data from the table: "rangers.area"
  """
  rangers_area(
    """distinct select on columns"""
    distinct_on: [rangers_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_order_by!]

    """filter the rows returned"""
    where: rangers_area_bool_exp
  ): [rangers_area!]!

  """
  fetch aggregated fields from the table: "rangers.area"
  """
  rangers_area_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_order_by!]

    """filter the rows returned"""
    where: rangers_area_bool_exp
  ): rangers_area_aggregate!

  """fetch data from the table: "rangers.area" using primary key columns"""
  rangers_area_by_pk(id: String!): rangers_area

  """
  fetch data from the table in a streaming manner: "rangers.area"
  """
  rangers_area_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_area_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_area_bool_exp
  ): [rangers_area!]!

  """
  fetch data from the table: "rangers.area_text"
  """
  rangers_area_text(
    """distinct select on columns"""
    distinct_on: [rangers_area_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_text_order_by!]

    """filter the rows returned"""
    where: rangers_area_text_bool_exp
  ): [rangers_area_text!]!

  """
  fetch aggregated fields from the table: "rangers.area_text"
  """
  rangers_area_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_area_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_area_text_order_by!]

    """filter the rows returned"""
    where: rangers_area_text_bool_exp
  ): rangers_area_text_aggregate!

  """
  fetch data from the table: "rangers.area_text" using primary key columns
  """
  rangers_area_text_by_pk(id: String!, locale: String!): rangers_area_text

  """
  fetch data from the table in a streaming manner: "rangers.area_text"
  """
  rangers_area_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_area_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_area_text_bool_exp
  ): [rangers_area_text!]!

  """
  fetch data from the table: "rangers.aspect"
  """
  rangers_aspect(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_bool_exp
  ): [rangers_aspect!]!

  """
  fetch aggregated fields from the table: "rangers.aspect"
  """
  rangers_aspect_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_bool_exp
  ): rangers_aspect_aggregate!

  """fetch data from the table: "rangers.aspect" using primary key columns"""
  rangers_aspect_by_pk(id: String!): rangers_aspect

  """
  fetch data from the table: "rangers.aspect_localized"
  """
  rangers_aspect_localized(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_localized_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_localized_bool_exp
  ): [rangers_aspect_localized!]!

  """
  fetch aggregated fields from the table: "rangers.aspect_localized"
  """
  rangers_aspect_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_localized_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_localized_bool_exp
  ): rangers_aspect_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.aspect_localized"
  """
  rangers_aspect_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_aspect_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_aspect_localized_bool_exp
  ): [rangers_aspect_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.aspect"
  """
  rangers_aspect_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_aspect_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_aspect_bool_exp
  ): [rangers_aspect!]!

  """
  fetch data from the table: "rangers.aspect_text"
  """
  rangers_aspect_text(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_text_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_text_bool_exp
  ): [rangers_aspect_text!]!

  """
  fetch aggregated fields from the table: "rangers.aspect_text"
  """
  rangers_aspect_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_aspect_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_aspect_text_order_by!]

    """filter the rows returned"""
    where: rangers_aspect_text_bool_exp
  ): rangers_aspect_text_aggregate!

  """
  fetch data from the table: "rangers.aspect_text" using primary key columns
  """
  rangers_aspect_text_by_pk(id: String!, locale: String!): rangers_aspect_text

  """
  fetch data from the table in a streaming manner: "rangers.aspect_text"
  """
  rangers_aspect_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_aspect_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_aspect_text_bool_exp
  ): [rangers_aspect_text!]!

  """
  fetch data from the table: "rangers.campaign"
  """
  rangers_campaign(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): [rangers_campaign!]!

  """
  fetch data from the table: "rangers.campaign_access"
  """
  rangers_campaign_access(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_access_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_access_bool_exp
  ): [rangers_campaign_access!]!

  """
  fetch aggregated fields from the table: "rangers.campaign_access"
  """
  rangers_campaign_access_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_access_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_access_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_access_bool_exp
  ): rangers_campaign_access_aggregate!

  """
  fetch data from the table: "rangers.campaign_access" using primary key columns
  """
  rangers_campaign_access_by_pk(campaign_id: Int!, user_id: String!): rangers_campaign_access

  """
  fetch data from the table in a streaming manner: "rangers.campaign_access"
  """
  rangers_campaign_access_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_campaign_access_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_campaign_access_bool_exp
  ): [rangers_campaign_access!]!

  """
  fetch aggregated fields from the table: "rangers.campaign"
  """
  rangers_campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): rangers_campaign_aggregate!

  """
  fetch data from the table: "rangers.campaign" using primary key columns
  """
  rangers_campaign_by_pk(id: Int!): rangers_campaign

  """
  fetch data from the table in a streaming manner: "rangers.campaign"
  """
  rangers_campaign_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_campaign_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_campaign_bool_exp
  ): [rangers_campaign!]!

  """
  fetch data from the table: "rangers.card"
  """
  rangers_card(
    """distinct select on columns"""
    distinct_on: [rangers_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_order_by!]

    """filter the rows returned"""
    where: rangers_card_bool_exp
  ): [rangers_card!]!

  """
  fetch aggregated fields from the table: "rangers.card"
  """
  rangers_card_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_order_by!]

    """filter the rows returned"""
    where: rangers_card_bool_exp
  ): rangers_card_aggregate!

  """fetch data from the table: "rangers.card" using primary key columns"""
  rangers_card_by_pk(id: String!): rangers_card

  """
  fetch data from the table: "rangers.card_localized"
  """
  rangers_card_localized(
    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): [rangers_card_localized!]!

  """
  fetch aggregated fields from the table: "rangers.card_localized"
  """
  rangers_card_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): rangers_card_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.card_localized"
  """
  rangers_card_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_card_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): [rangers_card_localized!]!

  """
  execute function "rangers.card_search" which returns "rangers.card_localized"
  """
  rangers_card_search(
    """
    input parameters for function "rangers_card_search"
    """
    args: rangers_card_search_args

    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): [rangers_card_localized!]!

  """
  execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized"
  """
  rangers_card_search_aggregate(
    """
    input parameters for function "rangers_card_search_aggregate"
    """
    args: rangers_card_search_args

    """distinct select on columns"""
    distinct_on: [rangers_card_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_localized_order_by!]

    """filter the rows returned"""
    where: rangers_card_localized_bool_exp
  ): rangers_card_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.card"
  """
  rangers_card_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_card_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_card_bool_exp
  ): [rangers_card!]!

  """
  fetch data from the table: "rangers.card_text"
  """
  rangers_card_text(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): [rangers_card_text!]!

  """
  fetch aggregated fields from the table: "rangers.card_text"
  """
  rangers_card_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_text_order_by!]

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): rangers_card_text_aggregate!

  """
  fetch data from the table: "rangers.card_text" using primary key columns
  """
  rangers_card_text_by_pk(id: String!, locale: String!): rangers_card_text

  """
  fetch data from the table in a streaming manner: "rangers.card_text"
  """
  rangers_card_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_card_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_card_text_bool_exp
  ): [rangers_card_text!]!

  """
  fetch data from the table: "rangers.card_updated"
  """
  rangers_card_updated(
    """distinct select on columns"""
    distinct_on: [rangers_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_updated_order_by!]

    """filter the rows returned"""
    where: rangers_card_updated_bool_exp
  ): [rangers_card_updated!]!

  """
  fetch aggregated fields from the table: "rangers.card_updated"
  """
  rangers_card_updated_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_card_updated_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_card_updated_order_by!]

    """filter the rows returned"""
    where: rangers_card_updated_bool_exp
  ): rangers_card_updated_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.card_updated"
  """
  rangers_card_updated_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_card_updated_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_card_updated_bool_exp
  ): [rangers_card_updated!]!

  """
  fetch data from the table: "rangers.comment"
  """
  rangers_comment(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): [rangers_comment!]!

  """
  fetch aggregated fields from the table: "rangers.comment"
  """
  rangers_comment_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_comment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_comment_order_by!]

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): rangers_comment_aggregate!

  """fetch data from the table: "rangers.comment" using primary key columns"""
  rangers_comment_by_pk(id: uuid!): rangers_comment

  """
  fetch data from the table in a streaming manner: "rangers.comment"
  """
  rangers_comment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_comment_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_comment_bool_exp
  ): [rangers_comment!]!

  """
  fetch data from the table: "rangers.deck"
  """
  rangers_deck(
    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): [rangers_deck!]!

  """
  fetch aggregated fields from the table: "rangers.deck"
  """
  rangers_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_order_by!]

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): rangers_deck_aggregate!

  """fetch data from the table: "rangers.deck" using primary key columns"""
  rangers_deck_by_pk(id: Int!): rangers_deck

  """
  fetch data from the table: "rangers.deck_copy"
  """
  rangers_deck_copy(
    """distinct select on columns"""
    distinct_on: [rangers_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_copy_order_by!]

    """filter the rows returned"""
    where: rangers_deck_copy_bool_exp
  ): [rangers_deck_copy!]!

  """
  fetch aggregated fields from the table: "rangers.deck_copy"
  """
  rangers_deck_copy_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_copy_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_copy_order_by!]

    """filter the rows returned"""
    where: rangers_deck_copy_bool_exp
  ): rangers_deck_copy_aggregate!

  """
  fetch data from the table: "rangers.deck_copy" using primary key columns
  """
  rangers_deck_copy_by_pk(copy_deck_id: Int!): rangers_deck_copy

  """
  fetch data from the table in a streaming manner: "rangers.deck_copy"
  """
  rangers_deck_copy_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_deck_copy_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_deck_copy_bool_exp
  ): [rangers_deck_copy!]!

  """
  fetch data from the table: "rangers.deck_like"
  """
  rangers_deck_like(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_bool_exp
  ): [rangers_deck_like!]!

  """
  fetch aggregated fields from the table: "rangers.deck_like"
  """
  rangers_deck_like_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_bool_exp
  ): rangers_deck_like_aggregate!

  """
  fetch data from the table: "rangers.deck_like" using primary key columns
  """
  rangers_deck_like_by_pk(deck_id: Int!, user_id: String!): rangers_deck_like

  """
  fetch data from the table: "rangers.deck_like_count"
  """
  rangers_deck_like_count(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_count_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_count_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_count_bool_exp
  ): [rangers_deck_like_count!]!

  """
  fetch aggregated fields from the table: "rangers.deck_like_count"
  """
  rangers_deck_like_count_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_like_count_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_like_count_order_by!]

    """filter the rows returned"""
    where: rangers_deck_like_count_bool_exp
  ): rangers_deck_like_count_aggregate!

  """
  fetch data from the table: "rangers.deck_like_count" using primary key columns
  """
  rangers_deck_like_count_by_pk(deck_id: Int!): rangers_deck_like_count

  """
  fetch data from the table in a streaming manner: "rangers.deck_like_count"
  """
  rangers_deck_like_count_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_deck_like_count_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_deck_like_count_bool_exp
  ): [rangers_deck_like_count!]!

  """
  fetch data from the table in a streaming manner: "rangers.deck_like"
  """
  rangers_deck_like_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_deck_like_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_deck_like_bool_exp
  ): [rangers_deck_like!]!

  """
  fetch data from the table: "rangers.deck_rank"
  """
  rangers_deck_rank(
    """distinct select on columns"""
    distinct_on: [rangers_deck_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_rank_order_by!]

    """filter the rows returned"""
    where: rangers_deck_rank_bool_exp
  ): [rangers_deck_rank!]!

  """
  fetch aggregated fields from the table: "rangers.deck_rank"
  """
  rangers_deck_rank_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_deck_rank_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_deck_rank_order_by!]

    """filter the rows returned"""
    where: rangers_deck_rank_bool_exp
  ): rangers_deck_rank_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.deck_rank"
  """
  rangers_deck_rank_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_deck_rank_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_deck_rank_bool_exp
  ): [rangers_deck_rank!]!

  """
  execute function "rangers.deck_search" which returns "rangers.search_deck"
  """
  rangers_deck_search(
    """
    input parameters for function "rangers_deck_search"
    """
    args: rangers_deck_search_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck"
  """
  rangers_deck_search_aggregate(
    """
    input parameters for function "rangers_deck_search_aggregate"
    """
    args: rangers_deck_search_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.deck"
  """
  rangers_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_deck_bool_exp
  ): [rangers_deck!]!

  """
  fetch data from the table: "rangers.faq_entry"
  """
  rangers_faq_entry(
    """distinct select on columns"""
    distinct_on: [rangers_faq_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_faq_entry_order_by!]

    """filter the rows returned"""
    where: rangers_faq_entry_bool_exp
  ): [rangers_faq_entry!]!

  """
  fetch aggregated fields from the table: "rangers.faq_entry"
  """
  rangers_faq_entry_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_faq_entry_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_faq_entry_order_by!]

    """filter the rows returned"""
    where: rangers_faq_entry_bool_exp
  ): rangers_faq_entry_aggregate!

  """
  fetch data from the table: "rangers.faq_entry" using primary key columns
  """
  rangers_faq_entry_by_pk(id: String!): rangers_faq_entry

  """
  fetch data from the table in a streaming manner: "rangers.faq_entry"
  """
  rangers_faq_entry_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_faq_entry_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_faq_entry_bool_exp
  ): [rangers_faq_entry!]!

  """
  fetch data from the table: "rangers.friend_status"
  """
  rangers_friend_status(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_bool_exp
  ): [rangers_friend_status!]!

  """
  fetch aggregated fields from the table: "rangers.friend_status"
  """
  rangers_friend_status_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_bool_exp
  ): rangers_friend_status_aggregate!

  """
  fetch data from the table: "rangers.friend_status" using primary key columns
  """
  rangers_friend_status_by_pk(user_id_a: String!, user_id_b: String!): rangers_friend_status

  """
  fetch data from the table in a streaming manner: "rangers.friend_status"
  """
  rangers_friend_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_friend_status_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_friend_status_bool_exp
  ): [rangers_friend_status!]!

  """
  fetch data from the table: "rangers.friend_status_type"
  """
  rangers_friend_status_type(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_type_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_type_bool_exp
  ): [rangers_friend_status_type!]!

  """
  fetch aggregated fields from the table: "rangers.friend_status_type"
  """
  rangers_friend_status_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_friend_status_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_friend_status_type_order_by!]

    """filter the rows returned"""
    where: rangers_friend_status_type_bool_exp
  ): rangers_friend_status_type_aggregate!

  """
  fetch data from the table: "rangers.friend_status_type" using primary key columns
  """
  rangers_friend_status_type_by_pk(value: String!): rangers_friend_status_type

  """
  fetch data from the table in a streaming manner: "rangers.friend_status_type"
  """
  rangers_friend_status_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_friend_status_type_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_friend_status_type_bool_exp
  ): [rangers_friend_status_type!]!

  """
  fetch data from the table: "rangers.latest_deck"
  """
  rangers_latest_deck(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): [rangers_latest_deck!]!

  """
  fetch aggregated fields from the table: "rangers.latest_deck"
  """
  rangers_latest_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_latest_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_latest_deck_order_by!]

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): rangers_latest_deck_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.latest_deck"
  """
  rangers_latest_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_latest_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_latest_deck_bool_exp
  ): [rangers_latest_deck!]!

  """
  fetch data from the table: "rangers.locale"
  """
  rangers_locale(
    """distinct select on columns"""
    distinct_on: [rangers_locale_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_locale_order_by!]

    """filter the rows returned"""
    where: rangers_locale_bool_exp
  ): [rangers_locale!]!

  """
  fetch aggregated fields from the table: "rangers.locale"
  """
  rangers_locale_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_locale_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_locale_order_by!]

    """filter the rows returned"""
    where: rangers_locale_bool_exp
  ): rangers_locale_aggregate!

  """fetch data from the table: "rangers.locale" using primary key columns"""
  rangers_locale_by_pk(locale: String!): rangers_locale

  """
  fetch data from the table in a streaming manner: "rangers.locale"
  """
  rangers_locale_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_locale_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_locale_bool_exp
  ): [rangers_locale!]!

  """
  fetch data from the table: "rangers.pack"
  """
  rangers_pack(
    """distinct select on columns"""
    distinct_on: [rangers_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_order_by!]

    """filter the rows returned"""
    where: rangers_pack_bool_exp
  ): [rangers_pack!]!

  """
  fetch aggregated fields from the table: "rangers.pack"
  """
  rangers_pack_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_order_by!]

    """filter the rows returned"""
    where: rangers_pack_bool_exp
  ): rangers_pack_aggregate!

  """fetch data from the table: "rangers.pack" using primary key columns"""
  rangers_pack_by_pk(id: String!): rangers_pack

  """
  fetch data from the table: "rangers.pack_localized"
  """
  rangers_pack_localized(
    """distinct select on columns"""
    distinct_on: [rangers_pack_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_localized_order_by!]

    """filter the rows returned"""
    where: rangers_pack_localized_bool_exp
  ): [rangers_pack_localized!]!

  """
  fetch aggregated fields from the table: "rangers.pack_localized"
  """
  rangers_pack_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_localized_order_by!]

    """filter the rows returned"""
    where: rangers_pack_localized_bool_exp
  ): rangers_pack_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.pack_localized"
  """
  rangers_pack_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_pack_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_pack_localized_bool_exp
  ): [rangers_pack_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.pack"
  """
  rangers_pack_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_pack_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_pack_bool_exp
  ): [rangers_pack!]!

  """
  fetch data from the table: "rangers.pack_text"
  """
  rangers_pack_text(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): [rangers_pack_text!]!

  """
  fetch aggregated fields from the table: "rangers.pack_text"
  """
  rangers_pack_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_pack_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_pack_text_order_by!]

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): rangers_pack_text_aggregate!

  """
  fetch data from the table: "rangers.pack_text" using primary key columns
  """
  rangers_pack_text_by_pk(id: String!, locale: String!): rangers_pack_text

  """
  fetch data from the table in a streaming manner: "rangers.pack_text"
  """
  rangers_pack_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_pack_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_pack_text_bool_exp
  ): [rangers_pack_text!]!

  """
  execute function "rangers.search_all_decks" which returns "rangers.search_deck"
  """
  rangers_search_all_decks(
    """
    input parameters for function "rangers_search_all_decks"
    """
    args: rangers_search_all_decks_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  execute function "rangers.search_all_decks" and query aggregates on result of table type "rangers.search_deck"
  """
  rangers_search_all_decks_aggregate(
    """
    input parameters for function "rangers_search_all_decks_aggregate"
    """
    args: rangers_search_all_decks_args

    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table: "rangers.search_deck"
  """
  rangers_search_deck(
    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  fetch aggregated fields from the table: "rangers.search_deck"
  """
  rangers_search_deck_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_search_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_search_deck_order_by!]

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): rangers_search_deck_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.search_deck"
  """
  rangers_search_deck_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_search_deck_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_search_deck_bool_exp
  ): [rangers_search_deck!]!

  """
  fetch data from the table: "rangers.set"
  """
  rangers_set(
    """distinct select on columns"""
    distinct_on: [rangers_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_order_by!]

    """filter the rows returned"""
    where: rangers_set_bool_exp
  ): [rangers_set!]!

  """
  fetch aggregated fields from the table: "rangers.set"
  """
  rangers_set_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_order_by!]

    """filter the rows returned"""
    where: rangers_set_bool_exp
  ): rangers_set_aggregate!

  """fetch data from the table: "rangers.set" using primary key columns"""
  rangers_set_by_pk(id: String!): rangers_set

  """
  fetch data from the table: "rangers.set_localized"
  """
  rangers_set_localized(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): [rangers_set_localized!]!

  """
  fetch aggregated fields from the table: "rangers.set_localized"
  """
  rangers_set_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): rangers_set_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.set_localized"
  """
  rangers_set_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_localized_bool_exp
  ): [rangers_set_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.set"
  """
  rangers_set_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_bool_exp
  ): [rangers_set!]!

  """
  fetch data from the table: "rangers.set_text"
  """
  rangers_set_text(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): [rangers_set_text!]!

  """
  fetch aggregated fields from the table: "rangers.set_text"
  """
  rangers_set_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): rangers_set_text_aggregate!

  """
  fetch data from the table: "rangers.set_text" using primary key columns
  """
  rangers_set_text_by_pk(id: String!, locale: String!): rangers_set_text

  """
  fetch data from the table in a streaming manner: "rangers.set_text"
  """
  rangers_set_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_text_bool_exp
  ): [rangers_set_text!]!

  """
  fetch data from the table: "rangers.set_type"
  """
  rangers_set_type(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_bool_exp
  ): [rangers_set_type!]!

  """
  fetch aggregated fields from the table: "rangers.set_type"
  """
  rangers_set_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_bool_exp
  ): rangers_set_type_aggregate!

  """
  fetch data from the table: "rangers.set_type" using primary key columns
  """
  rangers_set_type_by_pk(id: String!): rangers_set_type

  """
  fetch data from the table: "rangers.set_type_localized"
  """
  rangers_set_type_localized(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_localized_bool_exp
  ): [rangers_set_type_localized!]!

  """
  fetch aggregated fields from the table: "rangers.set_type_localized"
  """
  rangers_set_type_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_localized_bool_exp
  ): rangers_set_type_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.set_type_localized"
  """
  rangers_set_type_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_type_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_type_localized_bool_exp
  ): [rangers_set_type_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.set_type"
  """
  rangers_set_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_type_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_type_bool_exp
  ): [rangers_set_type!]!

  """
  fetch data from the table: "rangers.set_type_text"
  """
  rangers_set_type_text(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): [rangers_set_type_text!]!

  """
  fetch aggregated fields from the table: "rangers.set_type_text"
  """
  rangers_set_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_set_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_set_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): rangers_set_type_text_aggregate!

  """
  fetch data from the table: "rangers.set_type_text" using primary key columns
  """
  rangers_set_type_text_by_pk(id: String!, locale: String!): rangers_set_type_text

  """
  fetch data from the table in a streaming manner: "rangers.set_type_text"
  """
  rangers_set_type_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_set_type_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_set_type_text_bool_exp
  ): [rangers_set_type_text!]!

  """
  fetch data from the table: "rangers.subset"
  """
  rangers_subset(
    """distinct select on columns"""
    distinct_on: [rangers_subset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_order_by!]

    """filter the rows returned"""
    where: rangers_subset_bool_exp
  ): [rangers_subset!]!

  """
  fetch aggregated fields from the table: "rangers.subset"
  """
  rangers_subset_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_order_by!]

    """filter the rows returned"""
    where: rangers_subset_bool_exp
  ): rangers_subset_aggregate!

  """fetch data from the table: "rangers.subset" using primary key columns"""
  rangers_subset_by_pk(id: String!): rangers_subset

  """
  fetch data from the table: "rangers.subset_localized"
  """
  rangers_subset_localized(
    """distinct select on columns"""
    distinct_on: [rangers_subset_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_localized_order_by!]

    """filter the rows returned"""
    where: rangers_subset_localized_bool_exp
  ): [rangers_subset_localized!]!

  """
  fetch aggregated fields from the table: "rangers.subset_localized"
  """
  rangers_subset_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_localized_order_by!]

    """filter the rows returned"""
    where: rangers_subset_localized_bool_exp
  ): rangers_subset_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.subset_localized"
  """
  rangers_subset_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_subset_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_subset_localized_bool_exp
  ): [rangers_subset_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.subset"
  """
  rangers_subset_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_subset_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_subset_bool_exp
  ): [rangers_subset!]!

  """
  fetch data from the table: "rangers.subset_text"
  """
  rangers_subset_text(
    """distinct select on columns"""
    distinct_on: [rangers_subset_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_text_order_by!]

    """filter the rows returned"""
    where: rangers_subset_text_bool_exp
  ): [rangers_subset_text!]!

  """
  fetch aggregated fields from the table: "rangers.subset_text"
  """
  rangers_subset_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_subset_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_subset_text_order_by!]

    """filter the rows returned"""
    where: rangers_subset_text_bool_exp
  ): rangers_subset_text_aggregate!

  """
  fetch data from the table: "rangers.subset_text" using primary key columns
  """
  rangers_subset_text_by_pk(id: String!, locale: String!): rangers_subset_text

  """
  fetch data from the table in a streaming manner: "rangers.subset_text"
  """
  rangers_subset_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_subset_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_subset_text_bool_exp
  ): [rangers_subset_text!]!

  """
  fetch data from the table: "rangers.taboo_set"
  """
  rangers_taboo_set(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_bool_exp
  ): [rangers_taboo_set!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set"
  """
  rangers_taboo_set_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_bool_exp
  ): rangers_taboo_set_aggregate!

  """
  fetch data from the table: "rangers.taboo_set" using primary key columns
  """
  rangers_taboo_set_by_pk(id: String!): rangers_taboo_set

  """
  fetch data from the table: "rangers.taboo_set_localized"
  """
  rangers_taboo_set_localized(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_localized_bool_exp
  ): [rangers_taboo_set_localized!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set_localized"
  """
  rangers_taboo_set_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_localized_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_localized_bool_exp
  ): rangers_taboo_set_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.taboo_set_localized"
  """
  rangers_taboo_set_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_taboo_set_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_taboo_set_localized_bool_exp
  ): [rangers_taboo_set_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.taboo_set"
  """
  rangers_taboo_set_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_taboo_set_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_taboo_set_bool_exp
  ): [rangers_taboo_set!]!

  """
  fetch data from the table: "rangers.taboo_set_text"
  """
  rangers_taboo_set_text(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_text_bool_exp
  ): [rangers_taboo_set_text!]!

  """
  fetch aggregated fields from the table: "rangers.taboo_set_text"
  """
  rangers_taboo_set_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_taboo_set_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_taboo_set_text_order_by!]

    """filter the rows returned"""
    where: rangers_taboo_set_text_bool_exp
  ): rangers_taboo_set_text_aggregate!

  """
  fetch data from the table: "rangers.taboo_set_text" using primary key columns
  """
  rangers_taboo_set_text_by_pk(id: String!, locale: String!): rangers_taboo_set_text

  """
  fetch data from the table in a streaming manner: "rangers.taboo_set_text"
  """
  rangers_taboo_set_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_taboo_set_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_taboo_set_text_bool_exp
  ): [rangers_taboo_set_text!]!

  """
  fetch data from the table: "rangers.token"
  """
  rangers_token(
    """distinct select on columns"""
    distinct_on: [rangers_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_order_by!]

    """filter the rows returned"""
    where: rangers_token_bool_exp
  ): [rangers_token!]!

  """
  fetch aggregated fields from the table: "rangers.token"
  """
  rangers_token_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_order_by!]

    """filter the rows returned"""
    where: rangers_token_bool_exp
  ): rangers_token_aggregate!

  """fetch data from the table: "rangers.token" using primary key columns"""
  rangers_token_by_pk(id: String!): rangers_token

  """
  fetch data from the table in a streaming manner: "rangers.token"
  """
  rangers_token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_token_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_token_bool_exp
  ): [rangers_token!]!

  """
  fetch data from the table: "rangers.token_text"
  """
  rangers_token_text(
    """distinct select on columns"""
    distinct_on: [rangers_token_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_text_order_by!]

    """filter the rows returned"""
    where: rangers_token_text_bool_exp
  ): [rangers_token_text!]!

  """
  fetch aggregated fields from the table: "rangers.token_text"
  """
  rangers_token_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_token_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_token_text_order_by!]

    """filter the rows returned"""
    where: rangers_token_text_bool_exp
  ): rangers_token_text_aggregate!

  """
  fetch data from the table: "rangers.token_text" using primary key columns
  """
  rangers_token_text_by_pk(id: String!, locale: String!): rangers_token_text

  """
  fetch data from the table in a streaming manner: "rangers.token_text"
  """
  rangers_token_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_token_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_token_text_bool_exp
  ): [rangers_token_text!]!

  """
  fetch data from the table: "rangers.type"
  """
  rangers_type(
    """distinct select on columns"""
    distinct_on: [rangers_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_order_by!]

    """filter the rows returned"""
    where: rangers_type_bool_exp
  ): [rangers_type!]!

  """
  fetch aggregated fields from the table: "rangers.type"
  """
  rangers_type_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_order_by!]

    """filter the rows returned"""
    where: rangers_type_bool_exp
  ): rangers_type_aggregate!

  """fetch data from the table: "rangers.type" using primary key columns"""
  rangers_type_by_pk(id: String!): rangers_type

  """
  fetch data from the table: "rangers.type_localized"
  """
  rangers_type_localized(
    """distinct select on columns"""
    distinct_on: [rangers_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_type_localized_bool_exp
  ): [rangers_type_localized!]!

  """
  fetch aggregated fields from the table: "rangers.type_localized"
  """
  rangers_type_localized_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_localized_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_localized_order_by!]

    """filter the rows returned"""
    where: rangers_type_localized_bool_exp
  ): rangers_type_localized_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.type_localized"
  """
  rangers_type_localized_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_type_localized_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_type_localized_bool_exp
  ): [rangers_type_localized!]!

  """
  fetch data from the table in a streaming manner: "rangers.type"
  """
  rangers_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_type_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_type_bool_exp
  ): [rangers_type!]!

  """
  fetch data from the table: "rangers.type_text"
  """
  rangers_type_text(
    """distinct select on columns"""
    distinct_on: [rangers_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_type_text_bool_exp
  ): [rangers_type_text!]!

  """
  fetch aggregated fields from the table: "rangers.type_text"
  """
  rangers_type_text_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_type_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_type_text_order_by!]

    """filter the rows returned"""
    where: rangers_type_text_bool_exp
  ): rangers_type_text_aggregate!

  """
  fetch data from the table: "rangers.type_text" using primary key columns
  """
  rangers_type_text_by_pk(id: String!, locale: String!): rangers_type_text

  """
  fetch data from the table in a streaming manner: "rangers.type_text"
  """
  rangers_type_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_type_text_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_type_text_bool_exp
  ): [rangers_type_text!]!

  """
  fetch data from the table: "rangers.user_campaign"
  """
  rangers_user_campaign(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): [rangers_user_campaign!]!

  """
  fetch aggregated fields from the table: "rangers.user_campaign"
  """
  rangers_user_campaign_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_campaign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_campaign_order_by!]

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): rangers_user_campaign_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.user_campaign"
  """
  rangers_user_campaign_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_campaign_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_campaign_bool_exp
  ): [rangers_user_campaign!]!

  """
  fetch data from the table: "rangers.user_friends"
  """
  rangers_user_friends(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): [rangers_user_friends!]!

  """
  fetch aggregated fields from the table: "rangers.user_friends"
  """
  rangers_user_friends_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_friends_order_by!]

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): rangers_user_friends_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.user_friends"
  """
  rangers_user_friends_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_friends_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_friends_bool_exp
  ): [rangers_user_friends!]!

  """
  fetch data from the table: "rangers.user_received_friend_requests"
  """
  rangers_user_received_friend_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): [rangers_user_received_friend_requests!]!

  """
  fetch aggregated fields from the table: "rangers.user_received_friend_requests"
  """
  rangers_user_received_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): rangers_user_received_friend_requests_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.user_received_friend_requests"
  """
  rangers_user_received_friend_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_received_friend_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_received_friend_requests_bool_exp
  ): [rangers_user_received_friend_requests!]!

  """
  fetch data from the table: "rangers.user_role"
  """
  rangers_user_role(
    """distinct select on columns"""
    distinct_on: [rangers_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_role_order_by!]

    """filter the rows returned"""
    where: rangers_user_role_bool_exp
  ): [rangers_user_role!]!

  """
  fetch aggregated fields from the table: "rangers.user_role"
  """
  rangers_user_role_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_role_order_by!]

    """filter the rows returned"""
    where: rangers_user_role_bool_exp
  ): rangers_user_role_aggregate!

  """
  fetch data from the table: "rangers.user_role" using primary key columns
  """
  rangers_user_role_by_pk(id: String!): rangers_user_role

  """
  fetch data from the table in a streaming manner: "rangers.user_role"
  """
  rangers_user_role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_role_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_role_bool_exp
  ): [rangers_user_role!]!

  """
  fetch data from the table: "rangers.user_sent_friend_requests"
  """
  rangers_user_sent_friend_requests(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): [rangers_user_sent_friend_requests!]!

  """
  fetch aggregated fields from the table: "rangers.user_sent_friend_requests"
  """
  rangers_user_sent_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): rangers_user_sent_friend_requests_aggregate!

  """
  fetch data from the table in a streaming manner: "rangers.user_sent_friend_requests"
  """
  rangers_user_sent_friend_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_sent_friend_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_sent_friend_requests_bool_exp
  ): [rangers_user_sent_friend_requests!]!

  """
  fetch data from the table: "rangers.user_settings"
  """
  rangers_user_settings(
    """distinct select on columns"""
    distinct_on: [rangers_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_settings_order_by!]

    """filter the rows returned"""
    where: rangers_user_settings_bool_exp
  ): [rangers_user_settings!]!

  """
  fetch aggregated fields from the table: "rangers.user_settings"
  """
  rangers_user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_user_settings_order_by!]

    """filter the rows returned"""
    where: rangers_user_settings_bool_exp
  ): rangers_user_settings_aggregate!

  """
  fetch data from the table: "rangers.user_settings" using primary key columns
  """
  rangers_user_settings_by_pk(user_id: String!): rangers_user_settings

  """
  fetch data from the table in a streaming manner: "rangers.user_settings"
  """
  rangers_user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_user_settings_bool_exp
  ): [rangers_user_settings!]!

  """
  fetch data from the table: "rangers.users"
  """
  rangers_users(
    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): [rangers_users!]!

  """
  fetch aggregated fields from the table: "rangers.users"
  """
  rangers_users_aggregate(
    """distinct select on columns"""
    distinct_on: [rangers_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rangers_users_order_by!]

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): rangers_users_aggregate!

  """fetch data from the table: "rangers.users" using primary key columns"""
  rangers_users_by_pk(id: String!): rangers_users

  """
  fetch data from the table in a streaming manner: "rangers.users"
  """
  rangers_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [rangers_users_stream_cursor_input]!

    """filter the rows returned"""
    where: rangers_users_bool_exp
  ): [rangers_users!]!

  """
  fetch data from the table: "taboo_set"
  """
  taboo_set(
    """distinct select on columns"""
    distinct_on: [taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [taboo_set_order_by!]

    """filter the rows returned"""
    where: taboo_set_bool_exp
  ): [taboo_set!]!

  """
  fetch aggregated fields from the table: "taboo_set"
  """
  taboo_set_aggregate(
    """distinct select on columns"""
    distinct_on: [taboo_set_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [taboo_set_order_by!]

    """filter the rows returned"""
    where: taboo_set_bool_exp
  ): taboo_set_aggregate!

  """fetch data from the table: "taboo_set" using primary key columns"""
  taboo_set_by_pk(id: Int!): taboo_set

  """
  fetch data from the table in a streaming manner: "taboo_set"
  """
  taboo_set_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [taboo_set_stream_cursor_input]!

    """filter the rows returned"""
    where: taboo_set_bool_exp
  ): [taboo_set!]!

  """
  fetch data from the table: "user_campaigns"
  """
  user_campaigns(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): [user_campaigns!]!

  """
  fetch aggregated fields from the table: "user_campaigns"
  """
  user_campaigns_aggregate(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): user_campaigns_aggregate!

  """
  fetch data from the table in a streaming manner: "user_campaigns"
  """
  user_campaigns_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_campaigns_stream_cursor_input]!

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): [user_campaigns!]!

  """
  fetch data from the table: "user_flag"
  """
  user_flag(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): [user_flag!]!

  """
  fetch aggregated fields from the table: "user_flag"
  """
  user_flag_aggregate(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): user_flag_aggregate!

  """fetch data from the table: "user_flag" using primary key columns"""
  user_flag_by_pk(flag: user_flag_type_enum!, user_id: String!): user_flag

  """
  fetch data from the table in a streaming manner: "user_flag"
  """
  user_flag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_flag_stream_cursor_input]!

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): [user_flag!]!

  """
  fetch data from the table: "user_flag_type"
  """
  user_flag_type(
    """distinct select on columns"""
    distinct_on: [user_flag_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_type_order_by!]

    """filter the rows returned"""
    where: user_flag_type_bool_exp
  ): [user_flag_type!]!

  """
  fetch aggregated fields from the table: "user_flag_type"
  """
  user_flag_type_aggregate(
    """distinct select on columns"""
    distinct_on: [user_flag_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_type_order_by!]

    """filter the rows returned"""
    where: user_flag_type_bool_exp
  ): user_flag_type_aggregate!

  """fetch data from the table: "user_flag_type" using primary key columns"""
  user_flag_type_by_pk(value: String!): user_flag_type

  """
  fetch data from the table in a streaming manner: "user_flag_type"
  """
  user_flag_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_flag_type_stream_cursor_input]!

    """filter the rows returned"""
    where: user_flag_type_bool_exp
  ): [user_flag_type!]!

  """
  fetch data from the table: "user_friends"
  """
  user_friends(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): [user_friends!]!

  """
  fetch aggregated fields from the table: "user_friends"
  """
  user_friends_aggregate(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): user_friends_aggregate!

  """
  fetch data from the table in a streaming manner: "user_friends"
  """
  user_friends_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_friends_stream_cursor_input]!

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): [user_friends!]!

  """
  fetch data from the table: "user_received_friend_requests"
  """
  user_received_friend_requests(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): [user_received_friend_requests!]!

  """
  fetch aggregated fields from the table: "user_received_friend_requests"
  """
  user_received_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): user_received_friend_requests_aggregate!

  """
  fetch data from the table in a streaming manner: "user_received_friend_requests"
  """
  user_received_friend_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_received_friend_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): [user_received_friend_requests!]!

  """
  fetch data from the table: "user_sent_friend_requests"
  """
  user_sent_friend_requests(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): [user_sent_friend_requests!]!

  """
  fetch aggregated fields from the table: "user_sent_friend_requests"
  """
  user_sent_friend_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): user_sent_friend_requests_aggregate!

  """
  fetch data from the table in a streaming manner: "user_sent_friend_requests"
  """
  user_sent_friend_requests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_sent_friend_requests_stream_cursor_input]!

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): [user_sent_friend_requests!]!

  """
  fetch data from the table: "user_settings"
  """
  user_settings(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch aggregated fields from the table: "user_settings"
  """
  user_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_settings_order_by!]

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): user_settings_aggregate!

  """fetch data from the table: "user_settings" using primary key columns"""
  user_settings_by_pk(user_id: String!): user_settings

  """
  fetch data from the table in a streaming manner: "user_settings"
  """
  user_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: user_settings_bool_exp
  ): [user_settings!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: String!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

"""
columns and relationships of "taboo_set"
"""
type taboo_set {
  active: Boolean!
  card_count: Int!

  """An array relationship"""
  cards(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): [all_card!]!

  """An aggregate relationship"""
  cards_aggregate(
    """distinct select on columns"""
    distinct_on: [all_card_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [all_card_order_by!]

    """filter the rows returned"""
    where: all_card_bool_exp
  ): all_card_aggregate!
  code: String!
  current: Boolean!
  date: String!
  id: Int!
  name: String
}

"""
aggregated selection of "taboo_set"
"""
type taboo_set_aggregate {
  aggregate: taboo_set_aggregate_fields
  nodes: [taboo_set!]!
}

"""
aggregate fields of "taboo_set"
"""
type taboo_set_aggregate_fields {
  avg: taboo_set_avg_fields
  count(columns: [taboo_set_select_column!], distinct: Boolean): Int!
  max: taboo_set_max_fields
  min: taboo_set_min_fields
  stddev: taboo_set_stddev_fields
  stddev_pop: taboo_set_stddev_pop_fields
  stddev_samp: taboo_set_stddev_samp_fields
  sum: taboo_set_sum_fields
  var_pop: taboo_set_var_pop_fields
  var_samp: taboo_set_var_samp_fields
  variance: taboo_set_variance_fields
}

"""aggregate avg on columns"""
type taboo_set_avg_fields {
  card_count: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "taboo_set". All fields are combined with a logical 'AND'.
"""
input taboo_set_bool_exp {
  _and: [taboo_set_bool_exp!]
  _not: taboo_set_bool_exp
  _or: [taboo_set_bool_exp!]
  active: Boolean_comparison_exp
  card_count: Int_comparison_exp
  cards: all_card_bool_exp
  cards_aggregate: all_card_aggregate_bool_exp
  code: String_comparison_exp
  current: Boolean_comparison_exp
  date: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "taboo_set"
"""
enum taboo_set_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  taboo_set_pkey
}

"""
input type for incrementing numeric columns in table "taboo_set"
"""
input taboo_set_inc_input {
  card_count: Int
  id: Int
}

"""
input type for inserting data into table "taboo_set"
"""
input taboo_set_insert_input {
  active: Boolean
  card_count: Int
  cards: all_card_arr_rel_insert_input
  code: String
  current: Boolean
  date: String
  id: Int
  name: String
}

"""aggregate max on columns"""
type taboo_set_max_fields {
  card_count: Int
  code: String
  date: String
  id: Int
  name: String
}

"""aggregate min on columns"""
type taboo_set_min_fields {
  card_count: Int
  code: String
  date: String
  id: Int
  name: String
}

"""
response of any mutation on the table "taboo_set"
"""
type taboo_set_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [taboo_set!]!
}

"""
input type for inserting object relation for remote table "taboo_set"
"""
input taboo_set_obj_rel_insert_input {
  data: taboo_set_insert_input!

  """upsert condition"""
  on_conflict: taboo_set_on_conflict
}

"""
on_conflict condition type for table "taboo_set"
"""
input taboo_set_on_conflict {
  constraint: taboo_set_constraint!
  update_columns: [taboo_set_update_column!]! = []
  where: taboo_set_bool_exp
}

"""Ordering options when selecting data from "taboo_set"."""
input taboo_set_order_by {
  active: order_by
  card_count: order_by
  cards_aggregate: all_card_aggregate_order_by
  code: order_by
  current: order_by
  date: order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: taboo_set"""
input taboo_set_pk_columns_input {
  id: Int!
}

"""
select columns of table "taboo_set"
"""
enum taboo_set_select_column {
  """column name"""
  active

  """column name"""
  card_count

  """column name"""
  code

  """column name"""
  current

  """column name"""
  date

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "taboo_set"
"""
input taboo_set_set_input {
  active: Boolean
  card_count: Int
  code: String
  current: Boolean
  date: String
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type taboo_set_stddev_fields {
  card_count: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type taboo_set_stddev_pop_fields {
  card_count: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type taboo_set_stddev_samp_fields {
  card_count: Float
  id: Float
}

"""
Streaming cursor of the table "taboo_set"
"""
input taboo_set_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: taboo_set_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input taboo_set_stream_cursor_value_input {
  active: Boolean
  card_count: Int
  code: String
  current: Boolean
  date: String
  id: Int
  name: String
}

"""aggregate sum on columns"""
type taboo_set_sum_fields {
  card_count: Int
  id: Int
}

"""
update columns of table "taboo_set"
"""
enum taboo_set_update_column {
  """column name"""
  active

  """column name"""
  card_count

  """column name"""
  code

  """column name"""
  current

  """column name"""
  date

  """column name"""
  id

  """column name"""
  name
}

input taboo_set_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: taboo_set_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: taboo_set_set_input

  """filter the rows which have to be updated"""
  where: taboo_set_bool_exp!
}

"""aggregate var_pop on columns"""
type taboo_set_var_pop_fields {
  card_count: Float
  id: Float
}

"""aggregate var_samp on columns"""
type taboo_set_var_samp_fields {
  card_count: Float
  id: Float
}

"""aggregate variance on columns"""
type taboo_set_variance_fields {
  card_count: Float
  id: Float
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_campaigns"
"""
type user_campaigns {
  """An object relationship"""
  campaign: campaign
  campaign_id: Int
  id: Int
  user_id: String
}

"""
aggregated selection of "user_campaigns"
"""
type user_campaigns_aggregate {
  aggregate: user_campaigns_aggregate_fields
  nodes: [user_campaigns!]!
}

input user_campaigns_aggregate_bool_exp {
  count: user_campaigns_aggregate_bool_exp_count
}

input user_campaigns_aggregate_bool_exp_count {
  arguments: [user_campaigns_select_column!]
  distinct: Boolean
  filter: user_campaigns_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_campaigns"
"""
type user_campaigns_aggregate_fields {
  avg: user_campaigns_avg_fields
  count(columns: [user_campaigns_select_column!], distinct: Boolean): Int!
  max: user_campaigns_max_fields
  min: user_campaigns_min_fields
  stddev: user_campaigns_stddev_fields
  stddev_pop: user_campaigns_stddev_pop_fields
  stddev_samp: user_campaigns_stddev_samp_fields
  sum: user_campaigns_sum_fields
  var_pop: user_campaigns_var_pop_fields
  var_samp: user_campaigns_var_samp_fields
  variance: user_campaigns_variance_fields
}

"""
order by aggregate values of table "user_campaigns"
"""
input user_campaigns_aggregate_order_by {
  avg: user_campaigns_avg_order_by
  count: order_by
  max: user_campaigns_max_order_by
  min: user_campaigns_min_order_by
  stddev: user_campaigns_stddev_order_by
  stddev_pop: user_campaigns_stddev_pop_order_by
  stddev_samp: user_campaigns_stddev_samp_order_by
  sum: user_campaigns_sum_order_by
  var_pop: user_campaigns_var_pop_order_by
  var_samp: user_campaigns_var_samp_order_by
  variance: user_campaigns_variance_order_by
}

"""
input type for inserting array relation for remote table "user_campaigns"
"""
input user_campaigns_arr_rel_insert_input {
  data: [user_campaigns_insert_input!]!
}

"""aggregate avg on columns"""
type user_campaigns_avg_fields {
  campaign_id: Float
  id: Float
}

"""
order by avg() on columns of table "user_campaigns"
"""
input user_campaigns_avg_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "user_campaigns". All fields are combined with a logical 'AND'.
"""
input user_campaigns_bool_exp {
  _and: [user_campaigns_bool_exp!]
  _not: user_campaigns_bool_exp
  _or: [user_campaigns_bool_exp!]
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  id: Int_comparison_exp
  user_id: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "user_campaigns"
"""
input user_campaigns_inc_input {
  campaign_id: Int
  id: Int
}

"""
input type for inserting data into table "user_campaigns"
"""
input user_campaigns_insert_input {
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  id: Int
  user_id: String
}

"""aggregate max on columns"""
type user_campaigns_max_fields {
  campaign_id: Int
  id: Int
  user_id: String
}

"""
order by max() on columns of table "user_campaigns"
"""
input user_campaigns_max_order_by {
  campaign_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_campaigns_min_fields {
  campaign_id: Int
  id: Int
  user_id: String
}

"""
order by min() on columns of table "user_campaigns"
"""
input user_campaigns_min_order_by {
  campaign_id: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_campaigns"
"""
type user_campaigns_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_campaigns!]!
}

"""Ordering options when selecting data from "user_campaigns"."""
input user_campaigns_order_by {
  campaign: campaign_order_by
  campaign_id: order_by
  id: order_by
  user_id: order_by
}

"""
select columns of table "user_campaigns"
"""
enum user_campaigns_select_column {
  """column name"""
  campaign_id

  """column name"""
  id

  """column name"""
  user_id
}

"""
input type for updating data in table "user_campaigns"
"""
input user_campaigns_set_input {
  campaign_id: Int
  id: Int
  user_id: String
}

"""aggregate stddev on columns"""
type user_campaigns_stddev_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev() on columns of table "user_campaigns"
"""
input user_campaigns_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type user_campaigns_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "user_campaigns"
"""
input user_campaigns_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type user_campaigns_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "user_campaigns"
"""
input user_campaigns_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "user_campaigns"
"""
input user_campaigns_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_campaigns_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_campaigns_stream_cursor_value_input {
  campaign_id: Int
  id: Int
  user_id: String
}

"""aggregate sum on columns"""
type user_campaigns_sum_fields {
  campaign_id: Int
  id: Int
}

"""
order by sum() on columns of table "user_campaigns"
"""
input user_campaigns_sum_order_by {
  campaign_id: order_by
  id: order_by
}

input user_campaigns_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_campaigns_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_campaigns_set_input

  """filter the rows which have to be updated"""
  where: user_campaigns_bool_exp!
}

"""aggregate var_pop on columns"""
type user_campaigns_var_pop_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "user_campaigns"
"""
input user_campaigns_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type user_campaigns_var_samp_fields {
  campaign_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "user_campaigns"
"""
input user_campaigns_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type user_campaigns_variance_fields {
  campaign_id: Float
  id: Float
}

"""
order by variance() on columns of table "user_campaigns"
"""
input user_campaigns_variance_order_by {
  campaign_id: order_by
  id: order_by
}

"""
columns and relationships of "user_flag"
"""
type user_flag {
  flag: user_flag_type_enum!

  """An object relationship"""
  user: users!
  user_id: String!
}

"""
aggregated selection of "user_flag"
"""
type user_flag_aggregate {
  aggregate: user_flag_aggregate_fields
  nodes: [user_flag!]!
}

input user_flag_aggregate_bool_exp {
  count: user_flag_aggregate_bool_exp_count
}

input user_flag_aggregate_bool_exp_count {
  arguments: [user_flag_select_column!]
  distinct: Boolean
  filter: user_flag_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_flag"
"""
type user_flag_aggregate_fields {
  count(columns: [user_flag_select_column!], distinct: Boolean): Int!
  max: user_flag_max_fields
  min: user_flag_min_fields
}

"""
order by aggregate values of table "user_flag"
"""
input user_flag_aggregate_order_by {
  count: order_by
  max: user_flag_max_order_by
  min: user_flag_min_order_by
}

"""
input type for inserting array relation for remote table "user_flag"
"""
input user_flag_arr_rel_insert_input {
  data: [user_flag_insert_input!]!

  """upsert condition"""
  on_conflict: user_flag_on_conflict
}

"""
Boolean expression to filter rows from the table "user_flag". All fields are combined with a logical 'AND'.
"""
input user_flag_bool_exp {
  _and: [user_flag_bool_exp!]
  _not: user_flag_bool_exp
  _or: [user_flag_bool_exp!]
  flag: user_flag_type_enum_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "user_flag"
"""
enum user_flag_constraint {
  """
  unique or primary key constraint on columns "user_id", "flag"
  """
  user_flag_pkey
}

"""
input type for inserting data into table "user_flag"
"""
input user_flag_insert_input {
  flag: user_flag_type_enum
  user: users_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type user_flag_max_fields {
  user_id: String
}

"""
order by max() on columns of table "user_flag"
"""
input user_flag_max_order_by {
  user_id: order_by
}

"""aggregate min on columns"""
type user_flag_min_fields {
  user_id: String
}

"""
order by min() on columns of table "user_flag"
"""
input user_flag_min_order_by {
  user_id: order_by
}

"""
response of any mutation on the table "user_flag"
"""
type user_flag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_flag!]!
}

"""
on_conflict condition type for table "user_flag"
"""
input user_flag_on_conflict {
  constraint: user_flag_constraint!
  update_columns: [user_flag_update_column!]! = []
  where: user_flag_bool_exp
}

"""Ordering options when selecting data from "user_flag"."""
input user_flag_order_by {
  flag: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_flag"""
input user_flag_pk_columns_input {
  flag: user_flag_type_enum!
  user_id: String!
}

"""
select columns of table "user_flag"
"""
enum user_flag_select_column {
  """column name"""
  flag

  """column name"""
  user_id
}

"""
input type for updating data in table "user_flag"
"""
input user_flag_set_input {
  flag: user_flag_type_enum
  user_id: String
}

"""
Streaming cursor of the table "user_flag"
"""
input user_flag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_flag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_flag_stream_cursor_value_input {
  flag: user_flag_type_enum
  user_id: String
}

"""
columns and relationships of "user_flag_type"
"""
type user_flag_type {
  value: String!
}

"""
aggregated selection of "user_flag_type"
"""
type user_flag_type_aggregate {
  aggregate: user_flag_type_aggregate_fields
  nodes: [user_flag_type!]!
}

"""
aggregate fields of "user_flag_type"
"""
type user_flag_type_aggregate_fields {
  count(columns: [user_flag_type_select_column!], distinct: Boolean): Int!
  max: user_flag_type_max_fields
  min: user_flag_type_min_fields
}

"""
Boolean expression to filter rows from the table "user_flag_type". All fields are combined with a logical 'AND'.
"""
input user_flag_type_bool_exp {
  _and: [user_flag_type_bool_exp!]
  _not: user_flag_type_bool_exp
  _or: [user_flag_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "user_flag_type"
"""
enum user_flag_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  user_flag_type_pkey
}

enum user_flag_type_enum {
  admin
  es_dv
  es_dv_admin
}

"""
Boolean expression to compare columns of type "user_flag_type_enum". All fields are combined with logical 'AND'.
"""
input user_flag_type_enum_comparison_exp {
  _eq: user_flag_type_enum
  _in: [user_flag_type_enum!]
  _is_null: Boolean
  _neq: user_flag_type_enum
  _nin: [user_flag_type_enum!]
}

"""
input type for inserting data into table "user_flag_type"
"""
input user_flag_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type user_flag_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type user_flag_type_min_fields {
  value: String
}

"""
response of any mutation on the table "user_flag_type"
"""
type user_flag_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_flag_type!]!
}

"""
on_conflict condition type for table "user_flag_type"
"""
input user_flag_type_on_conflict {
  constraint: user_flag_type_constraint!
  update_columns: [user_flag_type_update_column!]! = []
  where: user_flag_type_bool_exp
}

"""Ordering options when selecting data from "user_flag_type"."""
input user_flag_type_order_by {
  value: order_by
}

"""primary key columns input for table: user_flag_type"""
input user_flag_type_pk_columns_input {
  value: String!
}

"""
select columns of table "user_flag_type"
"""
enum user_flag_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "user_flag_type"
"""
input user_flag_type_set_input {
  value: String
}

"""
Streaming cursor of the table "user_flag_type"
"""
input user_flag_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_flag_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_flag_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "user_flag_type"
"""
enum user_flag_type_update_column {
  """column name"""
  value
}

input user_flag_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_flag_type_set_input

  """filter the rows which have to be updated"""
  where: user_flag_type_bool_exp!
}

"""
update columns of table "user_flag"
"""
enum user_flag_update_column {
  """column name"""
  flag

  """column name"""
  user_id
}

input user_flag_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_flag_set_input

  """filter the rows which have to be updated"""
  where: user_flag_bool_exp!
}

"""
columns and relationships of "user_friends"
"""
type user_friends {
  status: String

  """An object relationship"""
  user: users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "user_friends"
"""
type user_friends_aggregate {
  aggregate: user_friends_aggregate_fields
  nodes: [user_friends!]!
}

input user_friends_aggregate_bool_exp {
  count: user_friends_aggregate_bool_exp_count
}

input user_friends_aggregate_bool_exp_count {
  arguments: [user_friends_select_column!]
  distinct: Boolean
  filter: user_friends_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_friends"
"""
type user_friends_aggregate_fields {
  count(columns: [user_friends_select_column!], distinct: Boolean): Int!
  max: user_friends_max_fields
  min: user_friends_min_fields
}

"""
order by aggregate values of table "user_friends"
"""
input user_friends_aggregate_order_by {
  count: order_by
  max: user_friends_max_order_by
  min: user_friends_min_order_by
}

"""
input type for inserting array relation for remote table "user_friends"
"""
input user_friends_arr_rel_insert_input {
  data: [user_friends_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_friends". All fields are combined with a logical 'AND'.
"""
input user_friends_bool_exp {
  _and: [user_friends_bool_exp!]
  _not: user_friends_bool_exp
  _or: [user_friends_bool_exp!]
  status: String_comparison_exp
  user: users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "user_friends"
"""
input user_friends_insert_input {
  status: String
  user: users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type user_friends_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "user_friends"
"""
input user_friends_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type user_friends_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "user_friends"
"""
input user_friends_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "user_friends"
"""
type user_friends_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_friends!]!
}

"""Ordering options when selecting data from "user_friends"."""
input user_friends_order_by {
  status: order_by
  user: users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "user_friends"
"""
enum user_friends_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "user_friends"
"""
input user_friends_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "user_friends"
"""
input user_friends_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_friends_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_friends_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input user_friends_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_friends_set_input

  """filter the rows which have to be updated"""
  where: user_friends_bool_exp!
}

"""
columns and relationships of "user_received_friend_requests"
"""
type user_received_friend_requests {
  status: String

  """An object relationship"""
  user: users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "user_received_friend_requests"
"""
type user_received_friend_requests_aggregate {
  aggregate: user_received_friend_requests_aggregate_fields
  nodes: [user_received_friend_requests!]!
}

input user_received_friend_requests_aggregate_bool_exp {
  count: user_received_friend_requests_aggregate_bool_exp_count
}

input user_received_friend_requests_aggregate_bool_exp_count {
  arguments: [user_received_friend_requests_select_column!]
  distinct: Boolean
  filter: user_received_friend_requests_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_received_friend_requests"
"""
type user_received_friend_requests_aggregate_fields {
  count(columns: [user_received_friend_requests_select_column!], distinct: Boolean): Int!
  max: user_received_friend_requests_max_fields
  min: user_received_friend_requests_min_fields
}

"""
order by aggregate values of table "user_received_friend_requests"
"""
input user_received_friend_requests_aggregate_order_by {
  count: order_by
  max: user_received_friend_requests_max_order_by
  min: user_received_friend_requests_min_order_by
}

"""
input type for inserting array relation for remote table "user_received_friend_requests"
"""
input user_received_friend_requests_arr_rel_insert_input {
  data: [user_received_friend_requests_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_received_friend_requests". All fields are combined with a logical 'AND'.
"""
input user_received_friend_requests_bool_exp {
  _and: [user_received_friend_requests_bool_exp!]
  _not: user_received_friend_requests_bool_exp
  _or: [user_received_friend_requests_bool_exp!]
  status: String_comparison_exp
  user: users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "user_received_friend_requests"
"""
input user_received_friend_requests_insert_input {
  status: String
  user: users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type user_received_friend_requests_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "user_received_friend_requests"
"""
input user_received_friend_requests_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type user_received_friend_requests_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "user_received_friend_requests"
"""
input user_received_friend_requests_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "user_received_friend_requests"
"""
type user_received_friend_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_received_friend_requests!]!
}

"""
Ordering options when selecting data from "user_received_friend_requests".
"""
input user_received_friend_requests_order_by {
  status: order_by
  user: users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "user_received_friend_requests"
"""
enum user_received_friend_requests_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "user_received_friend_requests"
"""
input user_received_friend_requests_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "user_received_friend_requests"
"""
input user_received_friend_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_received_friend_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_received_friend_requests_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input user_received_friend_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_received_friend_requests_set_input

  """filter the rows which have to be updated"""
  where: user_received_friend_requests_bool_exp!
}

"""
columns and relationships of "user_sent_friend_requests"
"""
type user_sent_friend_requests {
  status: String

  """An object relationship"""
  user: users
  user_id_a: String
  user_id_b: String
}

"""
aggregated selection of "user_sent_friend_requests"
"""
type user_sent_friend_requests_aggregate {
  aggregate: user_sent_friend_requests_aggregate_fields
  nodes: [user_sent_friend_requests!]!
}

input user_sent_friend_requests_aggregate_bool_exp {
  count: user_sent_friend_requests_aggregate_bool_exp_count
}

input user_sent_friend_requests_aggregate_bool_exp_count {
  arguments: [user_sent_friend_requests_select_column!]
  distinct: Boolean
  filter: user_sent_friend_requests_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_sent_friend_requests"
"""
type user_sent_friend_requests_aggregate_fields {
  count(columns: [user_sent_friend_requests_select_column!], distinct: Boolean): Int!
  max: user_sent_friend_requests_max_fields
  min: user_sent_friend_requests_min_fields
}

"""
order by aggregate values of table "user_sent_friend_requests"
"""
input user_sent_friend_requests_aggregate_order_by {
  count: order_by
  max: user_sent_friend_requests_max_order_by
  min: user_sent_friend_requests_min_order_by
}

"""
input type for inserting array relation for remote table "user_sent_friend_requests"
"""
input user_sent_friend_requests_arr_rel_insert_input {
  data: [user_sent_friend_requests_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_sent_friend_requests". All fields are combined with a logical 'AND'.
"""
input user_sent_friend_requests_bool_exp {
  _and: [user_sent_friend_requests_bool_exp!]
  _not: user_sent_friend_requests_bool_exp
  _or: [user_sent_friend_requests_bool_exp!]
  status: String_comparison_exp
  user: users_bool_exp
  user_id_a: String_comparison_exp
  user_id_b: String_comparison_exp
}

"""
input type for inserting data into table "user_sent_friend_requests"
"""
input user_sent_friend_requests_insert_input {
  status: String
  user: users_obj_rel_insert_input
  user_id_a: String
  user_id_b: String
}

"""aggregate max on columns"""
type user_sent_friend_requests_max_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by max() on columns of table "user_sent_friend_requests"
"""
input user_sent_friend_requests_max_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""aggregate min on columns"""
type user_sent_friend_requests_min_fields {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
order by min() on columns of table "user_sent_friend_requests"
"""
input user_sent_friend_requests_min_order_by {
  status: order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
response of any mutation on the table "user_sent_friend_requests"
"""
type user_sent_friend_requests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_sent_friend_requests!]!
}

"""Ordering options when selecting data from "user_sent_friend_requests"."""
input user_sent_friend_requests_order_by {
  status: order_by
  user: users_order_by
  user_id_a: order_by
  user_id_b: order_by
}

"""
select columns of table "user_sent_friend_requests"
"""
enum user_sent_friend_requests_select_column {
  """column name"""
  status

  """column name"""
  user_id_a

  """column name"""
  user_id_b
}

"""
input type for updating data in table "user_sent_friend_requests"
"""
input user_sent_friend_requests_set_input {
  status: String
  user_id_a: String
  user_id_b: String
}

"""
Streaming cursor of the table "user_sent_friend_requests"
"""
input user_sent_friend_requests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_sent_friend_requests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_sent_friend_requests_stream_cursor_value_input {
  status: String
  user_id_a: String
  user_id_b: String
}

input user_sent_friend_requests_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_sent_friend_requests_set_input

  """filter the rows which have to be updated"""
  where: user_sent_friend_requests_bool_exp!
}

"""
columns and relationships of "user_settings"
"""
type user_settings {
  alphabetize: Boolean
  campaign_show_deck_id: Boolean
  colorblind: Boolean
  custom_content: Boolean
  ignore_collection: Boolean
  in_collection(
    """JSON select path"""
    path: String
  ): jsonb
  onboarding(
    """JSON select path"""
    path: String
  ): jsonb
  show_spoilers(
    """JSON select path"""
    path: String
  ): jsonb
  single_card: Boolean
  sort_quotes: Boolean
  user_id: String!
}

"""
aggregated selection of "user_settings"
"""
type user_settings_aggregate {
  aggregate: user_settings_aggregate_fields
  nodes: [user_settings!]!
}

"""
aggregate fields of "user_settings"
"""
type user_settings_aggregate_fields {
  count(columns: [user_settings_select_column!], distinct: Boolean): Int!
  max: user_settings_max_fields
  min: user_settings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_settings_append_input {
  in_collection: jsonb
  onboarding: jsonb
  show_spoilers: jsonb
}

"""
Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'.
"""
input user_settings_bool_exp {
  _and: [user_settings_bool_exp!]
  _not: user_settings_bool_exp
  _or: [user_settings_bool_exp!]
  alphabetize: Boolean_comparison_exp
  campaign_show_deck_id: Boolean_comparison_exp
  colorblind: Boolean_comparison_exp
  custom_content: Boolean_comparison_exp
  ignore_collection: Boolean_comparison_exp
  in_collection: jsonb_comparison_exp
  onboarding: jsonb_comparison_exp
  show_spoilers: jsonb_comparison_exp
  single_card: Boolean_comparison_exp
  sort_quotes: Boolean_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "user_settings"
"""
enum user_settings_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  user_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_settings_delete_at_path_input {
  in_collection: [String!]
  onboarding: [String!]
  show_spoilers: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_settings_delete_elem_input {
  in_collection: Int
  onboarding: Int
  show_spoilers: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_settings_delete_key_input {
  in_collection: String
  onboarding: String
  show_spoilers: String
}

"""
input type for inserting data into table "user_settings"
"""
input user_settings_insert_input {
  alphabetize: Boolean
  campaign_show_deck_id: Boolean
  colorblind: Boolean
  custom_content: Boolean
  ignore_collection: Boolean
  in_collection: jsonb
  onboarding: jsonb
  show_spoilers: jsonb
  single_card: Boolean
  sort_quotes: Boolean
  user_id: String
}

"""aggregate max on columns"""
type user_settings_max_fields {
  user_id: String
}

"""aggregate min on columns"""
type user_settings_min_fields {
  user_id: String
}

"""
response of any mutation on the table "user_settings"
"""
type user_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_settings!]!
}

"""
on_conflict condition type for table "user_settings"
"""
input user_settings_on_conflict {
  constraint: user_settings_constraint!
  update_columns: [user_settings_update_column!]! = []
  where: user_settings_bool_exp
}

"""Ordering options when selecting data from "user_settings"."""
input user_settings_order_by {
  alphabetize: order_by
  campaign_show_deck_id: order_by
  colorblind: order_by
  custom_content: order_by
  ignore_collection: order_by
  in_collection: order_by
  onboarding: order_by
  show_spoilers: order_by
  single_card: order_by
  sort_quotes: order_by
  user_id: order_by
}

"""primary key columns input for table: user_settings"""
input user_settings_pk_columns_input {
  user_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_settings_prepend_input {
  in_collection: jsonb
  onboarding: jsonb
  show_spoilers: jsonb
}

"""
select columns of table "user_settings"
"""
enum user_settings_select_column {
  """column name"""
  alphabetize

  """column name"""
  campaign_show_deck_id

  """column name"""
  colorblind

  """column name"""
  custom_content

  """column name"""
  ignore_collection

  """column name"""
  in_collection

  """column name"""
  onboarding

  """column name"""
  show_spoilers

  """column name"""
  single_card

  """column name"""
  sort_quotes

  """column name"""
  user_id
}

"""
input type for updating data in table "user_settings"
"""
input user_settings_set_input {
  alphabetize: Boolean
  campaign_show_deck_id: Boolean
  colorblind: Boolean
  custom_content: Boolean
  ignore_collection: Boolean
  in_collection: jsonb
  onboarding: jsonb
  show_spoilers: jsonb
  single_card: Boolean
  sort_quotes: Boolean
  user_id: String
}

"""
Streaming cursor of the table "user_settings"
"""
input user_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_settings_stream_cursor_value_input {
  alphabetize: Boolean
  campaign_show_deck_id: Boolean
  colorblind: Boolean
  custom_content: Boolean
  ignore_collection: Boolean
  in_collection: jsonb
  onboarding: jsonb
  show_spoilers: jsonb
  single_card: Boolean
  sort_quotes: Boolean
  user_id: String
}

"""
update columns of table "user_settings"
"""
enum user_settings_update_column {
  """column name"""
  alphabetize

  """column name"""
  campaign_show_deck_id

  """column name"""
  colorblind

  """column name"""
  custom_content

  """column name"""
  ignore_collection

  """column name"""
  in_collection

  """column name"""
  onboarding

  """column name"""
  show_spoilers

  """column name"""
  single_card

  """column name"""
  sort_quotes

  """column name"""
  user_id
}

input user_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_settings_set_input

  """filter the rows which have to be updated"""
  where: user_settings_bool_exp!
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  all_decks(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): [campaign_deck!]!

  """An aggregate relationship"""
  all_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [campaign_deck_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [campaign_deck_order_by!]

    """filter the rows returned"""
    where: campaign_deck_bool_exp
  ): campaign_deck_aggregate!

  """An array relationship"""
  campaigns(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): [user_campaigns!]!

  """An aggregate relationship"""
  campaigns_aggregate(
    """distinct select on columns"""
    distinct_on: [user_campaigns_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_campaigns_order_by!]

    """filter the rows returned"""
    where: user_campaigns_bool_exp
  ): user_campaigns_aggregate!
  created_at: timestamptz!

  """An array relationship"""
  decks(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): [latest_decks!]!

  """An aggregate relationship"""
  decks_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_decks_order_by!]

    """filter the rows returned"""
    where: latest_decks_bool_exp
  ): latest_decks_aggregate!

  """An array relationship"""
  flags(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): [user_flag!]!

  """An aggregate relationship"""
  flags_aggregate(
    """distinct select on columns"""
    distinct_on: [user_flag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_flag_order_by!]

    """filter the rows returned"""
    where: user_flag_bool_exp
  ): user_flag_aggregate!

  """An array relationship"""
  friends(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): [user_friends!]!

  """An aggregate relationship"""
  friends_aggregate(
    """distinct select on columns"""
    distinct_on: [user_friends_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_friends_order_by!]

    """filter the rows returned"""
    where: user_friends_bool_exp
  ): user_friends_aggregate!
  handle: String
  id: String!

  """An array relationship"""
  local_decks(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): [local_decks!]!

  """An aggregate relationship"""
  local_decks_aggregate(
    """distinct select on columns"""
    distinct_on: [local_decks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [local_decks_order_by!]

    """filter the rows returned"""
    where: local_decks_bool_exp
  ): local_decks_aggregate!
  normalized_handle: String

  """An array relationship"""
  received_requests(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): [user_received_friend_requests!]!

  """An aggregate relationship"""
  received_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_received_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_received_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_received_friend_requests_bool_exp
  ): user_received_friend_requests_aggregate!

  """An array relationship"""
  sent_requests(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): [user_sent_friend_requests!]!

  """An aggregate relationship"""
  sent_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [user_sent_friend_requests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_sent_friend_requests_order_by!]

    """filter the rows returned"""
    where: user_sent_friend_requests_bool_exp
  ): user_sent_friend_requests_aggregate!
  updated_at: timestamp!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  all_decks: campaign_deck_bool_exp
  all_decks_aggregate: campaign_deck_aggregate_bool_exp
  campaigns: user_campaigns_bool_exp
  campaigns_aggregate: user_campaigns_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  decks: latest_decks_bool_exp
  decks_aggregate: latest_decks_aggregate_bool_exp
  flags: user_flag_bool_exp
  flags_aggregate: user_flag_aggregate_bool_exp
  friends: user_friends_bool_exp
  friends_aggregate: user_friends_aggregate_bool_exp
  handle: String_comparison_exp
  id: String_comparison_exp
  local_decks: local_decks_bool_exp
  local_decks_aggregate: local_decks_aggregate_bool_exp
  normalized_handle: String_comparison_exp
  received_requests: user_received_friend_requests_bool_exp
  received_requests_aggregate: user_received_friend_requests_aggregate_bool_exp
  sent_requests: user_sent_friend_requests_bool_exp
  sent_requests_aggregate: user_sent_friend_requests_aggregate_bool_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "normalized_handle"
  """
  users_normalized_handle_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  all_decks: campaign_deck_arr_rel_insert_input
  campaigns: user_campaigns_arr_rel_insert_input
  created_at: timestamptz
  decks: latest_decks_arr_rel_insert_input
  flags: user_flag_arr_rel_insert_input
  friends: user_friends_arr_rel_insert_input
  handle: String
  id: String
  local_decks: local_decks_arr_rel_insert_input
  normalized_handle: String
  received_requests: user_received_friend_requests_arr_rel_insert_input
  sent_requests: user_sent_friend_requests_arr_rel_insert_input
  updated_at: timestamp
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamp
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamp
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  all_decks_aggregate: campaign_deck_aggregate_order_by
  campaigns_aggregate: user_campaigns_aggregate_order_by
  created_at: order_by
  decks_aggregate: latest_decks_aggregate_order_by
  flags_aggregate: user_flag_aggregate_order_by
  friends_aggregate: user_friends_aggregate_order_by
  handle: order_by
  id: order_by
  local_decks_aggregate: local_decks_aggregate_order_by
  normalized_handle: order_by
  received_requests_aggregate: user_received_friend_requests_aggregate_order_by
  sent_requests_aggregate: user_sent_friend_requests_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: String!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamp
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  created_at: timestamptz
  handle: String
  id: String
  normalized_handle: String
  updated_at: timestamp
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  created_at

  """column name"""
  handle

  """column name"""
  id

  """column name"""
  normalized_handle

  """column name"""
  updated_at
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

